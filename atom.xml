<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>冰冻橘子的自留地</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.onebug.tech/"/>
  <updated>2021-05-04T01:43:11.609Z</updated>
  <id>http://www.onebug.tech/</id>
  
  <author>
    <name>冰冻橘子</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>死锁</title>
    <link href="http://www.onebug.tech/2021/05/08/ch12%E6%AD%BB%E9%94%81/"/>
    <id>http://www.onebug.tech/2021/05/08/ch12%E6%AD%BB%E9%94%81/</id>
    <published>2021-05-07T16:00:00.000Z</published>
    <updated>2021-05-04T01:43:11.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>通俗的说，死锁就是两个或者多个线程，相互占用对方需要的资源，而都不进行释放，导致彼此之间都相互等待对方释放资源，产生了无限制等待的现象。死锁一旦发生，如果没有外力介入，这种等待将永远存在，从而对程序产生严重影响。用来描述死锁的问题最有名的场景就是“哲学家就餐问题”。</p><a id="more"></a><h3 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h3><ul><li>互斥条件：进程对锁分配的资源进行排他性使用</li><li>请求和保持条件：线程已经保持了一个资源，但是又提出了其他请求，而该资源已被其他线程占用</li><li>不剥夺条件：在使用时不能被剥夺，只能自己用完释放</li><li>环路等待条件：资源调用是一个环形的链</li></ul><h2 id="死锁示例"><a href="#死锁示例" class="headerlink" title="死锁示例"></a>死锁示例</h2><pre><code>@Slf4jpublic class DeadLock implements Runnable {    public int flag = 1;    //静态对象是类的所有对象共享的    private static Object o1 = new Object(), o2 = new Object();    @Override    public void run() {        log.info(&quot;flag:{}&quot;, flag);        if (flag == 1) {            synchronized (o1) {                try {                    Thread.sleep(500);                } catch (Exception e) {                    e.printStackTrace();                }                synchronized (o2) {                    log.info(&quot;1&quot;);                }            }        }        if (flag == 0) {            synchronized (o2) {                try {                    Thread.sleep(500);                } catch (Exception e) {                    e.printStackTrace();                }                synchronized (o1) {                    log.info(&quot;0&quot;);                }            }        }    }    public static void main(String[] args) {        DeadLock td1 = new DeadLock();        DeadLock td2 = new DeadLock();        td1.flag = 1;        td2.flag = 0;        //td1,td2都处于可执行状态，但JVM线程调度先执行哪个线程是不确定的。        //td2的run()可能在td1的run()之前运行        new Thread(td1).start();        new Thread(td2).start();    }}</code></pre><p><strong>jps jstack 定位死锁</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;jps</span><br><span class="line">&gt;jstack pid</span><br></pre></td></tr></table></figure><h2 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h2><ul><li>注意加锁顺序</li><li>设置加锁时限（超过时限放弃加锁）</li><li>死锁检测</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;死锁&quot;&gt;&lt;a href=&quot;#死锁&quot; class=&quot;headerlink&quot; title=&quot;死锁&quot;&gt;&lt;/a&gt;死锁&lt;/h1&gt;&lt;p&gt;通俗的说，死锁就是两个或者多个线程，相互占用对方需要的资源，而都不进行释放，导致彼此之间都相互等待对方释放资源，产生了无限制等待的现象。死锁一旦发生，如果没有外力介入，这种等待将永远存在，从而对程序产生严重影响。用来描述死锁的问题最有名的场景就是“哲学家就餐问题”。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java高并发" scheme="http://www.onebug.tech/categories/java%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java" scheme="http://www.onebug.tech/tags/java/"/>
    
      <category term="并发" scheme="http://www.onebug.tech/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="笔记" scheme="http://www.onebug.tech/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>线程池</title>
    <link href="http://www.onebug.tech/2021/05/07/ch11%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://www.onebug.tech/2021/05/07/ch11%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2021-05-06T16:00:00.000Z</published>
    <updated>2021-05-04T01:43:06.180Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="线程池与new-Thread"><a href="#线程池与new-Thread" class="headerlink" title="线程池与new Thread"></a>线程池与new Thread</h2><h3 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h3><ul><li>重用存在的线程，减少对象创建、消亡的开销，性能好</li><li>可有效控制最大并发线程数，提高系统资源利用率，同时可以避免过多资源竞争，避免阻塞。</li><li>提供定时执行、定期执行、单线程、并发数控制等功能。</li></ul><a id="more"></a><h3 id="new-Thread的弊端"><a href="#new-Thread的弊端" class="headerlink" title="new Thread的弊端"></a>new Thread的弊端</h3><ul><li>每次new Thread 新建对象，性能差</li><li>线程缺乏统一管理，可能无限制的新建线程，相互竞争，可能占用过多的系统资源导致死机或者OOM（out of memory 内存溢出），这种问题的原因不是因为单纯的new一个Thread，而是可能因为程序的bug或者设计上的缺陷导致不断new Thread造成的。</li><li>缺少更多功能，如更多执行、定期执行、线程中断。</li></ul><h2 id="线程池的结构"><a href="#线程池的结构" class="headerlink" title="线程池的结构"></a>线程池的结构</h2><p><img src="http://image.onebug.tech/image-20210504093153759.png" alt="image-20210504093153759"></p><p>在线程池的类图中，我们最常使用的是最下边的Executors，用它来创建线程池使用线程。那么在上边的类图中，包含了一个Executor框架，它是一个根据一组执行策略的调用调度执行和控制异步任务的框架，目的是提供一种将任务提交与任务如何运行分离开的机制。它包含了三个executor接口：</p><ul><li>Executor：运行新任务的简单接口</li><li>ExecutorService：扩展了Executor，添加了用来管理执行器生命周期和任务生命周期的方法</li><li>ScheduleExcutorService：扩展了ExecutorService，支持Future和定期执行任务</li></ul><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p><img src="http://image.onebug.tech/20170914114339689" alt="这里写图片描述"></p><ol><li><p>线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。</p></li><li><p>当调用 execute() 方法添加一个任务时，线程池会做如下判断：</p><ul><li>如果正在运行的线程数量小于 <code>corePoolSize</code>，那么马上创建线程运行这个任务；</li><li>如果正在运行的线程数量大于或等于 <code>corePoolSize</code>，那么将这个任务放入队列。</li><li>如果这时候队列满了，而且正在运行的线程数量小于 <code>maximumPoolSize</code>，那么还是要创建线程运行这个任务；</li><li>如果队列满了，而且正在运行的线程数量大于或等于 <code>maximumPoolSize</code>，那么线程池会抛出异常，告诉调用者“我不能再接受任务了”。</li></ul></li><li><p>当一个线程完成任务时，它会从队列中取下一个任务来执行。</p></li><li><p>当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 <code>corePoolSize</code>，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 <code>corePoolSize</code> 的大小。</p></li></ol><h3 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a>配置项</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates a new &#123;<span class="doctag">@code</span> ThreadPoolExecutor&#125; with the given initial</span></span><br><span class="line"><span class="comment">    * parameters.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> corePoolSize the number of threads to keep in the pool, even</span></span><br><span class="line"><span class="comment">    *        if they are idle, unless &#123;<span class="doctag">@code</span> allowCoreThreadTimeOut&#125; is set</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> maximumPoolSize the maximum number of threads to allow in the</span></span><br><span class="line"><span class="comment">    *        pool</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> keepAliveTime when the number of threads is greater than</span></span><br><span class="line"><span class="comment">    *        the core, this is the maximum time that excess idle threads</span></span><br><span class="line"><span class="comment">    *        will wait for new tasks before terminating.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> unit the time unit for the &#123;<span class="doctag">@code</span> keepAliveTime&#125; argument</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> workQueue the queue to use for holding tasks before they are</span></span><br><span class="line"><span class="comment">    *        executed.  This queue will hold only the &#123;<span class="doctag">@code</span> Runnable&#125;</span></span><br><span class="line"><span class="comment">    *        tasks submitted by the &#123;<span class="doctag">@code</span> execute&#125; method.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> threadFactory the factory to use when the executor</span></span><br><span class="line"><span class="comment">    *        creates a new thread</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> handler the handler to use when execution is blocked</span></span><br><span class="line"><span class="comment">    *        because the thread bounds and queue capacities are reached</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IllegalArgumentException if one of the following holds:&lt;br&gt;</span></span><br><span class="line"><span class="comment">    *         &#123;<span class="doctag">@code</span> corePoolSize &lt; 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment">    *         &#123;<span class="doctag">@code</span> keepAliveTime &lt; 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment">    *         &#123;<span class="doctag">@code</span> maximumPoolSize &lt;= 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment">    *         &#123;<span class="doctag">@code</span> maximumPoolSize &lt; corePoolSize&#125;</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> workQueue&#125;</span></span><br><span class="line"><span class="comment">    *         or &#123;<span class="doctag">@code</span> threadFactory&#125; or &#123;<span class="doctag">@code</span> handler&#125; is null</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                             TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                             BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                             ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                             RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">           maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">           maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">           keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">       <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">       <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">       <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">       <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">       <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">       <span class="keyword">this</span>.handler = handler;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li><code>corePoolSize</code> ：核心池的大小，如果调用了<code>prestartAllCoreThreads()</code>或者<code>prestartCoreThread()</code>方法，会直接预先创建<code>corePoolSize</code>的线程，否则当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到<code>corePoolSize</code>后，就会把到达的任务放到缓存队列当中；这样做的好处是，如果任务量很小，那么甚至就不需要缓存任务，<code>corePoolSize</code>的线程就可以应对；</li><li><code>maximumPoolSize</code>：线程池最大线程数，表示在线程池中最多能创建多少个线程，如果运行中的线程超过了这个数字，那么相当于线程池已满，新来的任务会使用<code>RejectedExecutionHandler</code> 进行处理；</li><li>keepAliveTime：表示线程没有任务执行时最多保持多久时间会终止，然后线程池的数目维持在<code>corePoolSize</code> 大小；</li><li>unit：参数keepAliveTime的时间单位；</li><li>workQueue：一个阻塞队列，用来存储等待执行的任务，如果当前对线程的需求超过了<code>corePoolSize</code>大小，才会放在这里；</li><li><code>threadFactory</code>：线程工厂，主要用来创建线程，比如可以指定线程的名字；</li><li>handler：如果线程池已满，新的任务的处理方式</li></ul><h3 id="线程池的阻塞队列"><a href="#线程池的阻塞队列" class="headerlink" title="线程池的阻塞队列"></a>线程池的阻塞队列</h3><p>通道，有以下一些阻塞队列可供选择：</p><ul><li><code>ArrayBlockingQueue</code>是一个有边界的阻塞队列，它的内部实现是一个数组。有边界的意思是它的容量是有限的，我们必须在其初始化的时候指定它的容量大小，容量大小一旦指定就不可改变。</li><li><code>DelayQueue</code>阻塞的是其内部元素，<code>DelayQueue</code>中的元素必须实现 <code>java.util.concurrent.Delayed</code>接口，该接口只有一个方法就是<code>long getDelay(TimeUnit unit)</code>，返回值就是队列元素被释放前的保持时间，如果返回0或者一个负值，就意味着该元素已经到期需要被释放，此时<code>DelayedQueue</code>会通过其take()方法释放此对象，<code>DelayQueue</code>可应用于定时关闭连接、缓存对象，超时处理等各种场景；</li><li><code>LinkedBlockingQueue</code>阻塞队列大小的配置是可选的，如果我们初始化时指定一个大小，它就是有边界的，如果不指定，它就是无边界的。说是无边界，其实是采用了默认大小为<code>Integer.MAX_VALUE</code>的容量 。它的内部实现是一个链表。</li><li><code>PriorityBlockingQueue</code>是一个没有边界的队列，它的排序规则和 <code>java.util.PriorityQueue</code>一样。需要注意，<code>PriorityBlockingQueue</code>中允许插入null对象。所有插入<code>PriorityBlockingQueue</code>的对象必须实现 <code>java.lang.Comparable</code>接口，队列优先级的排序规则就是按照我们对这个接口的实现来定义的。</li><li><code>SynchronousQueue</code>队列内部仅允许容纳一个元素。当一个线程插入一个元素后会被阻塞，除非这个元素被另一个线程消费。</li></ul><p>使用的最多的应该是<strong>LinkedBlockingQueue</strong>，注意一般情况下要配置一下队列大小，设置成有界队列，否则JVM内存会被撑爆！</p><h3 id="饱和策略"><a href="#饱和策略" class="headerlink" title="饱和策略"></a>饱和策略</h3><p>线程池已满的定义，是指<code>运行线程数==maximumPoolSize</code>，并且workQueue是有界队列并且已满（如果是无界队列当然永远不会满）；这时候再提交任务怎么办呢？线程池会将任务传递给最后一个参数<code>RejectedExecutionHandler</code>来处理，比如打印报错日志、抛出异常、存储到Mysql/redis用于后续处理等等，线程池默认也提供了几种处理方式：</p><ul><li>在默认的 <code>ThreadPoolExecutor.AbortPolicy</code> 中，处理程序遭到拒绝将抛出运行时<code>RejectedExecutionException</code>。</li><li>在 <code>ThreadPoolExecutor.CallerRunsPolicy</code> 中，线程调用运行该任务的execute 本身。此策略提供简单的反馈控制机制，能够减缓新任务的提交速度。</li><li>在 <code>ThreadPoolExecutor.DiscardPolicy</code> 中，不能执行的任务将被删除。</li><li>在 <code>ThreadPoolExecutor.DiscardOldestPolicy</code> 中，如果执行程序尚未关闭，则位于工作队列头部的任务将被删除，然后重试执行程序（如果再次失败，则重复此过程）</li><li>当然也可以自己实现处理策略类，继承<code>RejectedExecutionHandler</code>接口即可，该接口只有一个方法：<br><code>void rejectedExecution(Runnable r, ThreadPoolExecutor executor);</code></li></ul><h3 id="线程池配置优化"><a href="#线程池配置优化" class="headerlink" title="线程池配置优化"></a>线程池配置优化</h3><p>一般需要根据任务的类型来配置线程池大小：如果是CPU密集型任务，就需要尽量压榨CPU，参考值可以设为 NCPU+1。如果是IO密集型任务，参考值可以设置为2*NCPU。</p><p>当然，这只是一个参考值，具体的设置还需要根据实际情况进行调整，比如可以先将线程池大小设置为参考值，再观察任务运行情况和系统负载、资源利用率来进行适当调整。</p><blockquote><p>其中NCPU的指的是CPU的核心数，可以使用<code>Runtime.getRuntime().availableProcessors()</code>来获取；</p></blockquote><h2 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h2><p>使用Executor可以创建四种线程池：分别对应上边提到的四种线程池初始化方法</p><ul><li><p><code>newCachedThreadPool</code><br>创建一个可缓存的线程池，如果线程池的长度超过了处理的需要，可以灵活回收空闲线程。如果没有可回收的就新建线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的一点是，<code>newCachedThreadPool</code>的返回值是ExecutorService类型，该类型只包含基础的线程池方法，但却不包含线程监控相关方法，因此在使用返回值为ExecutorService的线程池类型创建新线程时要考虑到具体情况。</p></li><li><p><code>newFixedThreadPool</code></p><ul><li>定长线程池，可以设置线程的最大并发数，超出在队列等待</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>newSingleThreadExecutor</code></p><p>单线程化的线程池，用唯一的一个共用线程执行任务，保证所有任务按指定顺序执行（FIFO、优先级…）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>newScheduledThreadPool</code></p><p>定长线程池，支持定时和周期任务执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,<span class="comment">//此处super指的是ThreadPoolExecutor</span></span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ScheduledExecutorService</code>提供了三种方法可以使用：</p><ul><li><p><code>schedule</code>：在指定delay（延时）之后，执行提交Runnable的任务</p></li><li><p><code>scheduleAtFixedRate</code>：以指定的速率执行任务</p></li><li><p><code>scheduleWithFixedDelay</code>：以指定的延迟执行任务</p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;线程池&quot;&gt;&lt;a href=&quot;#线程池&quot; class=&quot;headerlink&quot; title=&quot;线程池&quot;&gt;&lt;/a&gt;线程池&lt;/h1&gt;&lt;h2 id=&quot;线程池与new-Thread&quot;&gt;&lt;a href=&quot;#线程池与new-Thread&quot; class=&quot;headerlink&quot; title=&quot;线程池与new Thread&quot;&gt;&lt;/a&gt;线程池与new Thread&lt;/h2&gt;&lt;h3 id=&quot;线程池的好处&quot;&gt;&lt;a href=&quot;#线程池的好处&quot; class=&quot;headerlink&quot; title=&quot;线程池的好处&quot;&gt;&lt;/a&gt;线程池的好处&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;重用存在的线程，减少对象创建、消亡的开销，性能好&lt;/li&gt;
&lt;li&gt;可有效控制最大并发线程数，提高系统资源利用率，同时可以避免过多资源竞争，避免阻塞。&lt;/li&gt;
&lt;li&gt;提供定时执行、定期执行、单线程、并发数控制等功能。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="java高并发" scheme="http://www.onebug.tech/categories/java%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java" scheme="http://www.onebug.tech/tags/java/"/>
    
      <category term="并发" scheme="http://www.onebug.tech/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="笔记" scheme="http://www.onebug.tech/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>AQS-组件</title>
    <link href="http://www.onebug.tech/2021/05/06/ch10AQS%E7%BB%84%E4%BB%B6/"/>
    <id>http://www.onebug.tech/2021/05/06/ch10AQS%E7%BB%84%E4%BB%B6/</id>
    <published>2021-05-05T16:00:00.000Z</published>
    <updated>2021-05-04T01:43:02.540Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AQS组件"><a href="#AQS组件" class="headerlink" title="AQS组件"></a>AQS组件</h1><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>CountDownLatch中count down是倒数的意思，latch则是门闩的含义。整体含义可以理解为<strong>倒数的门栓</strong>，似乎有一点【三二一，芝麻开门 】的感觉。CountDownLatch的作用也是如此，在构造CountDownLatch的时候需要传入一个整数n，在这个整数“倒数”到0之前，主线程需要等待在门口，而这个“倒数”过程则是由各个执行线程驱动的，每个线程执行完一个任务“倒数”一次。<strong>总结来说，CountDownLatch的作用就是等待其他的线程都执行完任务，必要时可以对各个任务的执行结果进行汇总，然后主线程才继续往下执行。</strong></p><a id="more"></a><p><img src="http://image.onebug.tech/image-20210504092638245.png" alt="image-20210504092638245"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> threadNum = i;</span><br><span class="line">    exec.execute(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test(threadNum);  <span class="comment">//需要被等待的线程执行的方法</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">countDownLatch.await();</span><br><span class="line"><span class="comment">//countDownLatch.await(10, TimeUnit.MILLISECONDS);</span></span><br><span class="line"><span class="comment">//await还可以设置等待的时间（参数1：等待的时间长度; 参数2：等待的时间单位）</span></span><br><span class="line">log.info(<span class="string">"analyze here"</span>)</span><br></pre></td></tr></table></figure><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>信号量在操作系统中是很重要的概念，Java并发库里的Semaphore就可以很轻松的完成类似操作系统信号量的控制。它可以很容易<strong>控制系统中某个资源被同时访问的线程个数</strong>。Semaphore常用来做流量分流，特别是对公共资源有限的场景，比如数据库连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、普通调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">     semaphore.acquire(); <span class="comment">// 获取一个许可</span></span><br><span class="line">     test();<span class="comment">//需要并发控制的内容</span></span><br><span class="line">     semaphore.release(); <span class="comment">// 释放一个许可</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">     log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 2、同时获取多个许可，同时释放多个许可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">     semaphore.acquire(<span class="number">2</span>);</span><br><span class="line">     test();</span><br><span class="line">     semaphore.release(<span class="number">2</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">     log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 3、尝试获取许可，获取不到不执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (semaphore.tryAcquire()) &#123;</span><br><span class="line">        test(threadNum);</span><br><span class="line">        semaphore.release();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">     log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 4、尝试获取许可一段时间，获取不到不执行</span></span><br><span class="line"><span class="comment"> * 参数1：等待时间长度  参数2：等待时间单位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (semaphore.tryAcquire(<span class="number">5000</span>, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">        test(threadNum);</span><br><span class="line">        semaphore.release(); </span><br><span class="line">     &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">     log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>CyclicBarrier也叫同步屏障，<strong>可以让一组线程达到一个屏障时被阻塞，直到最后一个线程达到屏障时，所以被阻塞的线程才能继续执行</strong>。CyclicBarrier好比一扇门，默认情况下关闭状态，堵住了线程执行的道路，直到所有线程都就位，门才打开，让所有线程一起通过。</p><p><img src="http://image.onebug.tech/image-20210504092709136.png" alt="image-20210504092709136"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//想象一个场景，运动会男子100米决赛，5名选手。每个运动员都就位后才开始。</span></span><br><span class="line"><span class="comment">//公共线程循环调用方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> threadNum = i;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        executor.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                race(threadNum);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    executor.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用方法1：每个线程都持续等待</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">race</span><span class="params">(<span class="keyword">int</span> threadNum)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    log.info(<span class="string">"&#123;&#125; is ready"</span>, threadNum);</span><br><span class="line">    barrier.await();</span><br><span class="line">    log.info(<span class="string">"&#123;&#125; continue"</span>, threadNum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用方法2：每个线程只等待一段时间</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">race</span><span class="params">(<span class="keyword">int</span> threadNum)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        barrier.await(<span class="number">2000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException | TimeoutException e) &#123;</span><br><span class="line">        log.warn(<span class="string">"BarrierException"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用方法3：在初始化的时候设置runnable，当线程达到屏障时优先执行runnable</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>, () -&gt; &#123;</span><br><span class="line">    log.info(<span class="string">"callback is running"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>与CountDownLatch区别</strong></p><ul><li>计数器可重复用</li><li>描述一个或多个线程等待其他线程的关系/多个线程相互等待</li></ul><h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><p>通常创建一个线程有2种方式，一种是直接继承Thread，另外一种就是实现Runnable接口。这2种方式都有一个缺陷就是：<strong>在执行完任务之后无法获取执行结果</strong>。如果需要获取执行结果，就必须通过共享变量或者使用线程通信的方式来达到效果，这样使用起来就比较麻烦。而自从Java 1.5开始，就提供了Callable和Future，通过它们可以在任务执行完毕之后得到任务执行结果。</p><p><strong>Callable与Runnable</strong></p><p>先说一下<code>java.lang.Runnable</code>吧，它是一个接口，在它里面只声明了一个run()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于run()方法返回值为void类型，所以在执行完任务之后无法返回任何结果。</p><p>Callable位于<code>java.util.concurrent</code>包下，它也是一个接口，在它里面也只声明了一个方法，只不过这个方法叫做call()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这是一个泛型接口，call()函数返回的类型就是传递进来的V类型。</p><p>那么怎么使用Callable呢？一般情况下是配合ExecutorService来使用的，在ExecutorService接口中声明了若干个submit方法的重载版本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></figure><p><strong>Future</strong></p><p>Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。</p><p>Future类位于<code>java.util.concurrent</code>包下，它是一个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说Future提供了三种功能：</p><ul><li>判断任务是否完成；</li><li>能够中断任务；</li><li>能够获取任务执行结果。</li></ul><p>因为Future只是一个接口，所以是无法直接用来创建对象使用的，因此就有了下面的FutureTask。</p><p><strong>FutureTask</strong></p><p>FutureTask类实现了RunnableFuture接口，RunnableFuture继承了Runnable接口和Future接口，而FutureTask实现了RunnableFuture接口。所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。</p><p><strong>使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTaskExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;String&gt;(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                log.info(<span class="string">"do something in callable"</span>);</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"Done"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line">        log.info(<span class="string">"do something in main"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        String result = futureTask.get();</span><br><span class="line">        log.info(<span class="string">"result：&#123;&#125;"</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ForkJoin"><a href="#ForkJoin" class="headerlink" title="ForkJoin"></a>ForkJoin</h2><p>ForkJoin是Java7提供的一个并行执行任务的框架，是把大任务分割成若干个小任务，待小任务完成后将结果汇总成大任务结果的框架。主要采用的是<strong>工作窃取算法</strong>，工作窃取算法是指某个线程从其他队列里窃取任务来执行。</p><p><img src="http://image.onebug.tech/image-20210504092914046.png" alt="image-20210504092914046"></p><p>在窃取过程中两个线程会访问同一个队列，为了减少窃取任务线程和被窃取任务线程之间的竞争，通常我们会使用<strong>双端队列</strong>来实现工作窃取算法。被窃取任务的线程永远从队列的头部拿取任务，窃取任务的线程从队列尾部拿取任务。</p><p><strong>局限性</strong></p><ul><li>任务只能使用fork和join作为同步机制，如果使用了其他同步机制，当他们在同步操作时，工作线程就不能执行其他任务了。比如在fork框架使任务进入了睡眠，那么在睡眠期间内在执行这个任务的线程将不会执行其他任务了</li><li>所拆分的任务不应该去执行IO操作，如读和写数据文件。</li><li>任务不能抛出检查异常。必须通过必要的代码来处理他们。</li></ul><p><strong>使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模拟加和运算</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinTaskExample</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> threshold = <span class="number">2</span>;<span class="comment">//设定不大于两个数相加就直接for循环，不适用框架</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinTaskExample</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//如果任务足够小就计算任务</span></span><br><span class="line">        <span class="keyword">boolean</span> canCompute = (end - start) &lt;= threshold;</span><br><span class="line">        <span class="keyword">if</span> (canCompute) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果任务大于阈值，就分裂成两个子任务计算（分裂算法，可依情况调优）</span></span><br><span class="line">            <span class="keyword">int</span> middle = (start + end) / <span class="number">2</span>;</span><br><span class="line">            ForkJoinTaskExample leftTask = <span class="keyword">new</span> ForkJoinTaskExample(start, middle);</span><br><span class="line">            ForkJoinTaskExample rightTask = <span class="keyword">new</span> ForkJoinTaskExample(middle + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行子任务</span></span><br><span class="line">            leftTask.fork();</span><br><span class="line">            rightTask.fork();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 等待任务执行结束合并其结果</span></span><br><span class="line">            <span class="keyword">int</span> leftResult = leftTask.join();</span><br><span class="line">            <span class="keyword">int</span> rightResult = rightTask.join();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 合并子任务</span></span><br><span class="line">            sum = leftResult + rightResult;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ForkJoinPool forkjoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成一个计算任务，计算1+2+3+4...100</span></span><br><span class="line">        ForkJoinTaskExample task = <span class="keyword">new</span> ForkJoinTaskExample(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行一个任务</span></span><br><span class="line">        Future&lt;Integer&gt; result = forkjoinPool.submit(task);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">"result:&#123;&#125;"</span>, result.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><p>BlockingQueue接口表示一个线程安全的队列，可以放入并获取实例。BlockingQueue通常用于使线程产生对象，而另一线程则使用该对象。主要应用场景就是：生产者消费者模型。</p><p><img src="http://image.onebug.tech/1992310-df4b4820c16642be.png" alt="img"></p><p>生产线程将持续生产新对象并将它们插入队列，直到队列达到它可以包含的上限。换句话说，这是极限。如果阻塞队列达到其上限，则会在尝试插入新对象时阻塞生产线程。在消耗线程将对象带出队列之前，它一直处于阻塞状态。消费线程不断将对象从阻塞队列中取出，并对其进行处理。如果消费线程试图将对象从空队列中取出，则消费线程将被阻塞，直到生成的线程将对象放入队列。</p><p><strong>方法</strong></p><p>BlockingQueue有4种不同的方法来插入、删除和检查队列中的元素。每一组方法的行为都是不同的，以防被请求的操作不能立即执行。下面是这些方法的一个表：</p><table><thead><tr><th align="center"></th><th align="center">Throws Exception</th><th align="center">Special Value</th><th align="center">Blocks</th><th align="center">Times out</th></tr></thead><tbody><tr><td align="center">Insert</td><td align="center">add(o)</td><td align="center">offer(o)</td><td align="center">put(o)</td><td align="center">offer(o, timeout, timeunit)</td></tr><tr><td align="center">Remove</td><td align="center">remove(o)</td><td align="center">poll()</td><td align="center">take()</td><td align="center">poll(timeout, timeunit)</td></tr><tr><td align="center">Examine</td><td align="center">element()</td><td align="center">peek()</td><td align="center"></td><td align="center"></td></tr></tbody></table><blockquote><ul><li>Throws Exception: 如果尝试的操作不可能立即发生，则抛出一个异常。</li><li>Special Value  ：如果尝试的操作不能立即执行，则会返回一个特殊值（通常为true / false）。</li><li>Blocks：如果尝试的操作不可能立即执行，那么该方法将阻塞。</li><li>Times out：如果尝试的操作不可能立即执行，则该方法调用将阻塞，但不会超过给定的超时。<br> 返回一个特殊值，告诉操作是否成功（通常为true / false）。</li></ul></blockquote><p><strong>实现</strong></p><p>由于BlockingQueue是一个接口，因此您需要使用它的一个实现来使用它。java.util.concurrent包具有以下BlockingQueue接口（在Java 6中）的实现：</p><ul><li>ArrayBlockingQueue</li><li>DelayQueue</li><li>LinkedBlockingQueue]</li><li>PriorityBlockingQueue</li><li>SynchronousQueue</li></ul><p><strong>使用</strong></p><p>该示例使用BlockingQueue接口的ArrayBlockingQueue实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BlockingQueueExample类在不同的线程中启动生产者和消费者。生产者将字符串插入共享BlockingQueue中，消费者将它们取出。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingQueueExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        BlockingQueue queue = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer(queue);</span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer(queue);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(producer).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(consumer).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这是生产者类。注意它在每个put（）调用之间的使用sleep。这将导致消费者在等待队列中的对象时阻塞。</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> BlockingQueue queue = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(BlockingQueue queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            queue.put(<span class="string">"1"</span>);</span><br><span class="line">            log.info(<span class="string">"put 1"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            queue.put(<span class="string">"2"</span>);</span><br><span class="line">            log.info(<span class="string">"put 2"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            queue.put(<span class="string">"3"</span>);</span><br><span class="line">            log.info(<span class="string">"put 3"</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这是消费者类。它只是从队列中取出对象，并将它们打印到System.out。</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> BlockingQueue queue = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(BlockingQueue queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">"take &#123;&#125;"</span>,queue.take());</span><br><span class="line">            log.info(<span class="string">"take &#123;&#125;"</span>,queue.take());</span><br><span class="line">            log.info(<span class="string">"take &#123;&#125;"</span>,queue.take());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">19</span>:<span class="number">15</span>:<span class="number">27.756</span> [Thread-<span class="number">0</span>] INFO com.mmall.concurrency.example.aqs.Producer - put <span class="number">1</span></span><br><span class="line"><span class="number">19</span>:<span class="number">15</span>:<span class="number">27.756</span> [Thread-<span class="number">1</span>] INFO com.mmall.concurrency.example.aqs.Consumer - take <span class="number">1</span></span><br><span class="line"><span class="number">19</span>:<span class="number">15</span>:<span class="number">28.776</span> [Thread-<span class="number">0</span>] INFO com.mmall.concurrency.example.aqs.Producer - put <span class="number">2</span></span><br><span class="line"><span class="number">19</span>:<span class="number">15</span>:<span class="number">28.776</span> [Thread-<span class="number">1</span>] INFO com.mmall.concurrency.example.aqs.Consumer - take <span class="number">2</span></span><br><span class="line"><span class="number">19</span>:<span class="number">15</span>:<span class="number">29.790</span> [Thread-<span class="number">0</span>] INFO com.mmall.concurrency.example.aqs.Producer - put <span class="number">3</span></span><br><span class="line"><span class="number">19</span>:<span class="number">15</span>:<span class="number">29.790</span> [Thread-<span class="number">1</span>] INFO com.mmall.concurrency.example.aqs.Consumer - take <span class="number">3</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;AQS组件&quot;&gt;&lt;a href=&quot;#AQS组件&quot; class=&quot;headerlink&quot; title=&quot;AQS组件&quot;&gt;&lt;/a&gt;AQS组件&lt;/h1&gt;&lt;h2 id=&quot;CountDownLatch&quot;&gt;&lt;a href=&quot;#CountDownLatch&quot; class=&quot;headerlink&quot; title=&quot;CountDownLatch&quot;&gt;&lt;/a&gt;CountDownLatch&lt;/h2&gt;&lt;p&gt;CountDownLatch中count down是倒数的意思，latch则是门闩的含义。整体含义可以理解为&lt;strong&gt;倒数的门栓&lt;/strong&gt;，似乎有一点【三二一，芝麻开门 】的感觉。CountDownLatch的作用也是如此，在构造CountDownLatch的时候需要传入一个整数n，在这个整数“倒数”到0之前，主线程需要等待在门口，而这个“倒数”过程则是由各个执行线程驱动的，每个线程执行完一个任务“倒数”一次。&lt;strong&gt;总结来说，CountDownLatch的作用就是等待其他的线程都执行完任务，必要时可以对各个任务的执行结果进行汇总，然后主线程才继续往下执行。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="java高并发" scheme="http://www.onebug.tech/categories/java%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java" scheme="http://www.onebug.tech/tags/java/"/>
    
      <category term="并发" scheme="http://www.onebug.tech/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="笔记" scheme="http://www.onebug.tech/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>AQS-锁</title>
    <link href="http://www.onebug.tech/2021/05/05/ch9AQS%E9%94%81/"/>
    <id>http://www.onebug.tech/2021/05/05/ch9AQS%E9%94%81/</id>
    <published>2021-05-04T16:00:00.000Z</published>
    <updated>2021-05-04T01:42:58.483Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AQS锁"><a href="#AQS锁" class="headerlink" title="AQS锁"></a>AQS锁</h1><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p><strong>ReentrantLock的使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建锁：使用Lock对象声明，使用ReentrantLock接口创建</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">//使用锁：在需要被加锁的方法中使用</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>源码分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化方面：</span></span><br><span class="line"><span class="comment">//在new ReentrantLock的时候默认给了一个不公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//也可以加参数来初始化指定使用公平锁还是不公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>功能：</p><ul><li>tryLock()：仅在调用时锁定未被另一个线程保持的情况下才获取锁定。</li><li>tryLock(long timeout, TimeUnit unit)：如果锁定在给定的时间内没有被另一个线程保持且当前线程没有被中断，则获取这个锁定。</li><li>lockInterruptbily：如果当前线程没有被中断的话，那么就获取锁定。如果中断了就抛出异常。</li><li>isLocked：查询此锁定是否由任意线程保持</li><li>isHeldByCurrentThread：查询当前线程是否保持锁定状态。</li><li>isFair：判断是不是公平锁</li><li>……</li></ul><p><strong>与synchronized的区别</strong></p><ul><li>可重入性：两者的锁都是可重入的，差别不大，有线程进入锁，计数器自增1，等下降为0时才可以释放锁</li><li>锁的实现：synchronized是基于JVM实现，ReentrantLock是JDK实现的。</li><li>性能区别：在最初的时候，二者的性能差别差很多，当synchronized引入了偏向锁、轻量级锁（自旋锁）后，二者的性能差别不大，官方推荐synchronized（优化时其实是借用了ReentrantLock的CAS技术，试图在用户态就把问题解决，避免进入内核态造成线程阻塞）</li><li>功能区别：<ul><li>便利性：synchronized更便利，它是由编译器保证加锁与释放。ReentrantLock是需要手动释放锁，所以为了避免忘记手工释放锁造成死锁，所以最好在finally中声明释放锁。</li><li>锁的细粒度和灵活度，ReentrantLock优于synchronized</li></ul></li></ul><p><strong>ReentrantLock独有的功能</strong></p><ul><li><p>可以指定是公平锁还是<strong>非公平锁</strong>，sync只能是非公平锁。</p><blockquote><p>公平锁就是先等待的线程先获得锁</p></blockquote></li><li><p>提供了一个Condition类，可以<strong>分组唤醒</strong>需要唤醒的线程，而synchronized要么随机唤醒一个线程，要么全部唤醒。</p></li><li><p>通过<code>lock.lockInterruptibly()</code>提供能够中断等待锁的线程的功能</p></li><li><p>ReentrantLock是一种自旋锁，通过循环调用CAS操作来实现加锁。由于避免了进入内核态的阻塞状态，性能比较好。</p></li></ul><p><strong>是否弃用synchronized？</strong></p><p>从上边的介绍，看上去ReentrantLock不仅拥有synchronized的所有功能，而且有一些功能synchronized无法实现的特性。性能方面，ReentrantLock也不比synchronized差，那么到底我们要不要放弃使用synchronized呢？<strong>答案是不要这样做</strong>。</p><p>J.U.C包中的锁类是高级用户的工具，除非说你对Lock的高级特性有特别清楚的了解以及有明确的需求，或有明确的证据表明同步已经成为可伸缩性的瓶颈的时候，否则我们还是继续使用synchronized。相比较这些高级的锁定类，synchronized还是有一些优势的，比如synchronized不需要手动释放锁。还有当JVM使用synchronized管理锁定请求和释放时，JVM在生成线程转储时能够包括锁定信息，这些信息对调试非常有价值，它们可以标识死锁以及其他异常行为的来源。</p><p><strong>如何选择锁？</strong></p><ul><li>当只有少量竞争者，使用synchronized</li><li>竞争者不少但是线程增长的趋势是能预估的，使用ReetrantLock</li></ul><h2 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h2><p>ReentrantReadWriteLock（读写锁）允许多个线程在没有写入时同时读取，只允许一个线程写入。如果一直存在读操作，那么写锁一直在等待没有读的情况出现，这样我的写锁就永远也获取不到，就会<strong>造成等待获取写锁的线程饥饿</strong>。平时使用的场景并不多，平时使用的场景并不多。</p><h2 id="StempedLock"><a href="#StempedLock" class="headerlink" title="StempedLock"></a>StempedLock</h2><p>要进一步提升并发执行效率，Java 8引入了新的读写锁：StampedLock。改进之处在于：读的过程中也允许获取写锁后写入，这样一来，我们读的数据就可能不一致，所以，需要一点额外的代码来判断读的过程中是否有写入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StampedLock stampedLock = <span class="keyword">new</span> StampedLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">double</span> deltaX, <span class="keyword">double</span> deltaY)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp = stampedLock.writeLock(); <span class="comment">// 获取写锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            x += deltaX;</span><br><span class="line">            y += deltaY;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            stampedLock.unlockWrite(stamp); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">distanceFromOrigin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp = stampedLock.tryOptimisticRead(); <span class="comment">// 获得一个乐观读锁</span></span><br><span class="line">        <span class="comment">// 注意下面两行代码不是原子操作</span></span><br><span class="line">        <span class="comment">// 假设x,y = (100,200)</span></span><br><span class="line">        <span class="keyword">double</span> currentX = x;</span><br><span class="line">        <span class="comment">// 此处已读取到x=100，但x,y可能被写线程修改为(300,400)</span></span><br><span class="line">        <span class="keyword">double</span> currentY = y;</span><br><span class="line">        <span class="comment">// 此处已读取到y，如果没有写入，读取是正确的(100,200)</span></span><br><span class="line">        <span class="comment">// 如果有写入，读取是错误的(100,400)</span></span><br><span class="line">        <span class="keyword">if</span> (!stampedLock.validate(stamp)) &#123; <span class="comment">// 检查乐观读锁后是否有其他写锁发生</span></span><br><span class="line">            stamp = stampedLock.readLock(); <span class="comment">// 获取一个悲观读锁</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                currentX = x;</span><br><span class="line">                currentY = y;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                stampedLock.unlockRead(stamp); <span class="comment">// 释放悲观读锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(currentX * currentX + currentY * currentY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和ReadWriteLock相比，写入的加锁是完全一样的，不同的是读取。注意到首先我们通过<code>tryOptimisticRead()</code>获取一个乐观读锁，并返回版本号。接着进行读取，读取完成后，我们通过<code>validate()</code>去验证版本号，如果在读取过程中没有写入，版本号不变，验证成功，我们就可以放心地继续后续操作。如果在读取过程中有写入，版本号会发生变化，验证将失败。在失败的时候，我们再通过获取悲观读锁再次读取。由于写入的概率不高，程序在绝大部分情况下可以通过乐观读锁获取数据，极少数情况下使用悲观读锁获取数据。</p><p>可见，StampedLock把读锁细分为乐观读和悲观读，能进一步提升并发效率。但这也是有代价的：一是代码更加复杂，二是StampedLock是不可重入锁，不能在一个线程中反复获取同一个锁。</p><blockquote><p>乐观锁的意思就是乐观地估计读的过程中大概率不会有写入，因此被称为乐观锁。反过来，悲观锁则是读的过程中拒绝有写入，也就是写入必须等待。显然乐观锁的并发效率更高，但一旦有小概率的写入导致读取的数据不一致，需要能检测出来，再读一遍就行</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;AQS锁&quot;&gt;&lt;a href=&quot;#AQS锁&quot; class=&quot;headerlink&quot; title=&quot;AQS锁&quot;&gt;&lt;/a&gt;AQS锁&lt;/h1&gt;&lt;h2 id=&quot;ReentrantLock&quot;&gt;&lt;a href=&quot;#ReentrantLock&quot; class=&quot;headerlink&quot; title=&quot;ReentrantLock&quot;&gt;&lt;/a&gt;ReentrantLock&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;ReentrantLock的使用&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//创建锁：使用Lock对象声明，使用ReentrantLock接口创建&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Lock lock = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ReentrantLock();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//使用锁：在需要被加锁的方法中使用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    lock.lock();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        count++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;finally&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        lock.unlock();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="java高并发" scheme="http://www.onebug.tech/categories/java%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java" scheme="http://www.onebug.tech/tags/java/"/>
    
      <category term="并发" scheme="http://www.onebug.tech/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="笔记" scheme="http://www.onebug.tech/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>AQS</title>
    <link href="http://www.onebug.tech/2021/05/04/ch8AQS/"/>
    <id>http://www.onebug.tech/2021/05/04/ch8AQS/</id>
    <published>2021-05-03T16:00:00.000Z</published>
    <updated>2021-05-04T01:40:38.157Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><p> AQS（AbstractQueuedSynchronizer）是用来构建锁或者其他同步组件的基础框架，它使用了一个int成员变量来表示状态，通过内置的FIFO（first in，first out）队列来完成资源获取线程的排队工作。</p><a id="more"></a><h2 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h2><p>同步队列（一个FIFO双向队列）是AQS的核心，用来完成同步状态的管理，当线程获取同步状态失败时，AQS会将当前线程以及等待状态等信息构造成一个节点并加入到同步队列，同时会阻塞当前线程。</p><p><img src="https://img2018.cnblogs.com/blog/1055780/201911/1055780-20191129233118009-1456342769.png" alt="img"></p><h3 id="同步状态"><a href="#同步状态" class="headerlink" title="同步状态"></a>同步状态</h3><p>AQS中维持一个全局的int状态码<strong>state</strong>，线程通过修改（加/减指定的数量）码是否成功来决定当前线程是否成功获取到同步状态。</p><p>AQS支持两种获取同步状态的模式既独占式和共享式。顾名思义，独占式模式同一时刻只允许一个线程获取同步状态，而共享模式则允许多个线程同时获取。</p><p><img src="http://image.onebug.tech/1055780-20191129233117600-2113769929.jpg" alt="img"></p><h3 id="独占模式获取与释放状态"><a href="#独占模式获取与释放状态" class="headerlink" title="独占模式获取与释放状态"></a>独占模式获取与释放状态</h3><p>独占模式既同一时间只能由一个线程持有同步状态。当多个线程竞争时(acquire)，获取到同步状态的线程会将当前线程赋值给<code>Thread exclusiveOwnerThread</code>属性（AQS父类中）来标记当前状态被线程独占。其他线程将被构造成Node加入到同步队列中。</p><p><strong>获取同步状态</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取同步状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. tryAcquire    尝试获取同步状态; </span></span><br><span class="line"><span class="comment">     * 2.1 addWaiter     如果尝试获取到同步状态失败，则加入到同步队列中; </span></span><br><span class="line"><span class="comment">     * 2.2 acquireQueued 在队列中尝试获取同步状态.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>多线程并发获取（修改）同步状态, 修改同步状态成功的线程标记为拥有同步状态</li></ol><p><img src="http://image.onebug.tech/1055780-20191129233118430-1256054001.png" alt="img"></p><ol start="2"><li>获取失败的线程，加入到同步队列的队尾；加入到队列中后，如果当前节点的前驱节点为头节点再次尝试获取同步状态。如果头节点的下一个节点尝试获取同步状态失败后，会进入等待状态；其他节点则继续自旋。</li></ol><p><img src="http://image.onebug.tech/1055780-20191129233118771-1689741253.png" alt=""></p><p><img src="https://img2018.cnblogs.com/blog/1055780/201911/1055780-20191129233119143-1476789162.png" alt="img"></p><p>总结：</p><p><img src="http://image.onebug.tech/1055780-20191129233119985-476209714.png" alt="img"></p><p><strong>释放同步状态</strong></p><p>当线程执行完相应逻辑后，需要释放同步状态，使后继节点有机会同步状态（让出资源，让排队的线程使用）。这时就需要调用release(int arg)方法。调用该方法后，会唤醒后继节点。</p><ol><li>释放同步状态，唤醒后继节点</li></ol><p><img src="http://image.onebug.tech/1055780-20191129233120861-935232279.png" alt="img"></p><ol start="2"><li><p>后继节点获取同步状态成功，头节点出队。需要注意的事，出队操作是间接的，有节点获取到同步状态时，会将当前节点设置为head，而原本的head设置为null。</p><blockquote><p>当同步队列中头节点唤醒后继节点时，此时可能有其他线程尝试获取同步状态。假设获取成功，将会被设置为头节点。头节点后续节点获取同步状态失败。</p></blockquote><p><img src="http://image.onebug.tech/1055780-20191129233121530-1946057717.png" alt="img"></p></li></ol><h3 id="共享模式获取与释放状态"><a href="#共享模式获取与释放状态" class="headerlink" title="共享模式获取与释放状态"></a>共享模式获取与释放状态</h3><p>共享模式和独占模式最主要的区别是在<strong>支持同一时刻有多个线程同时获取同步状态</strong>。为了避免带来额外的负担，在上文中提到的同步队列中都是用独占模式进行讲述，其实同步队列中的节点应该是独占和共享节点并存的。</p><p><img src="https://img2018.cnblogs.com/blog/1055780/201911/1055780-20191129233125056-1459011349.png" alt="img"></p><p><strong>获取同步状态</strong></p><ol><li>首先至少要调用一次tryAcquireShared(arg)方法，如果返回值大于等于0表示获取成功。</li><li>当获取锁失败时，则创建一个共享类型的节点并进入一个同步队列，然后进入队列中进入自旋状态（阻塞，唤醒两种状态来回切换，直到获取到同步状态为止）</li><li>当队列中的等待线程被唤醒以后就重新尝试获取锁资源，如果成功则<strong>唤醒后面还在等待的共享节点并把该唤醒事件传递下去，即会依次唤醒在该节点后面的所有共享节点</strong>，否则继续挂起等待。</li></ol><p><img src="http://image.onebug.tech/1055780-20191129233126033-2079605281.png" alt="img"></p><p>当一个同享节点获取到同步状态，并唤醒后面等待的共享状态的结果如下图所示：</p><p><img src="http://image.onebug.tech/1055780-20191129233127018-1280581551.png" alt="img"></p><p><strong>释放同步状态</strong></p><p>释放同步状态后，同步队列的变化过程和共享节点获取到同步状态后的变化过程一致，此处不再进行赘述。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>AQS通过一个int同步状态码，和一个（先进先出）队列来控制多个线程访问资源</li><li>支持独占和共享两种模式获取同步状态码</li><li>当线程获取同步状态失败会被加入到同步队列中</li><li>当线程释放同步状态，会唤醒后继节点来获取同步状态</li><li>共享模式下的节点获取到同步状态或者释放同步状态时，不仅会唤醒后继节点，还会向后传播，唤醒所有同步节点</li><li>使用volatile关键字保证状态码在线程间的可见性，CAS操作保证修改状态码过程的原子性。</li></ul><h2 id="条件队列"><a href="#条件队列" class="headerlink" title="条件队列"></a>条件队列</h2><p>条件队列：当某个线程调用了wait方法，或者通过Condition对象调用了await相关方法，线程就会进入阻塞状态，并加入到对应条件队列中。</p><p>即当对象获取到同步锁之后，如果调用了wait方法，当前线程会进入到条件队列中，并释放锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象)&#123; <span class="comment">// 获取锁失败，线程会加入到同步队列中 </span></span><br><span class="line"><span class="keyword">while</span>(条件不满足)&#123;</span><br><span class="line">对象.wait();<span class="comment">// 调用wait方法当前线程加入到条件队列中</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于synchcronized的内置条件队列存在一些缺陷。<strong>每个内置锁都只能有一个相关联的条件队列</strong>，因而存在多个线程可能在同一个条件队列上等待不同的条件谓词，并且在最常见的加锁模式下公开条件队列对象。</p><p>与Object配合synchronized相比，基于AQS的Lock&amp;Condition实现的等待唤醒模式更加灵活，<strong>支持多个条件队列，支持等待状态中不响应中断以及超时等待功能</strong>； 其次就是<strong>基于AQS实现的条件队列是”肉眼可见”的</strong>，我们可以通过源代码进行debug，而synchronized则是完全隐式的。</p><h3 id="同步队列和条件队列"><a href="#同步队列和条件队列" class="headerlink" title="同步队列和条件队列"></a>同步队列和条件队列</h3><p>与条件队列密不可分的类则是ConditionObject， 是AQS中实现了Condition接口的内部类，通常配合基于AQS实现的锁一同使用。当线程获取到锁之后，可以调用await方法进入条件队列并释放锁，或者调用singinal方法唤醒对应条件队列中等待时间最久的线程并加入到等待队列中。</p><p>在AQS中，线程会被封装成Node对象加入队列中，而<strong>条件队列中则复用了同步队列中的Node对象</strong>。</p><p><img src="http://image.onebug.tech/201912222329_295.jpg" alt="img"></p><h3 id="Condition相关方法和使用"><a href="#Condition相关方法和使用" class="headerlink" title="Condition相关方法和使用"></a>Condition相关方法和使用</h3><p>Condition接口一共定义了以下几个方法：</p><ul><li><strong>await():</strong> 当前线程进入等待状态，直到被通知(siginal)或中断【和wait方法语义相同】。</li><li><strong>awaitUninterruptibly():</strong> 当前线程进入等待状态，直到被通知，对中断不敏感。</li><li><strong>awaitNanos(long timeout):</strong> 当前线程进入等待状态直到被通知(siginal)，中断或超时。</li><li><strong>awaitUnitil(Date deadTime):</strong> 当前线程进入等待状态直到被通知(siginal)，中断或到达某个时间。</li><li><strong>signal():</strong> 唤醒一个等待在Condition上的线程，该线程从等待方法返回前必须获得与Condition关联的锁【和notify方法语义相同】</li><li><strong>signalAll():</strong> 唤醒所有等待在Condition上的线程，能够从等待方法返回的线程必须获得与Condition关联的锁【和notifyAll方法语义相同】。</li></ul><p><strong>使用</strong></p><p>下面是一个线程等待与唤醒的例子，其中用1234序号标出了日志输出顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    Condition condition = reentrantLock.newCondition();<span class="comment">//创建condition</span></span><br><span class="line">    <span class="comment">//线程1</span></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            reentrantLock.lock();</span><br><span class="line">            log.info(<span class="string">"wait signal"</span>); <span class="comment">// 1</span></span><br><span class="line">            condition.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">"get signal"</span>); <span class="comment">// 4</span></span><br><span class="line">        reentrantLock.unlock();</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="comment">//线程2</span></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        reentrantLock.lock();</span><br><span class="line">        log.info(<span class="string">"get lock"</span>); <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        condition.signalAll();<span class="comment">//发送信号</span></span><br><span class="line">        log.info(<span class="string">"send signal"</span>); <span class="comment">// 3</span></span><br><span class="line">        reentrantLock.unlock();</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>分析：</p><ol><li>线程1调用了reentrantLock.lock()，线程进入AQS等待队列，输出”wait signal”</li><li>接着调用了awiat方法，线程从AQS队列中移除，锁释放，直接加入condition的等待队列中</li><li>线程2因为线程1释放了锁，拿到了锁，输出”get lock”</li><li>线程2执行condition.signalAll()发送信号，输出”send signal”</li><li>condition队列中线程1的节点接收到信号，从condition队列中拿出来放入到了AQS的等待队列，这时线程1并没有被唤醒。</li><li>线程2调用unlock释放锁，因为AQS队列中只有线程1，因此AQS释放锁按照从头到尾的顺序，唤醒线程1</li><li>线程1继续执行，输出”get signal”，并进行unlock操作。</li></ol></blockquote><h3 id="条件队列入队操作"><a href="#条件队列入队操作" class="headerlink" title="条件队列入队操作"></a>条件队列入队操作</h3><p>当线程获取到锁之后，Condition对象调用await相关的方法，线程会从同步队列中退出，进入到对应的条件队列中。</p><p><img src="http://image.onebug.tech/201912222331_843.jpg" alt="img"></p><h3 id="条件队出队操作"><a href="#条件队出队操作" class="headerlink" title="条件队出队操作"></a>条件队出队操作</h3><p>Condition对象调用signal或者signalAll方法时，方法唤醒对应条件队列中的相关线程并加入到同步队列中。</p><p><img src="http://image.onebug.tech/201912222332_191.jpg" alt="img"></p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ol><li>条件队列和同步队列在Java中有两种实现，synchronized关键字以及基于AQS</li><li>每个（基于synchronized的）内置锁都只能有一个相关联的条件队列，会存在多个线程可能在同一个条件队列上等待不同的条件谓词；而（基于AQS实现的）显式锁支持多个条件队列</li><li>与wait，notify，notifyAll 对应的方法时Conditoin接口中的await，signal，signalAll，他们具有相同的语义</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;AQS&quot;&gt;&lt;a href=&quot;#AQS&quot; class=&quot;headerlink&quot; title=&quot;AQS&quot;&gt;&lt;/a&gt;AQS&lt;/h1&gt;&lt;p&gt; AQS（AbstractQueuedSynchronizer）是用来构建锁或者其他同步组件的基础框架，它使用了一个int成员变量来表示状态，通过内置的FIFO（first in，first out）队列来完成资源获取线程的排队工作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java高并发" scheme="http://www.onebug.tech/categories/java%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java" scheme="http://www.onebug.tech/tags/java/"/>
    
      <category term="并发" scheme="http://www.onebug.tech/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="笔记" scheme="http://www.onebug.tech/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>并发容器</title>
    <link href="http://www.onebug.tech/2021/05/03/ch7%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/"/>
    <id>http://www.onebug.tech/2021/05/03/ch7%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/</id>
    <published>2021-05-02T16:00:00.000Z</published>
    <updated>2021-05-04T01:42:51.211Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h1><p>Java并发容器JUC是三个单词的缩写。是JDK下面的一个包名。即<code>Java.util.concurrency</code>。</p><h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><p>CopyOnWriteArrayList 写操作时复制，当有新元素添加到集合中时，从原有的数组中拷贝一份出来，然后在新的数组上作写操作，将原来的数组指向新的数组。整个数组的add操作都是在锁的保护下进行的，防止并发时复制多份副本。读操作是在原数组中进行，不需要加锁。</p><a id="more"></a><p><strong>源码分析</strong></p><p>下面首先展示了CopyOnWriteArrayList中比较重要的成员：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The lock protecting all mutators */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The array, accessed only via getArray/setArray. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br></pre></td></tr></table></figure><p>CopyOnWriteArrayList使用了ReentrantLock来支持并发操作，array就是实际存放数据的数组对象。ReentrantLock是一种支持重入的独占锁，任意时刻只允许一个线程获得锁。下面首先展示了add方法的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock(); <span class="comment">//上锁，只允许一个线程进入</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray(); <span class="comment">// 获得当前数组对象</span></span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);<span class="comment">//拷贝到一个新的数组中</span></span><br><span class="line">        newElements[len] = e;<span class="comment">//插入数据元素</span></span><br><span class="line">        setArray(newElements);<span class="comment">//将新的数组对象设置回去</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();<span class="comment">//释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在来分析一下读操作，下面是get方法的细节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现是非常简单的，而且读是允许多个线程进入的。</p><p>下面来分析一下CopyOnWriteArrayList的迭代器。下面是两个重要的变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/** Snapshot of the array */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object[] snapshot;</span><br><span class="line"><span class="comment">/** Index of element to be returned by subsequent call to next.  */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> cursor;</span><br></pre></td></tr></table></figure><p>遍历的时候首先会获得当前数组对象的一个拷贝，称为快照，然后遍历的操作会在该快照上进行。获取了迭代器之后再对CopyOnWriteArrayList进行写操作会，迭代器不会感知到这种变化。每一个线程都将获得当前时刻的一个快照，所以不需要加锁就可以安全的实现遍历。</p><p><strong>设计思想</strong></p><ol><li>读写分离</li><li>最终一致性</li><li>使用时另外开辟空间，防止并发冲突</li></ol><p><strong>缺点</strong></p><ol><li>写操作时<strong>复制消耗内存</strong>，如果元素比较多时候，容易导致young gc 和full gc。</li><li>不能用于实时读的场景。由于复制和add操作等需要时间，故读取时可能读到旧值。<strong>能做到最终一致性，但无法满足实时性的要求，更适合读多写少的场景</strong>。如果无法知道数组有多大，或者add,set操作有多少，慎用此类,在大量的复制副本的过程中很容易出错。</li></ol><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>Map 这样的 <code>Key Value</code> 在软件开发中是非常经典的结构，常用于在内存中存放数据。</p><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>众所周知 HashMap 底层是基于 <code>数组 + 链表</code> 组成的，不过在 jdk1.7 和 1.8 中具体实现稍有不同。</p><p><strong>Base 1.7</strong></p><p><img src="http://image.onebug.tech/5cd1d2be77958.jpg" alt="img"></p><p><strong>Base 1.8</strong></p><p>其实一个很明显的地方就是：当 Hash 冲突严重时，在桶上形成的链表会变的越来越长，这样在查询时的效率就会越来越低；时间复杂度为 <code>O(N)</code>。因此 1.8 中重点优化了这个查询效率，判断当前链表的大小是否大于预设的阈值，大于时就要转换为红黑树。</p><p><img src="http://image.onebug.tech/5cd1d2c1c1cd7.jpg" alt="img"></p><p><strong>线程不安全</strong></p><p>HashMap 扩容的时候会调用 <code>resize()</code> 方法，就是这里的并发操作容易在一个桶上形成<strong>环形链表</strong>；这样当获取一个不存在的 key 时，计算出的 index 正好是环形链表的下标就会出现死循环。</p><blockquote><p><a href="https://coolshell.cn/articles/9606.html#问题的症状" target="_blank" rel="noopener">疫苗：Java HashMap的死循环 | 酷 壳 - CoolShell</a></p></blockquote><h3 id="ConcurrentHashMap-1"><a href="#ConcurrentHashMap-1" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p><strong>Base 1.7</strong></p><p><img src="http://image.onebug.tech/5cd1d2c5ce95c.jpg" alt="img"></p><p>如图所示，是由 Segment 数组、HashEntry 组成，和 HashMap 一样，仍然是数组加链表。</p><p>它的核心成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Segment 数组，存放数据时首先需要定位到具体的 Segment 中。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Segment&lt;K,V&gt;[] segments;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Set&lt;K&gt; keySet;</span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2249069246763182397L</span>;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 和 HashMap 中的 HashEntry 作用一样，真正存放数据的桶</span></span><br><span class="line">       <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">transient</span> <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理上来说：ConcurrentHashMap 采用了<strong>分段锁技术</strong>，其中 <strong>Segment 继承于 ReentrantLock</strong>。不会像 HashTable 那样不管是 put 还是 get 操作都需要做同步处理，理论上 ConcurrentHashMap 支持 CurrencyLevel （Segment 数组数量）的线程并发。每当一个线程占用锁访问一个 Segment 时，不会影响到其他的 Segment。</p><p><strong>Base 1.8</strong></p><p><img src="http://image.onebug.tech/5cd1d2ce33795.jpg" alt="img"></p><p>1.7 已经解决了并发问题，并且能支持 N 个 Segment 这么多次数的并发，但查询遍历链表效率太低。1.8抛弃了原有的 Segment 分段锁，而采用了 <code>CAS + synchronized</code> 来保证并发安全性。</p><h2 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a>ConcurrentSkipListMap</h2><p>底层实现采用SkipList跳表<br>曾经有人用ConcurrentHashMap与ConcurrentSkipListMap做性能测试，在4个线程1.6W的数据条件下，前者的数据存取速度是后者的4倍左右。但是后者有几个前者不能比拟的优点：</p><ul><li>Key是<strong>有序</strong>的</li><li>支持<strong>更高的并发</strong>，存储时间与线程数无关</li></ul><blockquote><p>安全共享对象策略:</p><ul><li>线程限制：一个被线程限制的对象，由线程独占，并且只能被占有它的线程修改</li><li>共享只读：一个共享只读的U帝乡，在没有额外同步的情况下，可以被多个线程并发访问，但是任何线程都不能修改它</li><li>线程安全对象：一个线程安全的对象或者容器，在内部通过同步机制来保障线程安全，多以其他线程无需额外的同步就可以通过公共接口随意访问他</li><li>被守护对象：被守护对象只能通过获取特定的锁来访问。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;并发容器&quot;&gt;&lt;a href=&quot;#并发容器&quot; class=&quot;headerlink&quot; title=&quot;并发容器&quot;&gt;&lt;/a&gt;并发容器&lt;/h1&gt;&lt;p&gt;Java并发容器JUC是三个单词的缩写。是JDK下面的一个包名。即&lt;code&gt;Java.util.concurrency&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;CopyOnWriteArrayList&quot;&gt;&lt;a href=&quot;#CopyOnWriteArrayList&quot; class=&quot;headerlink&quot; title=&quot;CopyOnWriteArrayList&quot;&gt;&lt;/a&gt;CopyOnWriteArrayList&lt;/h2&gt;&lt;p&gt;CopyOnWriteArrayList 写操作时复制，当有新元素添加到集合中时，从原有的数组中拷贝一份出来，然后在新的数组上作写操作，将原来的数组指向新的数组。整个数组的add操作都是在锁的保护下进行的，防止并发时复制多份副本。读操作是在原数组中进行，不需要加锁。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java高并发" scheme="http://www.onebug.tech/categories/java%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java" scheme="http://www.onebug.tech/tags/java/"/>
    
      <category term="并发" scheme="http://www.onebug.tech/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="笔记" scheme="http://www.onebug.tech/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>线程不安全类与同步容器</title>
    <link href="http://www.onebug.tech/2021/05/02/ch6%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%B1%BB%E4%B8%8E%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8/"/>
    <id>http://www.onebug.tech/2021/05/02/ch6%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%B1%BB%E4%B8%8E%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8/</id>
    <published>2021-05-01T16:00:00.000Z</published>
    <updated>2021-05-04T01:42:47.461Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程不安全类"><a href="#线程不安全类" class="headerlink" title="线程不安全类"></a>线程不安全类</h1><p>如果一个类的对象同时可以被多个线程访问，并且你不做特殊的同步或并发处理，那么它就很容易表现出线程不安全的现象。比如抛出异常、逻辑处理错误等。下面列举一下常见的线程不安全的类及对应的线程安全类：</p><a id="more"></a><h2 id="StringBuilder-与-StringBuffer"><a href="#StringBuilder-与-StringBuffer" class="headerlink" title="StringBuilder 与 StringBuffer"></a>StringBuilder 与 StringBuffer</h2><p>StringBuilder是线程不安全的，而StringBuffer是线程安全的。StringBuffer的方法使用了<code>synchronized</code>关键字修饰。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//StringBuffer的方法使用了synchronized关键字修饰。</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    toStringCache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SimpleDateFormat-与-jodatime插件"><a href="#SimpleDateFormat-与-jodatime插件" class="headerlink" title="SimpleDateFormat 与 jodatime插件"></a>SimpleDateFormat 与 jodatime插件</h2><p>SimpleDateFormat 类在处理时间的时候，如下写法是线程不安全的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMdd"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程调用方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        simpleDateFormat.parse(<span class="string">"20180208"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">"parse exception"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以使用线程封闭等手段，也可以使用jodatime插件来转换时间，Joda 类具有不可变性，因此它们的实例无法被修，可以保证线程安全性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> DateTimeFormatter dateTimeFormatter = DateTimeFormat.forPattern(<span class="string">"yyyyMMdd"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"&#123;&#125;, &#123;&#125;"</span>, i, DateTime.parse(<span class="string">"20180208"</span>, dateTimeFormatter).toDate());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ArrayList-HashSet-HashMap…"><a href="#ArrayList-HashSet-HashMap…" class="headerlink" title="ArrayList,HashSet,HashMap…"></a>ArrayList,HashSet,HashMap…</h2><p>像ArrayList,HashSet,HashMap 等Collection类均是线程不安全的，我们以ArrayList举例分析一下源码：</p><p>首先看看这个类所拥有的<strong>部分</strong>属性字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 列表元素集合数组</span></span><br><span class="line"><span class="comment">     * 如果新建ArrayList对象时没有指定大小，那么会将EMPTY_ELEMENTDATA赋值给elementData，</span></span><br><span class="line"><span class="comment">     * 并在第一次添加元素时，将列表容量设置为DEFAULT_CAPACITY </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 列表大小，elementData中存储的元素个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以通过这两个字段我们可以看出，ArrayList的实现主要就是用了一个Object的数组，用来保存所有的元素，以及一个size变量用来保存当前数组中已经添加了多少元素。</p><p>接着我们看下最重要的add操作时的源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加一个元素时，做了如下两步操作</span></span><br><span class="line"><span class="comment">     * 1.判断列表的capacity容量是否足够，是否需要扩容</span></span><br><span class="line"><span class="comment">     * 2.真正将元素放在列表的元素数组里面</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ensureCapacityInternal()</code>这个方法的详细代码我们可以暂时不看，它的作用就是判断如果将当前的新元素加到列表后面，列表的<code>elementData</code>数组的大小是否满足，如果size + 1的这个需求长度大于了<code>elementData</code>这个数组的长度，那么就要对这个数组进行<strong>扩容</strong>。</p><p>由此看到add元素时，实际做了两个大的步骤：</p><ol><li>判断<code>elementData</code>数组容量是否满足需求</li><li>在<code>elementData</code>对应位置上设置值</li></ol><p>这样也就出现了第一个导致线程不安全的隐患，在<strong>多个线程进行add操作时可能会导致<code>elementData</code>数组越界</strong>。具体逻辑如下：</p><ol><li>列表大小为9，即size=9</li><li>线程A开始进入add方法，这时它获取到size的值为9，调用<code>ensureCapacityInternal</code>方法进行容量判断。</li><li>线程B此时也进入add方法，它获取到size的值也为9，也开始调用<code>ensureCapacityInternal</code>方法。</li><li>线程A发现需求大小为10，而<code>elementData</code>的大小就为10，可以容纳。于是它不再扩容，返回。</li><li>线程B也发现需求大小为10，也可以容纳，返回。</li><li>线程A开始进行设置值操作， <code>elementData[size++] = e</code> 操作。此时size变为10。</li><li>线程B也开始进行设置值操作，它尝试设置<code>elementData[10] = e</code>，而<code>elementData</code>没有进行过扩容，它的标最大为9。于是此时会报出一个数组越界的异常<code>ArrayIndexOutOfBoundsException</code>.</li></ol><p>另外第二步 <code>elementData[size++] = e</code> 设置值的操作同样会导致线程不安全。从这儿可以看出，这步操作也不是一个原子操作，它由如下两步操作构成：</p><ol><li><code>elementData[size] = e;</code></li><li><code>size = size + 1;</code></li></ol><p>当多线程环境下执行时，可能就会发生<strong>一个线程的值覆盖另一个线程添加的值</strong>。</p><p>对应的线程安全类有哪些呢？接下来就涉及到我们同步容器。</p><h1 id="同步容器"><a href="#同步容器" class="headerlink" title="同步容器"></a>同步容器</h1><p>同步容器分两类，一种是Java提供好的类，另一类是Collections类中的相关同步方法。</p><h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p>Vector实现了List接口，Vector实际上就是一个数组，和ArrayList非常的类似，但是内部的方法都是使用<code>synchronized</code>修饰过的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vector 的add 方法实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是Vector也不是完全的线程安全的，比如：</p><p><strong>删除与获取并发操作</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VectorExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Vector&lt;Integer&gt; vector = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                vector.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">            Thread thread1 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">                        vector.remove(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            Thread thread2 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">                        vector.get(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            thread1.start();</span><br><span class="line">            thread2.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：报错<code>java.lang.ArrayIndexOutOfBoundsException: Array index out of range</code><br>原因分析：同时发生获取与删除的操作。当两个线程在同一时间都判断了vector的size，假设都判断为9，而下一刻线程1执行了remove操作，随后线程2才去get，所以就出现了错误。<strong>synchronized关键字可以保证同一时间只有一个线程执行该方法，但是多个线程同时分别执行remove、add、get操作的时候就无法控制了。</strong></p><p><strong>使用foreach\iterator遍历Vector的时候进行增删操作</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VectorExample3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 报错java.util.ConcurrentModificationException</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(Vector&lt;Integer&gt; v1)</span> </span>&#123; <span class="comment">// foreach</span></span><br><span class="line">        <span class="keyword">for</span>(Integer i : v1) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i.equals(<span class="number">3</span>)) &#123;</span><br><span class="line">                v1.remove(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 报错java.util.ConcurrentModificationException</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">(Vector&lt;Integer&gt; v1)</span> </span>&#123; <span class="comment">// iterator</span></span><br><span class="line">        Iterator&lt;Integer&gt; iterator = v1.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Integer i = iterator.next();</span><br><span class="line">            <span class="keyword">if</span> (i.equals(<span class="number">3</span>)) &#123;</span><br><span class="line">                v1.remove(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Vector&lt;Integer&gt; vector = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">        vector.add(<span class="number">1</span>);</span><br><span class="line">        vector.add(<span class="number">2</span>);</span><br><span class="line">        test1(vector);</span><br><span class="line">        test2(vector);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决办法：在使用iterator进行增删操作的时候，加上Lock或者synchronized同步措施或者并发容器</p><h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Make sure the value is not null</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Makes sure the key is not already in the hashtable.</span></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    <span class="keyword">for</span>(; entry != <span class="keyword">null</span> ; entry = entry.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">            V old = entry.value;</span><br><span class="line">            entry.value = value;</span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addEntry(hash, key, value, index);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码分析</p><ul><li><strong>使用了synchronized修饰</strong></li><li>保证安全性<strong>不允许空值</strong></li><li>HashMap和HashTable都使用哈希表来存储键值对</li></ul><h2 id="Collections类中的相关同步方法"><a href="#Collections类中的相关同步方法" class="headerlink" title="Collections类中的相关同步方法"></a>Collections类中的相关同步方法</h2><p><img src="http://image.onebug.tech/synContainer.png" alt="synContainer"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; list = Collections.synchronizedList(Lists.newArrayList());</span><br><span class="line"><span class="comment">//多线程调用方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    list.add(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;线程不安全类&quot;&gt;&lt;a href=&quot;#线程不安全类&quot; class=&quot;headerlink&quot; title=&quot;线程不安全类&quot;&gt;&lt;/a&gt;线程不安全类&lt;/h1&gt;&lt;p&gt;如果一个类的对象同时可以被多个线程访问，并且你不做特殊的同步或并发处理，那么它就很容易表现出线程不安全的现象。比如抛出异常、逻辑处理错误等。下面列举一下常见的线程不安全的类及对应的线程安全类：&lt;/p&gt;
    
    </summary>
    
    
      <category term="java高并发" scheme="http://www.onebug.tech/categories/java%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java" scheme="http://www.onebug.tech/tags/java/"/>
    
      <category term="并发" scheme="http://www.onebug.tech/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="笔记" scheme="http://www.onebug.tech/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>线程封闭</title>
    <link href="http://www.onebug.tech/2021/05/01/ch5%E7%BA%BF%E7%A8%8B%E5%B0%81%E9%97%AD/"/>
    <id>http://www.onebug.tech/2021/05/01/ch5%E7%BA%BF%E7%A8%8B%E5%B0%81%E9%97%AD/</id>
    <published>2021-04-30T16:00:00.000Z</published>
    <updated>2021-05-04T01:42:44.115Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程封闭"><a href="#线程封闭" class="headerlink" title="线程封闭"></a>线程封闭</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>当访问共享变量时，往往需要加锁来保证数据同步。<strong>一种避免使用同步的方式就是不共享数据。如果仅在单线程中访问数据，就不需要同步了，这种技术称为线程封闭。</strong></p><p>线程封闭技术有一个常见的应用，JDBC的Connection对象。Connection对象在实现的时候并没有对线程安全做太多的处理，JDBC的规范里也没有要求Connection对象必须是线程安全的。实际在服务器应用程序中，线程从连接池获取了一个Connection对象，使用完再把Connection对象返回给连接池，由于大多数请求都是由单线程采用同步的方式来处理的，并且在Connection对象返回之前，连接池不会将它分配给其他线程。因此这种连接管理模式处理请求时隐含的将Connection对象封闭在线程里面，这样我们使用的<strong>Connection对象虽然本身不是线程安全的，但是它通过线程封闭也做到了线程安全。</strong></p><a id="more"></a><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="Ad-hoc-线程封闭"><a href="#Ad-hoc-线程封闭" class="headerlink" title="Ad-hoc 线程封闭"></a>Ad-hoc 线程封闭</h3><p><code>Ad-hoc</code>线程封闭是指，维护线程封闭性的职责完全由程序实现来承担。Ad-hoc线程封闭是非常脆弱的，因为没有任何一种语言特性，例如可见性修饰符或局部变量，能将对象封闭到目标线程上。事实上，对线程封闭对象（例如，GUI应用程序中的可视化组件或数据模型等）的引用通常保存在公有变量中。</p><h3 id="堆栈封闭"><a href="#堆栈封闭" class="headerlink" title="堆栈封闭"></a>堆栈封闭</h3><p>堆栈封闭其实就是方法中定义局部变量。不存在并发问题。多个线程访问一个方法的时候，<strong>方法中的局部变量都会被拷贝一份到线程的栈中</strong>（Java内存模型），所以局部变量是不会被多个线程所共享的。</p><h3 id="ThreadLocal线程封闭"><a href="#ThreadLocal线程封闭" class="headerlink" title="ThreadLocal线程封闭"></a>ThreadLocal线程封闭</h3><p>它是一个特别好的封闭方法，其实<code>ThreadLocal</code>内部维护了一个<code>map</code>，<strong>map的key是每个线程的名称，而map的value就是我们要封闭的对象</strong>。<code>ThreadLocal</code>提供了<code>get</code>、<code>set</code>、<code>remove</code>方法，每个操作都是基于当前线程的，所以它是线程安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ThreadLocal的get方法源码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();<span class="comment">//当前线程对象</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);<span class="comment">//get操作基于当前线程</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ThreadLocal</code>的使用场景：</p><ul><li>实现单个线程单例以及单个线程上下文信息存储，比如交易id等</li><li>实现线程安全，非线程安全的对象使用<code>ThreadLocal</code>之后就会变得线程安全，因为每个线程都会有一个对应的实例</li><li>承载一些线程相关的数据，避免在方法中来回传递参数</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;线程封闭&quot;&gt;&lt;a href=&quot;#线程封闭&quot; class=&quot;headerlink&quot; title=&quot;线程封闭&quot;&gt;&lt;/a&gt;线程封闭&lt;/h1&gt;&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;当访问共享变量时，往往需要加锁来保证数据同步。&lt;strong&gt;一种避免使用同步的方式就是不共享数据。如果仅在单线程中访问数据，就不需要同步了，这种技术称为线程封闭。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;线程封闭技术有一个常见的应用，JDBC的Connection对象。Connection对象在实现的时候并没有对线程安全做太多的处理，JDBC的规范里也没有要求Connection对象必须是线程安全的。实际在服务器应用程序中，线程从连接池获取了一个Connection对象，使用完再把Connection对象返回给连接池，由于大多数请求都是由单线程采用同步的方式来处理的，并且在Connection对象返回之前，连接池不会将它分配给其他线程。因此这种连接管理模式处理请求时隐含的将Connection对象封闭在线程里面，这样我们使用的&lt;strong&gt;Connection对象虽然本身不是线程安全的，但是它通过线程封闭也做到了线程安全。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="java高并发" scheme="http://www.onebug.tech/categories/java%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java" scheme="http://www.onebug.tech/tags/java/"/>
    
      <category term="并发" scheme="http://www.onebug.tech/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="笔记" scheme="http://www.onebug.tech/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>不可变对象</title>
    <link href="http://www.onebug.tech/2021/04/30/ch4%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1/"/>
    <id>http://www.onebug.tech/2021/04/30/ch4%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1/</id>
    <published>2021-04-29T16:00:00.000Z</published>
    <updated>2021-05-04T01:42:38.198Z</updated>
    
    <content type="html"><![CDATA[<h1 id="不可变对象"><a href="#不可变对象" class="headerlink" title="不可变对象"></a>不可变对象</h1><p>不可变对象（Immutable Object）：对象一旦被创建后，对象所有的状态及属性在其生命周期内不会发生任何变化。发布不可变对象是安全的。</p><a id="more"></a><h2 id="自定义不可变类"><a href="#自定义不可变类" class="headerlink" title="自定义不可变类"></a>自定义不可变类</h2><p>通常来说，创建不可变类原则有以下几条：</p><ul><li><p>所有成员变量必须是<code>private</code>，同时用<code>final</code>修饰</p></li><li><p>将类声明为<code>final</code>，不允许类被继承</p></li><li><p>不提供能够修改原有对象状态的方法，最常见的方式是不提供<code>setter</code>方法</p></li><li><p>通过构造器初始化所有成员变量，引用类型的成员变量必须进行<strong>深拷贝(deep copy)</strong></p></li><li><p>在<code>get</code>方法中不直接返回对象的本身，而是克隆对象，返回对象的拷贝。</p></li></ul><p>下面是一个Immutable Object的例子，该对象可以用在并发环境下而没有线程安全问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,String address)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", address='"</span> + address + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java-unmodifiablexxx"><a href="#Java-unmodifiablexxx" class="headerlink" title="Java unmodifiablexxx"></a>Java unmodifiablexxx</h2><p>使用Java的<code>Collections</code>类的<code>unmodifiablexxx</code>相关方法，可以创建不可变对象。<code>xxx</code>方法包含：Collection、List、Map、Set….</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImmutableExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        map.put(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">        Map&lt;Integer, Integer&gt; unmodifiableMap = Collections.unmodifiableMap(map);</span><br><span class="line">        log.info(<span class="string">"&#123;&#125;"</span>, unmodifiableMap.get(<span class="number">1</span>));</span><br><span class="line">        unmodifiableMap.put(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>UnmodifiableMap</code>对<code>map</code>的<strong>更新方法（比如put、remove等）进行了重写</strong>，均返回<code>UnsupportedOperationException</code>异常，这样就做到了<code>map</code>对象的不可变。</p><h4 id="Guava-Immutablexxx"><a href="#Guava-Immutablexxx" class="headerlink" title="Guava Immutablexxx"></a>Guava Immutablexxx</h4><p>使用<code>Guava</code>的<code>Immutablexxx</code>类也可以创建不可变对象。<code>xxx</code>同样包含很多类型：Collection、List、Map、Set….</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ImmutableMap&lt;Integer, Integer&gt; map = ImmutableMap.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure><p><code>Immutable</code>相关类使用了跟Java的<code>unmodifiable</code>相关类相似的实现方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;不可变对象&quot;&gt;&lt;a href=&quot;#不可变对象&quot; class=&quot;headerlink&quot; title=&quot;不可变对象&quot;&gt;&lt;/a&gt;不可变对象&lt;/h1&gt;&lt;p&gt;不可变对象（Immutable Object）：对象一旦被创建后，对象所有的状态及属性在其生命周期内不会发生任何变化。发布不可变对象是安全的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java高并发" scheme="http://www.onebug.tech/categories/java%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java" scheme="http://www.onebug.tech/tags/java/"/>
    
      <category term="并发" scheme="http://www.onebug.tech/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="笔记" scheme="http://www.onebug.tech/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>安全发布对象</title>
    <link href="http://www.onebug.tech/2021/04/29/ch3%E5%AE%89%E5%85%A8%E5%8F%91%E5%B8%83%E5%AF%B9%E8%B1%A1/"/>
    <id>http://www.onebug.tech/2021/04/29/ch3%E5%AE%89%E5%85%A8%E5%8F%91%E5%B8%83%E5%AF%B9%E8%B1%A1/</id>
    <published>2021-04-28T16:00:00.000Z</published>
    <updated>2021-05-04T01:42:32.125Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安全发布对象"><a href="#安全发布对象" class="headerlink" title="安全发布对象"></a>安全发布对象</h1><h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><p>简单来说就是提供一个对象的引用给作用域之外的代码。比如<code>return</code>一个对象，或者作为参数传递到其他类的方法中。</p><h2 id="逸出"><a href="#逸出" class="headerlink" title="逸出"></a>逸出</h2><p>如果<strong>一个类还没有构造结束就已经提供给了外部代码一个对象引用</strong>即发布了该对象，此时叫做对象逸出，对象的逸出会破坏线程的安全性。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnsafeStates</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] states = <span class="keyword">new</span> String[]&#123;<span class="string">"AK"</span>, <span class="string">"AL"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String[] getStates()&#123;</span><br><span class="line">        <span class="keyword">return</span> states;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>states</code>变量作用域是<code>private</code>而我们在<code>getStates</code>方法中却把它发布了，这样就称为数组states逸出了它所在的作用域。</p><p>然而更加隐蔽和需要我们注意的是<code>this</code>逸出，这个问题要引起重点关注。观察以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThisEscape</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThisEscape</span><span class="params">(EventSource source)</span></span>&#123;</span><br><span class="line">        source.registerListener&#123;</span><br><span class="line">            <span class="keyword">new</span> EventListener()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event e)</span></span>&#123;</span><br><span class="line">                    doSomething(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//一些初始化工作</span></span><br><span class="line">        value = <span class="number">7</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Event e)</span></span>&#123;</span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在构造方法中我们定义了一个匿名内部类，匿名内部类是一个事件监听类，当事件监听类注册完毕后，实际上我们已经将<code>EventListener</code>匿名内部类发布出去了，而此时我们实际上已经携带了<code>this</code>逸出，重点在于这个时候我们还有一些初始化工作没有做完，这也就是上面所说的，一个类还没有构造结束我们已经将发布了。</p><h2 id="安全发布对象-1"><a href="#安全发布对象-1" class="headerlink" title="安全发布对象"></a>安全发布对象</h2><p>安全发布对象，共有四种方法</p><ul><li>在静态初始化函数中初始化一个对象引用</li><li>将对象的引用保存到<code>volatile</code>类型域或者<code>AtomicReference</code>对象中</li><li>对象的引用保存到某个正确构造对象的<code>final</code>类型域中</li><li>将对象的引用保存到一个由锁保护的域中</li></ul><p>下面我们用各种单例模式来演示其中的几种方法：</p><p><strong>懒汉式（最简式）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample</span> </span>&#123;</span><br><span class="line">    <span class="comment">//私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonExample instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SingletonExample();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在多线程环境下，当两个线程同时访问这个方法，同时制定到<code>instance==null</code>的判断。都判断为<code>null</code>，接下来同时执行<code>new</code>操作，这样类的构造函数被执行了两次。一旦构造函数中涉及到某些资源的处理，那么就会发生错误。所以说最简懒汉式是<strong>线程不安全的</strong>。</p><p><strong>懒汉式（synchronized）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在类的静态方法上使用synchronized修饰</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SingletonExample <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用synchronized修饰静态方法后，同一时间只有一个线程访问该方，保证了线程安全性，但会造成性能损耗。</p><p><strong>双重同步锁模式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单例对象</span></span><br><span class="line">    <span class="comment">//在对象声明时使用volatile关键字修饰，阻止CPU的指令重排。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> SingletonExample instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 静态的工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; <span class="comment">// 双重检测机制</span></span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonExample<span class="class">.<span class="keyword">class</span>) </span>&#123; <span class="comment">// 同步锁</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SingletonExample();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先判断一次后，再锁定整个类，再加上一次的双重同步锁，保证了最大程度上的避免耗损性能。</p><p>为什么要使用<code>volatile</code>关键字修饰对象引用？</p><p>执行new操作的时候，CPU会进行了三次指令：</p><ol><li><code>memory = allocate()</code> 分配对象的内存空间</li><li><code>ctorInstance()</code> 初始化对象</li><li><code>instance = memory</code> 设置instance指向刚分配的内存</li></ol><p>在程序运行过程中，CPU为提高运算速度会做出违背代码原有顺序的优化。我们称之为乱序执行优化或者说是指令重排。<br>那么上面知识点中的三步指令极有可能被优化为1、3、2的顺序。当我们有两个线程A与B，A线程遵从1、3、2的顺序，经过了两此<code>instance</code>的空值判断后，执行了<code>new</code>操作，并且cpu在某一瞬间刚结束指令3，并且还没有执行指令2。而在此时线程B恰巧在进行第一次的<code>instance</code>空值判断，由于线程A执行完3指令，为<code>instance</code>分配了内存，线程B判断<code>instance</code>不为空，直接执行<code>return</code>，返回了<code>instance</code>，这样就出现了错误。</p><p><img src="http://image.onebug.tech/20180409165630129" alt="img"></p><p><strong>饿汉式（最简式）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonExample instance = <span class="keyword">new</span> SingletonExample();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态的工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>饿汉模式由于单例实例是在类装载的时候进行创建，因此只会被执行一次，所以它是<strong>线程安全</strong>的。如果构造函数中有着大量的操作要做，类的装载时间会很长。要是只做了类的构造，却没有使用构造好的对象，那么会造成资源浪费。所以饿汉模式适用于以下场景：私有构造函数在实现的时候没有太多的处理，占用系统资源少；这个类在实例化后很大概率会被使用。</p><p><strong>枚举式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Singleton.INSTANCE.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line">        <span class="keyword">private</span> SingletonExample singleton;</span><br><span class="line"></span><br><span class="line">        Singleton() &#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> SingletonExample();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> SingletonExample <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> singleton;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于枚举类的特殊性，因为Java保证枚举类的每个枚举都是单例，上诉代码构造函数<code>Singleton</code>方法只会被实例化一次，且是这个类被调用之前。对比懒汉与饿汉模式，它的<strong>优势很明显</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;安全发布对象&quot;&gt;&lt;a href=&quot;#安全发布对象&quot; class=&quot;headerlink&quot; title=&quot;安全发布对象&quot;&gt;&lt;/a&gt;安全发布对象&lt;/h1&gt;&lt;h2 id=&quot;发布&quot;&gt;&lt;a href=&quot;#发布&quot; class=&quot;headerlink&quot; title=&quot;发布&quot;&gt;&lt;/a&gt;发布&lt;/h2&gt;&lt;p&gt;简单来说就是提供一个对象的引用给作用域之外的代码。比如&lt;code&gt;return&lt;/code&gt;一个对象，或者作为参数传递到其他类的方法中。&lt;/p&gt;
&lt;h2 id=&quot;逸出&quot;&gt;&lt;a href=&quot;#逸出&quot; class=&quot;headerlink&quot; title=&quot;逸出&quot;&gt;&lt;/a&gt;逸出&lt;/h2&gt;&lt;p&gt;如果&lt;strong&gt;一个类还没有构造结束就已经提供给了外部代码一个对象引用&lt;/strong&gt;即发布了该对象，此时叫做对象逸出，对象的逸出会破坏线程的安全性。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java高并发" scheme="http://www.onebug.tech/categories/java%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java" scheme="http://www.onebug.tech/tags/java/"/>
    
      <category term="并发" scheme="http://www.onebug.tech/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="笔记" scheme="http://www.onebug.tech/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>线程安全性</title>
    <link href="http://www.onebug.tech/2021/04/28/ch2%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7/"/>
    <id>http://www.onebug.tech/2021/04/28/ch2%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7/</id>
    <published>2021-04-27T16:00:00.000Z</published>
    <updated>2021-05-04T01:42:23.128Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>当多个线程访问某个类时，不管运行时环境采用<strong>何种调度方式</strong>或者这些进程将如何交替执行，并且在主调代码中<strong>不需要任何额外的同步或协同</strong>，这个类都能表现出<strong>正确的行为</strong>，那么就称这个类是线程安全的。</p><a id="more"></a><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>线程安全性主要体现在三个方面：</p><ul><li>原子性：提供了<strong>互斥访问</strong>，同一时刻只能有一个线程来对它进行操作</li><li>可见性：一个线程对主内存的修改可以及时的被其他线程观察到</li><li>有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序的存在，该观察结果一般杂乱无序。</li></ul><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>说到原子性，一般涉及两个机制：</p><ul><li>JDK中已经提供好的Atomic包，他们均使用了CAS完成线程的原子性操作</li><li>使用锁的机制来处理线程之间的原子性。锁包括：synchronized、Lock</li></ul><h3 id="Atomic包"><a href="#Atomic包" class="headerlink" title="Atomic包"></a>Atomic包</h3><p><img src="http://image.onebug.tech/image-20210504002340565.png" alt="image-20210504002340565"></p><h4 id="AtomicInteger与CAS"><a href="#AtomicInteger与CAS" class="headerlink" title="AtomicInteger与CAS"></a>AtomicInteger与CAS</h4><p>我们从最简单的AtomicInteger类来了解什么是CAS</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该方法功能是Interger类型加1</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//主要看这个getAndAddInt方法</span></span><br><span class="line">       <span class="comment">//var1 传入this指针</span></span><br><span class="line"><span class="comment">//var2 传入地址偏移量</span></span><br><span class="line"><span class="comment">//var4 传入自增1</span></span><br><span class="line">       <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//var1 要操作的对象</span></span><br><span class="line"><span class="comment">//var2 期望底层当前的数值</span></span><br><span class="line"><span class="comment">//var4 要自增的数值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line"><span class="comment">//获取内存值，但此时内存值已经是旧的，假设我们称作期望值E</span></span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">        <span class="comment">//compareAndSwapInt方法是重点，</span></span><br><span class="line">        <span class="comment">//var5是期望值，var5 + var4是要更新的值</span></span><br><span class="line">        <span class="comment">//这个操作就是调用CAS的JNI,每个线程将自己内存里的内存值M与var5期望值E作比较，如果相同将内存值M更新为var5 + var4,否则做自旋操作</span></span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释一下<code>getAndAddInt</code>方法的流程：</p><p>假设有一下情景：</p><ol><li>A、B两个线程</li><li>jvm主内存的值1，A、B本地内存的值为1（本地内存会拷贝一份主内存的值）</li><li>当前期望值为1，做加1操作</li><li>此时<code>var5 = 1</code>，<code>var4 = 1</code>；<ol><li>A线程将<code>var5</code>与工作内存值<code>M</code>比较，比较<code>var5</code>是否等于1</li><li>如果相同则将工作内存值修改为<code>var5 + var4</code> 即修改为2并同步到主内存，此时<code>this + valueOffset</code>指针里的值就是2，结束循环</li><li>如果不相同，则是B线程修改了主内存的值，说明B线程已经先于A线程做了加1操作，A线程没有更新成功需要继续循环，注意此时<code>var5</code>更新为新的内存值，假设当前的内存值是2，那么此时<code>var5 = 2，var + var4 = 3</code>，重复上述步骤直到成功（自旋），成功之后，内存地址中的值就改变为3</li></ol></li></ol><p><strong>CAS优缺点</strong></p><ul><li><p>优点：非阻塞的轻量级的乐观锁，通过CPU指令实现，在资源竞争不激烈的情况下性能高，相比synchronized重量锁，synchronized会进行比较复杂的加锁、解锁和唤醒操作。</p></li><li><p>缺点：</p><ul><li><code>ABA</code>问题： 线程C、D；线程D将A修改为B后又修改为A，此时C线程以为A没有改变过。<code>java</code>的原子类<code>AtomicStampedReference</code>，通过<strong>控制变量值的版本号</strong>来保证CAS的正确性。具体解决思路就是在变量前追加上版本号，每次变量更新的时候把版本号加一，那么<code>A - B - A</code>就会变成<code>1A - 2B - 3A</code>。</li><li>自旋时间过长，消耗CPU资源，如果资源竞争激烈，多线程自旋长时间消耗资源。</li></ul></li></ul><blockquote><p><a href="https://www.jianshu.com/p/db5c964a61ee" target="_blank" rel="noopener">深入理解CAS（乐观锁） - 简书 (jianshu.com)</a></p></blockquote><h4 id="LongAdder"><a href="#LongAdder" class="headerlink" title="LongAdder"></a>LongAdder</h4><p><strong>AtomicLong 的缺陷</strong></p><p>AtomicLong 的 Add() 是依赖自旋不断的 CAS 去累加一个 Long 值。如果在竞争激烈的情况下，CAS 操作不断的失败，就会有大量的线程不断的自旋尝试 CAS 会造成 CPU 的极大的消耗。</p><p><strong>LongAdder</strong> </p><p>LongAdder 功能类似 AtomicLong ，在低并发情况下二者表现差不多，在高并发情况下 LongAdder 的表现就会好很多。</p><p>LongAdder先尝试一次cas更新，如果失败会转而通过Cell[]的方式更新值，如果计算index的方式足够散列，那么在并发量大的情况下，多个线程定位到同一个cell的概率也就越低，这有点类似于分段锁的意思。</p><p>当需要在高并发下有较好的性能表现，且对值的精确度要求不高时，可以使用LongAdder（例如网站访问人数计数）。 当需要保证线程安全，可允许一些性能损耗，要求高精度时，可以使用AtomicLong（例如自增id）。</p><blockquote><p><a href="https://juejin.cn/post/6844903891310477325" target="_blank" rel="noopener">深入剖析LongAdder是咋干活的 (juejin.cn)</a></p><p><a href="https://xilidou.com/2018/11/27/LongAdder/" target="_blank" rel="noopener">从 LongAdder 中窥见并发组件的设计思路 | 犀利豆的博客 (xilidou.com)</a></p></blockquote><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p><strong>AtomicBoolean</strong></p><p>常用于控制某一件事只让一个线程执行，并仅能执行一次。</p><p><strong>AtomicIntegerFieldUpdater</strong></p><p>这个类的核心作用是要更新一个指定的类的某一个字段的值。并且这个字段一定要用volatile修饰同时还不能是static的。</p><p><strong>AtomicLongArray</strong></p><p>这个类实际上维护了一个Array数组，我们在对数值进行更新的时候，会多一个索引值让我们更新。</p><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>synchronized是java中的一个关键字，是一种同步锁。在synchronized关键字作用范围内，同一时刻只能有一个线程对其进行操作的。</p><p>它可以修饰的对象主要有四种：</p><ul><li>修饰代码块：大括号括起来的代码，作用于调用的对象</li><li>修饰方法：整个方法，作用于调用的对象</li><li>修饰静态方法：整个静态方法，作用于所有对象</li><li>修饰类：括号括起来的部分，作用于所有对象</li></ul><h3 id="原子性操作各方法间的对比"><a href="#原子性操作各方法间的对比" class="headerlink" title="原子性操作各方法间的对比"></a>原子性操作各方法间的对比</h3><ul><li>synchronized:不可中断锁，适合竞争不激烈，可读性好</li><li>Lock：可中断锁，多样化同步，竞争激烈时能维持常态</li><li>Atomic:竞争激烈时能维持常态，比Lock性能好，每次只能同步一个值</li></ul><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>可见性是指一个线程对主内存的修改可以及时的被其他线程观察到。导致共享变量在线程间不可见的原因有：</p><ul><li>线程交叉执行</li><li>重排序结合线程交叉执行</li><li>共享变量更新后的值没有在工作内存与主存间及时更新</li></ul><p>JVM对于可见性，提供了synchronized和volatile。</p><h3 id="synchronized-1"><a href="#synchronized-1" class="headerlink" title="synchronized"></a>synchronized</h3><p>JMM关于synchronized的两条规定：</p><ul><li>线程解锁前，必须把共享变量的最新值刷新到主内存</li><li>线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值（注意：<strong>加锁与解锁是同一把锁</strong>）</li></ul><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>volatile通过加入<strong>内存屏障</strong>和<strong>禁止重排序</strong>优化来实现</p><ul><li><p>对volatile变量写操作时，会在写操作后加入一条store屏障指令，将本地内存中的共享变量值刷新到主内存</p><p><img src="http://image.onebug.tech/image-20210504003303719.png" alt="image-20210504003303719"></p></li><li><p>对volatile变量读操作时，会在读操作前加入一条load屏障指令，从主内存中读取共享变量</p><p><img src="http://image.onebug.tech/image-20210504003330856.png" alt="image-20210504003330856"></p></li><li><p>volatile的屏障操作都是cpu级别的</p></li><li><p>volatile关键字<strong>不具有原子性</strong>，不适合累加值。volatile适合状态验证，在修饰状态标记量时，要保证对：</p><ul><li>变量的写操作不依赖于当前值</li><li>该变量没有包含在具有其他变量的式子中</li></ul></li></ul><h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>Java内存模型中，允许编译器和处理器对指令进行<strong>重排序</strong>，但是重排序过程不会影响到<strong>单线程</strong>程序的执行，却会影响到多线程并发执行的正确性。</p><p>java提供了 volatile、synchronized、Lock可以用来保证有序性。另外，java内存模型具备一些先天的有序性，即不需要任何手段就能得到保证的有序性。通常被我们成为happens-before原则（先行发生原则）。如果两个线程的执行顺序无法从happens-before原则推导出来，那么就不能保证它们的有序性，虚拟机就可以对它们进行重排序。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;线程安全性&quot;&gt;&lt;a href=&quot;#线程安全性&quot; class=&quot;headerlink&quot; title=&quot;线程安全性&quot;&gt;&lt;/a&gt;线程安全性&lt;/h2&gt;&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;当多个线程访问某个类时，不管运行时环境采用&lt;strong&gt;何种调度方式&lt;/strong&gt;或者这些进程将如何交替执行，并且在主调代码中&lt;strong&gt;不需要任何额外的同步或协同&lt;/strong&gt;，这个类都能表现出&lt;strong&gt;正确的行为&lt;/strong&gt;，那么就称这个类是线程安全的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java高并发" scheme="http://www.onebug.tech/categories/java%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java" scheme="http://www.onebug.tech/tags/java/"/>
    
      <category term="并发" scheme="http://www.onebug.tech/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="笔记" scheme="http://www.onebug.tech/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>高并发相关基础知识</title>
    <link href="http://www.onebug.tech/2021/04/27/ch1%E5%9F%BA%E7%A1%80/"/>
    <id>http://www.onebug.tech/2021/04/27/ch1%E5%9F%BA%E7%A1%80/</id>
    <published>2021-04-26T16:00:00.000Z</published>
    <updated>2021-05-04T01:42:14.828Z</updated>
    
    <content type="html"><![CDATA[<h1 id="高并发相关基础知识"><a href="#高并发相关基础知识" class="headerlink" title="高并发相关基础知识"></a>高并发相关基础知识</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li><p>并发</p><p>同时拥有两个或者多个线程，如果程序在单核处理器上运行，多个线程将交替地还如或者换出内存，这些线程是同时”存在”的，每个线程都处于执行过程中的某个状态，如果运行在多核处理器上，此时，程序中的每个线程都将分配到一个处理器核上，因此可以同时运行。</p></li><li><p>高并发</p><p>高并发是互联网分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计保证系统能够同时并行处理很多请求。</p><a id="more"></a></li><li><p>CPU多级缓存</p><p>CPU的频率太快了，快到主存跟不上，这样在处理器时钟周期内，CPU常常需要等待主存，浪费资源，所以cache的出现，是<strong>为了缓解CPU和内存之间速度的不匹配问题</strong>。</p><p><img src="http://image.onebug.tech/image-20210504002724606.png" alt="image-20210504002724606"></p></li><li><p>局部性原理</p><ul><li>时间局部性：如果某个数据被访问，那么在不久的将来它很可能被再次访问。</li><li>空间局部性：如果某个数据被访问，那么与他相邻的数据很快也可能被访问。</li></ul></li><li><p>乱序执行优化</p><p>处理器为提高运算速度而做出违背代码原有顺序的优化。</p></li></ul><h2 id="多核CPU多级缓存一致性协议MESI"><a href="#多核CPU多级缓存一致性协议MESI" class="headerlink" title="多核CPU多级缓存一致性协议MESI"></a>多核CPU多级缓存一致性协议MESI</h2><p>多核CPU的情况下有多个一级缓存，如何保证缓存内部数据的一致,不让系统数据混乱。这里就引出了一个一致性的协议MESI。</p><h3 id="MESI协议缓存状态"><a href="#MESI协议缓存状态" class="headerlink" title="MESI协议缓存状态"></a>MESI协议缓存状态</h3><p>MESI 是指4中状态的首字母。每个Cache line有4个状态，可用2个bit表示，它们分别是：</p><blockquote><p><strong>缓存行（Cache line）</strong>:缓存存储数据的单元。</p></blockquote><table><thead><tr><th align="left">状态</th><th align="left">描述</th><th align="left">监听任务</th></tr></thead><tbody><tr><td align="left">M 修改 (Modified)</td><td align="left">该Cache line有效，数据被修改了，和内存中的数据不一致，数据只存在于本Cache中。</td><td align="left">缓存行必须时刻监听所有试图读该缓存行相对就主存的操作，这种操作必须在缓存将该缓存行写回主存并将状态变成S（共享）状态之前被延迟执行。</td></tr><tr><td align="left">E 独享、互斥 (Exclusive)</td><td align="left">该Cache line有效，数据和内存中的数据一致，数据只存在于本Cache中。</td><td align="left">缓存行也必须监听其它缓存读主存中该缓存行的操作，一旦有这种操作，该缓存行需要变成S（共享）状态。</td></tr><tr><td align="left">S 共享 (Shared)</td><td align="left">该Cache line有效，数据和内存中的数据一致，数据存在于很多Cache中。</td><td align="left">缓存行也必须监听其它缓存使该缓存行无效或者独享该缓存行的请求，并将该缓存行变成无效（Invalid）。</td></tr><tr><td align="left">I 无效 (Invalid)</td><td align="left">该Cache line无效。</td><td align="left">无</td></tr></tbody></table><h3 id="MESI状态转换"><a href="#MESI状态转换" class="headerlink" title="MESI状态转换"></a>MESI状态转换</h3><p><img src="http://image.onebug.tech/image-20210504002838073.png" alt="image-20210504002838073"></p><p>说明：</p><ul><li>触发事件</li></ul><table><thead><tr><th align="left">触发事件</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">本地读取（Local read）</td><td align="left">本地cache读取本地cache数据</td></tr><tr><td align="left">本地写入（Local write）</td><td align="left">本地cache写入本地cache数据</td></tr><tr><td align="left">远端读取（Remote read）</td><td align="left">其他cache读取本地cache数据</td></tr><tr><td align="left">远端写入（Remote write）</td><td align="left">其他cache写入本地cache数据</td></tr></tbody></table><ul><li><p>cache分类：</p><blockquote><p>前提：所有的cache共同缓存了主内存中的某一条数据。</p><p>注意：本地的事件触发 本地cache和触发cache为相同。</p></blockquote><ul><li>本地cache:指当前cpu的cache</li><li>触发cache:触发读写事件的cache</li><li>其他cache:指既除了以上两种之外的cache</li></ul></li></ul><h2 id="MESI与Java"><a href="#MESI与Java" class="headerlink" title="MESI与Java"></a>MESI与Java</h2><p>缓存的一致性消息传递是要时间的，这就使其切换时会产生延迟。当一个缓存被切换状态时其他缓存收到消息完成各自的切换并且发出回应消息这么一长串的时间中CPU都会等待所有缓存响应完成。可能出现的阻塞都会导致各种各样的性能问题和稳定性问题。</p><p>这对于程序员来说简直是一个灾难。幸好java解决了这个问题，至于如何解决的请关注JMM(JavaMemoryMode)。</p><blockquote><p><a href="https://www.cnblogs.com/yanlong300/p/8986041.html" target="_blank" rel="noopener">并发研究之CPU缓存一致性协议(MESI) - 枫飘雪落 - 博客园 (cnblogs.com)</a></p></blockquote><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><h3 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h3><p>Java内存模型（Java Memory Model）即JMM是一个<strong>抽象</strong>的概念。Java内存模型（JMM）定义了Java虚拟机（JVM）在计算机内存（RAM）中的工作规范。在硬件内存模型中，各种CPU架构的实现是不尽相同的，Java作为跨平台的语言，为了屏蔽底层硬件差异，定义了Java内存模型（JMM）。JMM作用于JVM和底层硬件之间，屏蔽了下游不同硬件模型带来的差异，为上游开发者提供了统一的使用接口。说了这么多其实就是想说明白JMM——JVM——硬件的关系。总之一句话，JMM是JVM的内存使用规范，是一个抽象的概念。</p><p><img src="http://image.onebug.tech/image-20210504003219866.png" alt="image-20210504003219866"></p><h3 id="JMM主内存和本地内存交互操作"><a href="#JMM主内存和本地内存交互操作" class="headerlink" title="JMM主内存和本地内存交互操作"></a>JMM主内存和本地内存交互操作</h3><p><img src="http://image.onebug.tech/image-20210504003101783.png" alt="image-20210504003101783"></p><p> 计算机硬件内存模型有缓存和主内存的交互协议MESI，同样JMM也规范了主内存和线程工作内存进行数据交换操作。一共包括如上图所示的8中操作，并且每个操作都是原子性的。</p><ol><li><strong>lock(锁定)：</strong>作用于主内存的变量，一个变量在同一时间只能一个线程锁定。该操作表示该线程独占锁定的变量。</li><li><strong>unlock(解锁)：</strong>作用于主内存的变量，表示这个变量的状态由处于锁定状态被释放，这样其他线程才能对该变量进行锁定。</li><li><strong>read(读取)：</strong>作用于主内存变量，表示把一个主内存变量的值传输到线程的工作内存，以便随后的load操作使用。</li><li><strong>load(载入)：</strong>作用于线程的工作内存的变量，表示把read操作从主内存中读取的变量的值放到工作内存的变量副本中(副本是相对于主内存的变量而言的)。</li><li><strong>use(使用)：</strong>作用于线程的工作内存中的变量，表示把工作内存中的一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时就会执行该操作。</li><li><strong>assign(赋值)：</strong>作用于线程的工作内存的变量，表示把执行引擎返回的结果赋值给工作内存中的变量，每当虚拟机遇到一个给变量赋值的字节码指令时就会执行该操作。</li><li><strong>store(存储)：</strong>作用于线程的工作内存中的变量，把工作内存中的一个变量的值传递给主内存，以便随后的write操作使用。</li><li><strong>write(写入)：</strong>作用于主内存的变量，把store操作从工作内存中得到的变量的值放入主内存的变量中。</li></ol><p>JMM规定了以上8中操作需要按照如下规则进行</p><ul><li>不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。</li><li>不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</li><li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中。</li><li>一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。</li><li>一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。</li><li>如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。</li><li>如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定住的变量。</li></ul><p>以上8中规则看着也是比较生涩的，其实如果你没看明白也没关系，其实这些规则就是保障数据同步的一些规则。不是很重要，重要的在后面的<strong>happens-before原则</strong>。</p><h3 id="并发环境下JMM存在的问题"><a href="#并发环境下JMM存在的问题" class="headerlink" title="并发环境下JMM存在的问题"></a>并发环境下JMM存在的问题</h3><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>JMM保证了四章节中的8个操作是原子性的，Java语言本身对基本数据类型的变量的读取和赋值操作是原子性操作。（JVM不对double和long类型的变量做原子性保障，可能的原因是缓存行的大小导致的）</p><p>比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x ++;</span><br></pre></td></tr></table></figure><p>x ++；不是原子操作，因为这行代码包含三个操作：加载x的值，执行 ++，然后写入新值。<br>在并发环境下，为了保证原子性通常采用synchronized或者Lock对代码块加锁保证原子性</p><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>在Java中提供了一个volatile关键字来保证可见性。当一个主内存中的共享变量被volatile关键字修饰时，一个线程对该变量的修改会被立即刷新（store）到主内存，保证<strong>其他线程看到的值一定是最新的</strong>。<strong>JMM层面上volatile是通过load/store操作实现的可见性</strong>。</p><p>当然我们也可以通过synchronized和Lock通过加锁将多线程进行同步也就是串行执行来保证共享变量的可见性。</p><h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p><strong>happens-before原则</strong></p><ul><li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于后面的操作。</li><li>锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作。（先释放锁，才能加锁）</li><li>volatile变量规则：对同一个变量的写操作先行发生于后面对这个变量的读操作。</li><li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于C，则A先行发生于操作C。</li><li>线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作。</li><li>线程终结规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生。</li><li>线程终结规则：线程中所有的操作都先行发生于线程的终结检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行。</li><li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始。</li></ul><p><strong>happens-before与可见性</strong><br>happens-before通过以上8中规则保证可见性，如果一个操作A happens-before 另一个操作B，那么操作A的结果是对操作B可见的。不难理解。</p><p><strong>happens-before与重排序</strong><br>两个操作如果存在happens-before关系，并不意味着一定是有序进行的，因为JVM存在指令重排优化，如果JVM认为两个操作重排序有利于性能提升并且重排序后的操作和未重排结果一致，将进行指令重排序。当然JVM层面的重排序发生于编译期，运行时的指令重排是处理器决定的。Java语言通过volatile关键字通过向主内存加入内存屏障实现禁止指令重排。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;高并发相关基础知识&quot;&gt;&lt;a href=&quot;#高并发相关基础知识&quot; class=&quot;headerlink&quot; title=&quot;高并发相关基础知识&quot;&gt;&lt;/a&gt;高并发相关基础知识&lt;/h1&gt;&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;并发&lt;/p&gt;
&lt;p&gt;同时拥有两个或者多个线程，如果程序在单核处理器上运行，多个线程将交替地还如或者换出内存，这些线程是同时”存在”的，每个线程都处于执行过程中的某个状态，如果运行在多核处理器上，此时，程序中的每个线程都将分配到一个处理器核上，因此可以同时运行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;高并发&lt;/p&gt;
&lt;p&gt;高并发是互联网分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计保证系统能够同时并行处理很多请求。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java高并发" scheme="http://www.onebug.tech/categories/java%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java" scheme="http://www.onebug.tech/tags/java/"/>
    
      <category term="并发" scheme="http://www.onebug.tech/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="笔记" scheme="http://www.onebug.tech/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>用 VSCode + Wsl 搭建 linux 开发环境</title>
    <link href="http://www.onebug.tech/2020/10/20/vscode%E4%BD%BF%E7%94%A8wsl/"/>
    <id>http://www.onebug.tech/2020/10/20/vscode%E4%BD%BF%E7%94%A8wsl/</id>
    <published>2020-10-19T16:00:00.000Z</published>
    <updated>2020-10-21T14:33:39.466Z</updated>
    
    <content type="html"><![CDATA[<p>使用vscode + Wsl 可以改善C++/C的开发体验</p><p><img src="https://code.visualstudio.com/assets/docs/remote/wsl/architecture-wsl.png" alt="WSL Architecture"></p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><ul><li><a href="https://docs.microsoft.com/zh-cn/windows/wsl/install-win10" target="_blank" rel="noopener">安装 WSL</a></li><li>在 Windows 端(不是在 WSL 中)安装 <a href="https://code.visualstudio.com/" target="_blank" rel="noopener">Vs Code</a></li></ul><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><ul><li><p>安装Vs Code扩展<a href="https://aka.ms/vscode-remote/download/extension" target="_blank" rel="noopener">Remote Development extension pack</a></p></li><li><p>在<strong>WSL端</strong>安装C++/C 语言扩展（以下是我个人安装的一些扩展）</p><p><img src="http://image.onebug.tech/image-20201021222529606.png-d" alt="image-20201021222529606"></p></li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="初始化项目文件夹"><a href="#初始化项目文件夹" class="headerlink" title="初始化项目文件夹"></a>初始化项目文件夹</h3><ul><li><p>打开vscode</p></li><li><p><code>F1</code>-&gt;<code>Remote-WSL: New Window</code> ，或者点击左下角的绿色按钮</p><p><img src="http://image.onebug.tech/image-20201021222425486.png-d" alt="image-20201021222425486"></p></li><li><p>新建bash终端，使用<code>mkdir</code>等命令新建项目文件夹</p></li></ul><p><img src="http://image.onebug.tech/image-20201021222133299.png-d" alt="image-20201021222133299"></p><ul><li>菜单<code>文件</code>-&gt;<code>打开文件夹</code></li><li><img src="http://image.onebug.tech/image-20201021222248879.png-d" alt="image-20201021222248879"></li></ul><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><ul><li><p>新建测试文件<code>test.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Hello World"</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在安装<code>code runner</code>扩展的前提下，<code>右键</code>- &gt;<code>run code</code>，可以看到，成功运行</p></li></ul><p><img src="http://image.onebug.tech/image-20201021222646711.png-d" alt="image-20201021222646711"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用vscode + Wsl 可以改善C++/C的开发体验&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://code.visualstudio.com/assets/docs/remote/wsl/architecture-wsl.png&quot; alt=&quot;WSL Architecture&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="http://www.onebug.tech/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://www.onebug.tech/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="vscode" scheme="http://www.onebug.tech/tags/vscode/"/>
    
      <category term="wsl" scheme="http://www.onebug.tech/tags/wsl/"/>
    
      <category term="windows" scheme="http://www.onebug.tech/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>使用ventoy制作多系统启动盘</title>
    <link href="http://www.onebug.tech/2020/09/22/ventoy/"/>
    <id>http://www.onebug.tech/2020/09/22/ventoy/</id>
    <published>2020-09-21T16:00:00.000Z</published>
    <updated>2020-09-22T06:19:23.096Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ventoy介绍"><a href="#ventoy介绍" class="headerlink" title="ventoy介绍"></a>ventoy介绍</h2><p>Ventoy是一个制作可启动U盘的开源工具。有了Ventoy你就无需反复地格式化U盘，你<strong>只需要把ISO/WIM/IMG/VHD(x)/EFI文件拷贝到U盘</strong>里面就可以启动了，无需其他操作。 你可以一次性拷贝很<strong>多个</strong>不同类型的ISO文件，在启动时Ventoy会显示一个菜单来选择。</p><a id="more"></a><p><img src="http://image.onebug.tech/screen_uefi.png" alt="img"></p><p>ventoy能够无差异支持Legacy BIOS和UEFI模式，并且支持大部分常见操作系统 （Windows/WinPE/Linux/Unix/VMware/Xen 等等）</p><h2 id="制作启动盘"><a href="#制作启动盘" class="headerlink" title="制作启动盘"></a>制作启动盘</h2><p>在<a href="https://www.lanzoux.com/b01bd54gb" target="_blank" rel="noopener">这里</a>，下载安装包，例如 ventoy-1.0.15-windows.zip 然后解压开。直接执行 <code>Ventoy2Disk.exe</code> 如下图所示，选择U盘设备，然后点击 Install 按钮即可。</p><p><img src="http://image.onebug.tech/ventoy2disk2_cn.png" alt="img"></p><blockquote><p><strong>选择安装的时候，U盘将会被格式化，里面所有的数据都会丢失！！！</strong></p></blockquote><h2 id="启动盘的使用"><a href="#启动盘的使用" class="headerlink" title="启动盘的使用"></a>启动盘的使用</h2><p>你只需要把ISO文件拷贝到这里面即可。你可以把ISO文件放在<strong>任意目录以及子目录</strong>下。 Ventoy默认会遍历所有的目录和子目录，找出所有的ISO文件，并按照字母排序之后显示在菜单中。需要注意的是，<strong>ISO文件的全路径中(包括目录、子目录和文件名)不能包含中文或者空格</strong>。</p><p>至于如何从u盘启动系统，可以自行搜索关键词<strong>电脑型号+U盘启动</strong>，比如我用的是的华为matebook，就可以搜索<strong>华为matebook u盘启动</strong>。</p><p><img src="http://image.onebug.tech/image-20200922141917108.png" alt="image-20200922141917108"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;ventoy介绍&quot;&gt;&lt;a href=&quot;#ventoy介绍&quot; class=&quot;headerlink&quot; title=&quot;ventoy介绍&quot;&gt;&lt;/a&gt;ventoy介绍&lt;/h2&gt;&lt;p&gt;Ventoy是一个制作可启动U盘的开源工具。有了Ventoy你就无需反复地格式化U盘，你&lt;strong&gt;只需要把ISO/WIM/IMG/VHD(x)/EFI文件拷贝到U盘&lt;/strong&gt;里面就可以启动了，无需其他操作。 你可以一次性拷贝很&lt;strong&gt;多个&lt;/strong&gt;不同类型的ISO文件，在启动时Ventoy会显示一个菜单来选择。&lt;/p&gt;
    
    </summary>
    
    
      <category term="系统" scheme="http://www.onebug.tech/categories/%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="多系统" scheme="http://www.onebug.tech/tags/%E5%A4%9A%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="U盘" scheme="http://www.onebug.tech/tags/U%E7%9B%98/"/>
    
      <category term="工具" scheme="http://www.onebug.tech/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>navicat for windows 激活</title>
    <link href="http://www.onebug.tech/2020/08/27/navicat%E6%BF%80%E6%B4%BB/"/>
    <id>http://www.onebug.tech/2020/08/27/navicat%E6%BF%80%E6%B4%BB/</id>
    <published>2020-08-26T16:00:00.000Z</published>
    <updated>2020-09-03T07:57:59.173Z</updated>
    
    <content type="html"><![CDATA[<p>本教程用于激活windows 版本的navicat-premium。</p><a id="more"></a><h2 id="下载安装navicat"><a href="#下载安装navicat" class="headerlink" title="下载安装navicat"></a>下载安装navicat</h2><p>到官网下载navicat，<a href="https://www.navicat.com.cn/products/navicat-premium" target="_blank" rel="noopener">https://www.navicat.com.cn/products/navicat-premium</a>。下载完成后安装。安装过程中请记下navicat的安装目录，后面会用到。</p><h2 id="编译激活工具"><a href="#编译激活工具" class="headerlink" title="编译激活工具"></a>编译激活工具</h2><p>激活工具的github项目地址：<a href="https://github.com/HeQuanX/navicat-keygen-tools/tree/windows" target="_blank" rel="noopener">https://github.com/HeQuanX/navicat-keygen-tools/tree/windows</a></p><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><ol><li><p>请确保你有 <strong>Visual Studio 2019</strong> 或者更高版本。因为这是一个VS2019项目。</p></li><li><p>请确保你安装了 <code>vcpkg</code> 以及下面几个库：</p><ul><li><code>capstone[x86]:x64-windows-static</code></li><li><code>capstone[x86]:x86-windows-static</code></li><li><code>keystone:x64-windows-static</code></li><li><code>keystone:x86-windows-static</code></li><li><code>openssl-windows:x64-windows-static</code></li><li><code>openssl-windows:x86-windows-static</code></li><li><code>rapidjson:x64-windows-static</code></li><li><code>rapidjson:x86-windows-static</code></li></ul><p>你可以通过下面的命令来安装它们：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ vcpkg install capstone[x86]:x64-windows-static</span><br><span class="line">$ vcpkg install capstone[x86]:x86-windows-static</span><br><span class="line">$ vcpkg install keystone:x64-windows-static</span><br><span class="line">$ vcpkg install keystone:x86-windows-static</span><br><span class="line">$ vcpkg install openssl-windows:x64-windows-static</span><br><span class="line">$ vcpkg install openssl-windows:x86-windows-static</span><br><span class="line">$ vcpkg install rapidjson:x64-windows-static</span><br><span class="line">$ vcpkg install rapidjson:x86-windows-static</span><br></pre></td></tr></table></figure></li><li><p>你的 <code>vcpkg</code> 已经和你的 <strong>Visual Studio</strong> 集成了，即你曾成功运行了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vcpkg integrate install</span><br></pre></td></tr></table></figure></li></ol><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><ol><li><p>在 <strong>Visual Studio</strong> 打开这个项目。</p></li><li><p>选择 <code>Release</code> 配置。</p></li><li><p>选择 <code>Win32</code> 来生成供32位Navicat使用的keygen/patcher。</p><p>或者选择 <code>x64</code> 来生成供64位Navicat使用的keygen/patcher。</p></li><li><p>选择 <strong>生成 &gt; 生成解决方案</strong>。</p></li></ol><p>生成完成后，你会在 <code>bin/</code> 文件夹下看到编译后的<code>keygen/patcher</code>。</p><h3 id="免编译"><a href="#免编译" class="headerlink" title="免编译"></a>免编译</h3><p>如果你懒得编译，可以下载我编译好的程序，<a href="http://file.onebug.tech/?/%E8%BD%AF%E4%BB%B6%E5%88%86%E4%BA%AB/navicat-keygen-for-x64.zip" target="_blank" rel="noopener">下载地址</a>。</p><h2 id="激活navicat"><a href="#激活navicat" class="headerlink" title="激活navicat"></a>激活navicat</h2><p>在cmd中执行，打开cmd, 进入激活程序的目录，执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">navicat-patcher.exe <span class="string">"C:\Program Files\PremiumSoft\ Premium 15"</span></span><br></pre></td></tr></table></figure><p><code>navicat-patcher.exe</code>是编译生成的激活程序，<code>&quot;C:\Program Files\PremiumSoft\Navicat Premium 15&quot;</code>要替换成自己的Navicat Premium的安装路径 。</p><p>然后执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">navicat-keygen.exe -text .\RegPrivateKey.pem</span><br></pre></td></tr></table></figure><p>输入编号选择你下载的Navicat的具体版本，然后选择语言和版本号。剩下的name和organization随便填写。</p><p>复制激活工具生成的<code>Serial number</code> ，注意先不要关闭cmd窗口。此时断开网络，打开刚刚安装的Navicat，点击注册，把<code>Serial number</code> 粘贴上去。</p><p>再次打开刚刚的cmd窗口，把得到的请求码粘贴上去。按两次回车(产生一个空行)，就会得到一个<code>Activation Code</code>, 把这个码粘贴到需要输入激活码的地方，点击激活即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本教程用于激活windows 版本的navicat-premium。&lt;/p&gt;
    
    </summary>
    
    
      <category term="教程" scheme="http://www.onebug.tech/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="激活工具" scheme="http://www.onebug.tech/tags/%E6%BF%80%E6%B4%BB%E5%B7%A5%E5%85%B7/"/>
    
      <category term="navicat" scheme="http://www.onebug.tech/tags/navicat/"/>
    
      <category term="github" scheme="http://www.onebug.tech/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>github action 部署爬虫脚本</title>
    <link href="http://www.onebug.tech/2020/06/28/github%20action%20%E9%83%A8%E7%BD%B2%E7%88%AC%E8%99%AB%E8%84%9A%E6%9C%AC/"/>
    <id>http://www.onebug.tech/2020/06/28/github%20action%20%E9%83%A8%E7%BD%B2%E7%88%AC%E8%99%AB%E8%84%9A%E6%9C%AC/</id>
    <published>2020-06-27T16:00:00.000Z</published>
    <updated>2020-06-28T13:06:56.205Z</updated>
    
    <content type="html"><![CDATA[<p>很久之前写了一个爬虫脚本，每10分钟获取一次比特币价格，当价格波动较大时，使用邮件通知我进行交易。之前的脚本部署在学校的群晖上，由于会时不时地停电，爬虫脚本运行状态很不稳定，这段时间接触了github action ，感觉正好满足我的需求，于是将爬虫迁移到到GitHub Action上，并弃用原来Python实现的邮件发送功能，改为利用Github Action实现邮件通知。</p><p>项目地址：<a href="https://github.com/lsqls/bitcoin" target="_blank" rel="noopener">https://github.com/lsqls/bitcoin</a></p><a id="more"></a><h2 id="编写爬虫脚本"><a href="#编写爬虫脚本" class="headerlink" title="编写爬虫脚本"></a>编写爬虫脚本</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#https://price.btcfans.com/</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">from</span> jinja2 <span class="keyword">import</span> Environment, PackageLoader</span><br><span class="line">max=<span class="number">10000</span>;min=<span class="number">4000</span></span><br><span class="line"><span class="comment">#获取环境变量中的MAX，MIN值</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">'MAX'</span> <span class="keyword">in</span> os.environ:</span><br><span class="line">    max=float(os.getenv(<span class="string">'MAX'</span>)) </span><br><span class="line"><span class="keyword">if</span> <span class="string">'MIN'</span> <span class="keyword">in</span> os.environ:</span><br><span class="line">    min=float(os.getenv(<span class="string">'MIN'</span>))</span><br><span class="line">sendemail=<span class="literal">False</span>;strategy=<span class="string">"继续持有"</span></span><br><span class="line"><span class="comment">#获取https://price.btcfans.com/上显示的比特币价格</span></span><br><span class="line">url=<span class="string">'https://price.btcfans.com/'</span></span><br><span class="line">html = etree.HTML(requests.get(url).text)</span><br><span class="line">price = float(html.xpath(<span class="string">'//li[@id="coin-bitcoin"]//span[@class="last-price"]/text()'</span>)[<span class="number">0</span>].replace(<span class="string">','</span>,<span class="string">''</span>))</span><br><span class="line"><span class="comment">#根据当前价格选择策略，以及是否发送邮件</span></span><br><span class="line"><span class="keyword">if</span> (price&gt;max):</span><br><span class="line">    sendemail=<span class="literal">True</span></span><br><span class="line">    strategy=<span class="string">"卖出"</span></span><br><span class="line"><span class="keyword">if</span> (price&lt;min):</span><br><span class="line">    sendemail=<span class="literal">True</span></span><br><span class="line">    strategy=<span class="string">"买入"</span></span><br><span class="line"><span class="comment">#使用jinja2渲染HTML用于发送邮件</span></span><br><span class="line">env = Environment(loader=PackageLoader(<span class="string">'bitcoin'</span>, <span class="string">''</span>))</span><br><span class="line">template = env.get_template(<span class="string">'template.html'</span>)</span><br><span class="line">template.stream(price=price,max=max,min=min,strategy=strategy).dump(<span class="string">'email.html'</span>)</span><br><span class="line"><span class="comment">#放弃使用Python脚本发送邮件的方案，使用dawidd6/action-send-mail发送邮件，两者通过环境变量通信</span></span><br><span class="line">print(<span class="string">"::set-env name=sendemail::&#123;&#125;"</span>.format(sendemail))</span><br></pre></td></tr></table></figure><p>脚本非常简单，可以分为以下几步：</p><ul><li><p>读取环境变量中的MAX、MIN值。如果不存在，就使用默认值</p></li><li><p>获取网络上的比特币价格</p></li><li><p>根据当前比特币价格选择策略</p></li><li><p>渲染HTML文件用于发送邮件</p></li><li><p>设置环境变量，邮件发送需要根据这个变量选择是否执行</p><p><img src="http://image.onebug.tech/image-20200628210633551.png-d" alt="image-20200628210633551"></p><center> 输出HTML的部分截图</center></li></ul><h2 id="编写workflow文件"><a href="#编写workflow文件" class="headerlink" title="编写workflow文件"></a>编写workflow文件</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">'bitcoin'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line">  <span class="attr">schedule:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">cron:</span> <span class="string">'*/10 *  * * *'</span> </span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">GetBtcPrice:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">'Checkout codes'</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">'Setup python'</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/setup-python@v1</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">python-version:</span> <span class="string">'3.x'</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">'Install dependencies'</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">python</span> <span class="string">-m</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">--upgrade</span> <span class="string">requests</span> <span class="string">lxml</span> <span class="string">jinja2</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">'run get price script'</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="attr">MAX:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.MAX</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">MIN:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.MIN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">python</span> <span class="string">bitcoin.py</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Send</span> <span class="string">mail</span></span><br><span class="line">      <span class="attr">if:</span> <span class="string">$&#123;&#123;</span> <span class="string">env.sendemail</span> <span class="string">==</span> <span class="string">'True'</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">dawidd6/action-send-mail@v2</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">server_address:</span> <span class="string">smtp.163.com</span></span><br><span class="line">        <span class="attr">server_port:</span> <span class="number">465</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">$&#123;&#123;secrets.MAIL_USERNAME&#125;&#125;</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">$&#123;&#123;secrets.MAIL_PASSWORD&#125;&#125;</span></span><br><span class="line">        <span class="attr">subject:</span> <span class="string">比特币价格监控</span></span><br><span class="line">        <span class="comment"># Literal body:</span></span><br><span class="line">        <span class="attr">body:</span> <span class="string">file://email.html</span></span><br><span class="line">        <span class="attr">to:</span> <span class="string">$&#123;&#123;secrets.TO&#125;&#125;</span></span><br><span class="line">        <span class="attr">from:</span> <span class="string">$&#123;&#123;secrets.MAIL_USERNAME&#125;&#125;</span> <span class="comment"># &lt;user@example.com&gt;</span></span><br><span class="line">        <span class="comment"># Optional content type (defaults to text/plain):</span></span><br><span class="line">        <span class="attr">content_type:</span> <span class="string">text/html</span></span><br></pre></td></tr></table></figure><ul><li><p>脚本每10分钟执行一次，cron的设置语法和Linux下的crontab一致</p></li><li><p>在secrets中设置<code>MAX</code>、<code>MIN</code>、<code>MAIL_USERNAME</code>、<code>MAIL_PASSWORD</code>、<code>TO</code>（接收邮箱地址）以保证脚本的正常运行</p></li><li><p>Fork 的仓库上 GitHub Actions 的定时任务不会自动执行，必须要手动触发一次后才能正常工作，随便改点什么提交就行</p><p><img src="http://image.onebug.tech/image-20200628205024464.png-d" alt="image-20200628205024464"></p></li></ul><h2 id="参考文章与项目"><a href="#参考文章与项目" class="headerlink" title="参考文章与项目"></a>参考文章与项目</h2><blockquote><p><a href="http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html</a></p><p><a href="http://www.ruanyifeng.com/blog/2019/12/github_actions.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2019/12/github_actions.html</a></p><p><a href="https://github.com/Closty/chaoxing/" target="_blank" rel="noopener">https://github.com/Closty/chaoxing/</a></p><p><a href="https://help.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_idif" target="_blank" rel="noopener">https://help.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_idif</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很久之前写了一个爬虫脚本，每10分钟获取一次比特币价格，当价格波动较大时，使用邮件通知我进行交易。之前的脚本部署在学校的群晖上，由于会时不时地停电，爬虫脚本运行状态很不稳定，这段时间接触了github action ，感觉正好满足我的需求，于是将爬虫迁移到到GitHub Action上，并弃用原来Python实现的邮件发送功能，改为利用Github Action实现邮件通知。&lt;/p&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/lsqls/bitcoin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/lsqls/bitcoin&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="爬虫" scheme="http://www.onebug.tech/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="爬虫" scheme="http://www.onebug.tech/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="github action" scheme="http://www.onebug.tech/tags/github-action/"/>
    
  </entry>
  
  <entry>
    <title>Linux备忘录</title>
    <link href="http://www.onebug.tech/2020/06/27/linux%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    <id>http://www.onebug.tech/2020/06/27/linux%E5%A4%87%E5%BF%98%E5%BD%95/</id>
    <published>2020-06-26T16:00:00.000Z</published>
    <updated>2020-06-27T11:49:00.145Z</updated>
    
    <content type="html"><![CDATA[<p>Linux备忘录，记录经常忘记的一些命令以及概念。</p><a id="more"></a><ul><li><code>Ctrl + D</code>  结束键盘输入</li><li><code>man</code>常用的数字代表的指令类型<ul><li><strong>1</strong>用户再shell环境中可以操作的指令和可执行文件</li><li><strong>5</strong>配置文件</li><li><strong>8</strong>系统管理员可以使用的管理指令</li></ul></li><li><code>info</code> 与<code>man</code>类似，但是<code>info</code>将文档分成一个个页面，每个页面可以跳转</li><li><code>/usr/share/doc</code> 存放着软件的一整套说明文件</li><li><code>sync</code>将内存中的文件数据立即同步到磁盘</li><li>磁盘<ul><li>IDE 133MB/s</li><li>SATA SATA-II  300MB/s，SATA-III 600MB/s</li><li>SCSI  </li><li>SAS  6Gb/s</li></ul></li><li>磁盘的文件名，文件名后面序号的确定与系统检测到磁盘的顺序有关，而与磁盘所插入的插槽位置无关<ul><li>IDE磁盘：/dev/hd[a-d]</li><li>SATA/SCSI/SAS  ：/dev/sd[a-p]</li></ul></li><li>MBR<ul><li>主要开机记录占446bytes，分区表占64bytes</li><li>分区表最多存储四个分区分为主分区和扩展分区，扩展分区只有一个</li><li>扩展分区使用其它扇区来记录额外的分区表，从而分出更多逻辑分区</li><li>Linux分区当成文件，分区文件的命名方式为：磁盘文件名+编号，例如/dev/sda1。逻辑分区的编号从5开始</li></ul></li><li>GPT<ul><li>GPT为了兼容所有磁盘，在定义扇区上使用逻辑区块地址（Logic Block Address，LBA），LBA扇区大小通常为512bytes</li><li>GPT第一个区块记录MBR，紧接着33个区块记录分区信息，最后的33个区块用于对分区信息进行备份，33个区块的第一个区块为GPT表头记录，这个部分记录了分区表本身位置与大小和备份分区的位，同时放置了分区表的校验码（CRC32）。</li><li>GPT没有扩展分区的概念，都是主分区，每个LBA可以分为4个分区，因此总共可以分128个分区。</li><li>MBR不支持2.2TN以上的硬盘，GPT则最多支持到8ZB</li></ul></li><li>BIOS不可以读取GPT分区表，UEFI可以读取</li><li>对分区进行格式化就是在分区上建立文件系统，一个分区通常只能格式化一个文件系统，但是磁盘阵列等技术可以将一个分区格式化称为多个文件系统</li><li>文件系统<ul><li>inode ，一个文件占用一个inode，记录文件的属性和文件内容所在的block编号</li><li>block：记录文件的具体内容</li><li>superblock：记录文件系统的整体信息，包括inode和block的总量、使用量、剩余量，文件系统的格式和相关信息</li><li>block bitmap：记录block是否被使用的位图</li></ul></li><li>在Ext2文件系统中所支持的block大小有1K，2K，以及4K三种</li><li>inode组成：权限、拥有者与群组、容量、ctime、mtime、定义文件特性的旗标（flag，如SetUID）、文件真正内容的指向</li><li>每个inode的大小是固定的。为了引用大量的block编号，除了使用直接指向外引入了间接、双间接、三间接引用，这决定了文件系统的最大的单文件大小</li><li>建立目录，系统分配一个inode和至少一个block，block中记录的是该目录下的文件名和inode的对应关系</li><li>文件的inode本身不记录文件名，文件名记录在目录中，因此新增文件、删除文件、更改文件名这些与文件名有关的操作都与目录的写权限相关</li><li>ext3/ext4文件系统引入了日志功能，可以利用日志解决block bitmap与block数据不一致的问题</li><li>linux 最基础的三个目录：<ul><li><code>/root</code> 根目录</li><li><code>/usr</code> （unix software resource）软件默认安装目录</li><li><code>/var</code>  （varible）存放系统或程序运行中的数据文件</li></ul></li><li><code>mtime</code>：文件内容被修改会更新；<code>ctime</code>：文件的状态改变会更新；<code>atime</code>：读文件时会更新</li><li><code>mkdir -p</code> 递归创建目录</li><li><code>umask</code>通过掩码表示设置默认权限，文件默认权限为666，目录默认权限为777。<code>umask 0077</code>，之后创建的目录默认权限为700，文件默认权限是600。</li><li><code>ln</code>实体链接在目录下创建一个条目，记录文件名与inode编号，不能跨越文件系统、不能对目录进行链接</li><li><code>ln -s</code>符号链接保存着源文件所在的绝对路径，可以理解为Windows的快捷方式</li><li><code>head</code>：获取文件前几行；<code>tail</code> 获取文件后几行</li><li><code>whereis</code>：搜寻相关的的可执行文件、源代码文件、帮助文件</li><li><code>locate</code>利用数据库进行搜索，使用<code>updatedb</code>来立即更新数据库</li><li><code>find[basedir] [option]</code><ul><li><code>-mtime n</code> 列出在n天前的那一天修改过内容的文件</li><li><code>-mtime +n</code>列出在n天之前修改过内容的文件</li><li><code>-mtime -n</code> 列出在n天之内修改过内容的文件</li><li><code>-user name</code>；<code>-group name</code>；<code>-nouser</code>；<code>-nogroup</code></li><li><code>-name filename</code></li></ul></li><li><code>gzip</code>、<code>bzip2</code>、<code>xz</code>的压缩比不断优化，不过要注意的是，压缩比越高，压缩的世家就越长</li><li><code>tar</code><ul><li>打包压缩 <code>tar -zvcf filename.tar.gz</code></li><li>查看      <code>tar -ztvf  filename.tar.gz</code></li><li>解压缩   <code>tar -zvxf   filename.tar.gz</code></li></ul></li><li>对一个变量赋值直接使用<code>=</code></li><li>对变量的使用需要早变量前加上<code>$</code>，也可以用<code>${}</code>的形式</li><li>变量内容中如果有空格，必须使用双引号或者单引号，双引号中的特殊字符可以保留原本特性，单引号内的特殊字符就是特殊字符本身</li><li>可以使用`指令`或者${指令}的方式将指令的执行结果赋值给变量</li><li>可以使用<code>export</code>命令将自定义变量转为环境变量，环境变量可以在子程序也就是当前bash产生的子bash中使用</li><li>指令搜索顺序<ul><li>绝对或相对路径</li><li>别名</li><li>Bash内置指令</li><li>$PATH指定的路径搜索找到的第一个指令</li></ul></li><li>数据量重定向<ul><li>标准输入 0  <code>&lt;</code>或<code>&lt;&lt;</code></li><li>标准输出 1 <code>&gt;</code>或<code>&gt;&gt;</code></li><li>标准错误输出 2 <code>2&gt;</code> 或<code>2&gt;&gt;</code></li></ul></li><li><code>2&gt;&amp;1</code>表示将标准错误输出转换为标准输出： <code>find /home -name .bashrrc &gt; list 2&gt;&amp;1</code></li><li><code>cut</code>对数据进行切分，取出想要的部分，切分过程一行一行地进行。取出登入者的用户名：<code>last | cut -d &#39; &#39; -f 1</code></li><li>以<code>/etc/passwd</code>的第三列进行排序：<code>cat /etc/passwd | sort -t &#39;:&#39;  -k 3</code></li><li>取得每个人的登录总次数：<code>last|cut -d  &#39; &#39; -f 1 |sort| uniq -c</code> </li><li><code>awk</code>每次只处理一行，处理的最小单位是字段，每个字段的命令方式为<code>$n</code>，n从1开始，<code>$0</code>表示一整行，具体：<code>awk &#39;条件类型 {动作1} 条件类型 {动作2} ...&#39; filename</code></li><li><code>awk</code>变量：<code>NF</code>（每一行拥有的字段数）；<code>NR</code>（目前所处理的是第几行数据）；<code>FS</code>（目前的分隔字符，默认是空格）  </li><li><code>awk</code>示例：<code>/etc/passwd</code>文件的第三个字段为UID，对UID小于10的数据进行处理：<code>cat /etc/passwd|awk &#39;BEGIN {FS=&quot;:&quot;} $3&lt;10 {print $1 &quot;\t&quot; $3}&#39;</code></li><li><code>pstree -A</code>查看进程树</li><li>查看特定端口的进程：<code>netstat -anp|grep port</code></li><li>一个父进程退出，它的一个或者多个进程还在运行，这些子进程将称为孤儿进程，孤儿进程将会被init进程收养</li><li>如果子进程退出，父进程并没有调用<code>wait()</code>或者<code>waitpid()</code>，那么子进程的进程描述符仍然保存在系统中，这种进程被称之为僵尸进程，僵尸进程有可能对系统造成危害，消灭僵尸进程只需要将其父进程杀死即可。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux备忘录，记录经常忘记的一些命令以及概念。&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://www.onebug.tech/categories/linux/"/>
    
    
      <category term="linux" scheme="http://www.onebug.tech/tags/linux/"/>
    
      <category term="备忘录" scheme="http://www.onebug.tech/tags/%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>顶级域名注册</title>
    <link href="http://www.onebug.tech/2020/06/24/freenom/"/>
    <id>http://www.onebug.tech/2020/06/24/freenom/</id>
    <published>2020-06-23T16:00:00.000Z</published>
    <updated>2020-07-05T02:13:03.809Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，<a href="https://freenom.com/" target="_blank" rel="noopener">Freenom</a>是地球上唯一一个提供免费顶级域名的商家，不过需要每年续期，每次续期最多一年，而管理界面并不是很人性化。下面介绍如何注册一个免费的顶级域名，使用github action 自动续费，以及托管于cloudflare。</p><a id="more"></a><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>注册教程参见<a href="https://zhuanlan.zhihu.com/p/109553641" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/109553641</a>，需要注意的是：</p><ul><li>注册过程中你的ip地址要全程保持不变</li><li>个人信息可以瞎填，但是<strong>国家</strong>信息尽量与你的ip地址相对应</li><li>账号注册成功后，如果在申请顶级域名的过程中出现问题的话，多刷新几次，或者等一天再回来申请，还不成功可以尝试给freenom发封邮件，附上自己的<strong>customer id</strong>（我几乎没遇到问题就是了）</li></ul><h3 id="使用cloudflare管理域名"><a href="#使用cloudflare管理域名" class="headerlink" title="使用cloudflare管理域名"></a>使用<a href="https://www.cloudflare.com/" target="_blank" rel="noopener">cloudflare</a>管理域名</h3><p>直接按照cloudflare的提示进行操作，非常简单，无非就是修改DNS服务器地址。添加域名的时候，如果出现<code>XXX is not a registered domain</code>的错误，要先在freenom管理页面随便添加一条解析记录，然后才能在cloudflare处继续操作。freenom更改DNS服务器一般需要一天时间，这段时间cloudflare上的域名状态会一直显示<code>Pending Nameserver Update</code>，你只需要等待就行。</p><p>如果你只需要域名解析服务，注意添加域名解析时不要点亮小云朵，使用<strong>dns only</strong>就可以了。</p><p><img src="http://image.onebug.tech/image-20200624103558605.png-d" alt="image-20200624103558605"></p><h3 id="使用github-action自动续期"><a href="#使用github-action自动续期" class="headerlink" title="使用github action自动续期"></a>使用<a href="http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html" target="_blank" rel="noopener">github action</a>自动续期</h3><ul><li><p>fork项目<a href="https://github.com/luolongfei/freenom" target="_blank" rel="noopener">https://github.com/luolongfei/freenom</a> </p></li><li><p>查看<a href="https://github.com/lsqls/freenom#--%E6%9C%AC%E9%A1%B9%E7%9B%AE%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">项目使用方法</a></p></li><li><p>设置<strong>Secrets</strong></p></li><li><p>启用github action</p></li></ul><p>附上一张我的<strong>Secrets</strong>截图 ，我是直接把邮件通知关了<code>MAIL_EBABLE=false</code>（如果你需要这个功能，请自行设置）</p><p><img src="http://image.onebug.tech/image-20200624104312825.png-d" alt="image-20200624104312825"></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>免费的就是最贵的，而且还不能保证稳定。我就遇到域名被污染的情况，最后通过重新注册才解决该问题。域名这玩意并不贵，我的建议是嫌麻烦直接去<a href="https://sg.godaddy.com/zh" target="_blank" rel="noopener">godday</a>购买一个首年域名，价格不会超过10RMB。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，&lt;a href=&quot;https://freenom.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Freenom&lt;/a&gt;是地球上唯一一个提供免费顶级域名的商家，不过需要每年续期，每次续期最多一年，而管理界面并不是很人性化。下面介绍如何注册一个免费的顶级域名，使用github action 自动续费，以及托管于cloudflare。&lt;/p&gt;
    
    </summary>
    
    
      <category term="网站" scheme="http://www.onebug.tech/categories/%E7%BD%91%E7%AB%99/"/>
    
    
      <category term="域名" scheme="http://www.onebug.tech/tags/%E5%9F%9F%E5%90%8D/"/>
    
      <category term="cloudflare" scheme="http://www.onebug.tech/tags/cloudflare/"/>
    
  </entry>
  
  <entry>
    <title>腾讯云(DNSPOD)域名DDNS脚本使用</title>
    <link href="http://www.onebug.tech/2020/06/24/%E8%85%BE%E8%AE%AF%E4%BA%91(DNSPOD)%E5%9F%9F%E5%90%8DDDNS%E8%84%9A%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.onebug.tech/2020/06/24/%E8%85%BE%E8%AE%AF%E4%BA%91(DNSPOD)%E5%9F%9F%E5%90%8DDDNS%E8%84%9A%E6%9C%AC%E4%BD%BF%E7%94%A8/</id>
    <published>2020-06-23T16:00:00.000Z</published>
    <updated>2020-08-06T09:42:50.548Z</updated>
    
    <content type="html"><![CDATA[<p>DDNS（Dynamic Domain Name Server，动态域名服务）是将用户的动态IP地址映射到一个固定的域名解析服务上，用户每次连接网络的时候客户端程序就会通过信息传递把该主机的动态IP地址传送给位于服务商主机上的服务器程序，服务器程序负责提供DNS服务并实现动态域名解析。下面是介绍如何使用脚本实现腾讯云购买域名的DDNS。</p><a id="more"></a><h2 id="登录DNSPod获取密钥"><a href="#登录DNSPod获取密钥" class="headerlink" title="登录DNSPod获取密钥"></a>登录DNSPod获取密钥</h2><p>访问DNSPod控制台<a href="https://console.dnspod.cn/" target="_blank" rel="noopener">https://console.dnspod.cn/</a>，使用你的腾讯云账号登录，如果腾讯云账号绑定微信，直接扫码登录就行。在域名管理添加一条A记录。域名前缀需要设定好，IP可以随意填写。我将域名前缀设置为<code>test</code>，ip设置为<code>1.1.1.1</code>。</p><p><img src="http://image.onebug.tech/image-20200624223938388.png-d" alt="image-20200624223938388"></p><p>点击个人头像下的密钥管理，创建一个密钥，将<code>ID</code>和<code>token</code>记下。</p><p><img src="http://image.onebug.tech/image-20200624224951160.png-d" alt="image-20200624224951160"></p><h2 id="设置DDNS脚本"><a href="#设置DDNS脚本" class="headerlink" title="设置DDNS脚本"></a>设置DDNS脚本</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/imki911/ArDNSPod</span><br><span class="line"><span class="built_in">cd</span> ArDNSPod</span><br><span class="line">vi dns.conf</span><br></pre></td></tr></table></figure><p><code>dns.conf</code>设置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. Combine your token ID and token together as follows</span></span><br><span class="line"><span class="comment"># 第一个参数是上图的ID，第二个参数是上图的Token</span></span><br><span class="line">arToken=<span class="string">"123425,b28c3344eaeaea9074c123451234512d"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. Place each domain you want to check as follows</span></span><br><span class="line"><span class="comment"># you can have multiple arDdnsCheck blocks</span></span><br><span class="line"><span class="comment"># 第一个参数是你的域名，第二个参数是前面设定的域名前缀</span></span><br><span class="line">arDdnsCheck <span class="string">"yourdomain.com"</span> <span class="string">"test"</span></span><br></pre></td></tr></table></figure><h2 id="定时运行DDNS脚本"><a href="#定时运行DDNS脚本" class="headerlink" title="定时运行DDNS脚本"></a>定时运行DDNS脚本</h2><p>测试脚本是否能正常运行，<code>./ddnspod.sh</code>，显示以下信息说明脚本正常运行，到DNSPod控制台可以看到前面设置的A记录的IP已经被修改为外网IP。</p><p><img src="http://image.onebug.tech/image-20200624225712024.png-d" alt="image-20200624225712024"></p><p>利用cron半小时执行一次DDNS脚本，注意脚本要使用绝对路径。群晖可以使用自带的定时程序完成该操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br><span class="line">*/30 * * * *   bin/bash /home/bzjz/ArDNSPod/ddnspod.sh</span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>将不支持DDNS的域名服务商下的域名接入DNSPod，同样可以实现DDNS。</p><p><img src="http://image.onebug.tech/image-20200624232552344.png-d" alt="image-20200624232552344"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;DDNS（Dynamic Domain Name Server，动态域名服务）是将用户的动态IP地址映射到一个固定的域名解析服务上，用户每次连接网络的时候客户端程序就会通过信息传递把该主机的动态IP地址传送给位于服务商主机上的服务器程序，服务器程序负责提供DNS服务并实现动态域名解析。下面是介绍如何使用脚本实现腾讯云购买域名的DDNS。&lt;/p&gt;
    
    </summary>
    
    
      <category term="网站" scheme="http://www.onebug.tech/categories/%E7%BD%91%E7%AB%99/"/>
    
    
      <category term="域名" scheme="http://www.onebug.tech/tags/%E5%9F%9F%E5%90%8D/"/>
    
      <category term="ddns" scheme="http://www.onebug.tech/tags/ddns/"/>
    
      <category term="脚本" scheme="http://www.onebug.tech/tags/%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>博客折腾笔记</title>
    <link href="http://www.onebug.tech/2020/06/20/%E5%8D%9A%E5%AE%A2%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.onebug.tech/2020/06/20/%E5%8D%9A%E5%AE%A2%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/</id>
    <published>2020-06-19T16:59:03.839Z</published>
    <updated>2020-10-18T12:37:15.868Z</updated>
    
    <content type="html"><![CDATA[<p>之前有拿Wordpress搭建过博客，感觉还是太臃肿了，Hexo这种静态博客刚好满足我的需求，记录下折腾博客的过程。</p><a id="more"></a><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>在云服务商处购买服务器与域名，备案的时候需要服务器，如果打算将博客托管在对象存储或者github pages之类的平台，可以选择不购买服务器，直接到*宝购买服务号即可。</p><h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><h3 id="Hexo-的安装"><a href="#Hexo-的安装" class="headerlink" title="Hexo 的安装"></a>Hexo 的安装</h3><ul><li>安装<a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">node.js</a></li></ul><blockquote><p>使用 Node.js 官方安装程序时，请确保勾选 <strong>Add to PATH</strong> 选项（默认已勾选）</p></blockquote><ul><li>安装hexo</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo init blog</span><br><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">npm install</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><blockquote><p>如果你觉得速度慢，可以使用阿里提供的<a href="https://developer.aliyun.com/mirror/NPM?from=tnpm" target="_blank" rel="noopener">NPM淘宝镜像</a>，或者<a href="https://stackoverflow.com/questions/7559648/is-there-a-way-to-make-npm-install-the-command-to-work-behind-proxy" target="_blank" rel="noopener">使用代理</a></p></blockquote><ul><li><p>修改配置</p><p>打开<code>_config.yml</code>，修改<code>title</code>、<code>description</code>、<code>author</code>、<code>language</code>、<code>url</code>字段。</p></li></ul><h3 id="安装-next-主题"><a href="#安装-next-主题" class="headerlink" title="安装 next 主题"></a>安装 next 主题</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span>  blog</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><p>在<code>_config.yml</code>中将<code>theme</code>字段值设置为<code>next</code>。</p><h3 id="配置-next-主题（可选）"><a href="#配置-next-主题（可选）" class="headerlink" title="配置 next 主题（可选）"></a>配置 next 主题（可选）</h3><p>配置next主题指的是修改<code>next/_config.yml</code>文件，注意区分。</p><h4 id="选择-Scheme"><a href="#选择-Scheme" class="headerlink" title="选择 Scheme"></a>选择 Scheme</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">scheme:</span> <span class="string">Muse</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br></pre></td></tr></table></figure><h4 id="设置头像"><a href="#设置头像" class="headerlink" title="设置头像"></a>设置头像</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="comment"># Replace the default image and set the url here.</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">http://image.onebug.tech/avatar.png</span></span><br><span class="line">  <span class="comment"># If true, the avatar will be dispalyed in circle.</span></span><br><span class="line">  <span class="attr">rounded:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If true, the avatar will be rotated with the cursor.</span></span><br><span class="line">  <span class="attr">rotated:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="添加标签页"><a href="#添加标签页" class="headerlink" title="添加标签页"></a>添加标签页</h4><ul><li><p>新建标签页</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> your-hexo-site </span><br><span class="line">$ hexo new page tags</span><br></pre></td></tr></table></figure></li><li><p>修改主题配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="添加分类页"><a href="#添加分类页" class="headerlink" title="添加分类页"></a>添加分类页</h4><ul><li><p>新建标签页</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> your-hexo-site </span><br><span class="line">$ hexo new page categories</span><br></pre></td></tr></table></figure></li><li><p>修改主题配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="侧边栏社交链接"><a href="#侧边栏社交链接" class="headerlink" title="侧边栏社交链接"></a>侧边栏社交链接</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">GitHub:</span> <span class="string">https://github.com/lsqls</span> <span class="string">||</span> <span class="string">fab</span> <span class="string">fa-github</span></span><br><span class="line">  <span class="string">邮箱:</span> <span class="string">mailto:764666894@qq.com</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-envelope</span></span><br></pre></td></tr></table></figure><h4 id="设置字体"><a href="#设置字体" class="headerlink" title="设置字体"></a>设置字体</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">font:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 外链字体库地址，例如 //fonts.googleapis.com (默认值)</span></span><br><span class="line">  <span class="attr">host:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 全局字体，应用在 body 元素上</span></span><br><span class="line">  <span class="attr">global:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span> <span class="string">Monda</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 标题字体 (h1, h2, h3, h4, h5, h6)</span></span><br><span class="line">  <span class="attr">headings:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span> <span class="string">Roboto</span> <span class="string">Slab</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 文章字体</span></span><br><span class="line">  <span class="attr">posts:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Logo 字体</span></span><br><span class="line">  <span class="attr">logo:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span> <span class="string">Lobster</span> <span class="string">Two</span></span><br><span class="line">    <span class="attr">size:</span> <span class="number">24</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 代码字体，应用于 code 以及代码块</span></span><br><span class="line">  <span class="attr">codes:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span> <span class="string">PT</span> <span class="string">Mono</span></span><br></pre></td></tr></table></figure><h4 id="设置动画效果"><a href="#设置动画效果" class="headerlink" title="设置动画效果"></a>设置动画效果</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">use_motion:</span> <span class="literal">true</span>  <span class="comment"># 开启动画效果</span></span><br><span class="line"><span class="comment"># use_motion: false # 关闭动画效果</span></span><br></pre></td></tr></table></figure><h4 id="设置页脚"><a href="#设置页脚" class="headerlink" title="设置页脚"></a>设置页脚</h4><ul><li><p>不显示<code>Powered by Hexo &amp; NexT</code>信息</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">powered:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure></li><li><p>添加备案号</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">beian:</span></span><br><span class="line"> <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"> <span class="attr">icp:</span> <span class="string">京ICP备17073808-2</span></span><br></pre></td></tr></table></figure></li><li><p>站点建立时间</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">since:</span> <span class="number">2020</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="设置版权信息"><a href="#设置版权信息" class="headerlink" title="设置版权信息"></a>设置版权信息</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Declare license on posts</span></span><br><span class="line"><span class="attr">post_copyright:</span></span><br><span class="line"> <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"> <span class="attr">license:</span> <span class="string">CC</span> <span class="string">BY-NC-SA</span> <span class="number">3.0</span></span><br><span class="line"> <span class="attr">license_url:</span> <span class="string">https://creativecommons.org/licenses/by-nc-sa/3.0/</span></span><br></pre></td></tr></table></figure><h4 id="加载进度条"><a href="#加载进度条" class="headerlink" title="加载进度条"></a>加载进度条</h4><ul><li><p>安装<code>pace</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/theme-next-pace themes/next/<span class="built_in">source</span>/lib/pace</span><br></pre></td></tr></table></figure></li><li><p>修改配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pace:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Themes list:</span></span><br><span class="line">  <span class="comment"># big-counter | bounce | barber-shop | center-atom | center-circle | center-radar | center-simple</span></span><br><span class="line">  <span class="comment"># corner-indicator | fill-left | flat-top | flash | loading-bar | mac-osx | material | minimal</span></span><br><span class="line">  <span class="attr">theme:</span> <span class="string">minimal</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="显示当前浏览进度"><a href="#显示当前浏览进度" class="headerlink" title="显示当前浏览进度"></a>显示当前浏览进度</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">scrollpercent:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line"> <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="百度统计"><a href="#百度统计" class="headerlink" title="百度统计"></a>百度统计</h4><p>登录 <a href="http://tongji.baidu.com/" target="_blank" rel="noopener">百度统计</a>，定位到站点的代码获取页面，复制 <code>hm.js?</code> 后面那串统计脚本 id，编辑 主题配置文件， 修改字段 <code>baidu_analytics</code>，值设置成你的百度统计脚本 id</p><h4 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h4><p>比较常用的开源项目 CDN 服务商主要有 unpkg、bootcdn、 cdnjs、jsdelivr 和 cloudflare，本站主要使用 jsdelivr 提供的 CDN 加速服务。</p><h2 id="博客部署"><a href="#博客部署" class="headerlink" title="博客部署"></a>博客部署</h2><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><ul><li>git</li><li>nginx</li></ul><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><h4 id="git服务器"><a href="#git服务器" class="headerlink" title="git服务器"></a>git服务器</h4><ul><li><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600/899998870925664" target="_blank" rel="noopener">搭建git服务器</a></p></li><li><p>配置钩子</p><p>在 <code>/home/git/lsqls/public.git/hook</code>  目录下新建一个 <code>post-receive</code> 文件，编辑这个文件，写入如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">git --work-tree=/var/www/hexoblog/public --git-dir=/home/git/lsqls/public.git checkout -f</span><br></pre></td></tr></table></figure><ul><li>设置这个文件的可执行权限：<code>chmod +x post-receive</code></li><li>更改配置目录的权限：<code>chown -R git:git /var/www/hexoblog/public/</code></li><li>注意，<code>/var/www/hexoblog/public</code> 要换成你自己的部署目录</li></ul></li></ul><h4 id="nginx服务器"><a href="#nginx服务器" class="headerlink" title="nginx服务器"></a>nginx服务器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/nginx/conf.d/</span><br><span class="line">vi blog.conf</span><br></pre></td></tr></table></figure><p><code>blog.conf</code>文件配置，开启缓存。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  www.onebug.tech;</span><br><span class="line">        charset utf-8;</span><br><span class="line"></span><br><span class="line">        root   /var/www/hexoblog/public;# 这里是静态文件地址</span><br><span class="line">        index  index.html;</span><br><span class="line">    location ~* ^.+\.(ico|gif|jpg|jpeg|png)$ &#123;</span><br><span class="line"></span><br><span class="line">   access_log off;</span><br><span class="line">    expires 30d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~* ^.+\.(css|js|txt|xml|swf|wav)$ &#123;</span><br><span class="line">access_log off;</span><br><span class="line">expires 24h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~* ^.+\.(html|htm)$ &#123;</span><br><span class="line"> expires 1h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编辑<code>nginx.conf</code>，开启gzip</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">gzip on;</span><br><span class="line"></span><br><span class="line">#设置允许压缩的页面最小字节数;</span><br><span class="line">gzip_min_length 1k;</span><br><span class="line"></span><br><span class="line">#设置压缩缓冲区大小，此处设置为4个16K内存作为压缩结果流缓存</span><br><span class="line">gzip_buffers 4 16k;</span><br><span class="line"></span><br><span class="line">#压缩版本</span><br><span class="line">gzip_http_version 1.1;</span><br><span class="line"></span><br><span class="line">#设置压缩比率，最小为1，处理速度快，传输速度慢；9为最大压缩比，处理速度慢，传输速度快;级别越高，压缩就越小</span><br><span class="line">gzip_comp_level 6;</span><br><span class="line"></span><br><span class="line">#制定压缩的类型</span><br><span class="line">gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/javascript application/json image/svg+xml application/x-font-ttf font/opentype image/x-icon;</span><br><span class="line"></span><br><span class="line">#配置禁用gzip条件，支持正则。此处表示ie6及以下不启用gzip（因为ie低版本不支持）</span><br><span class="line">gzip_disable "MSIE [1-6]\.";</span><br><span class="line"></span><br><span class="line">#选择支持vary header；改选项可以让前端的缓存服务器缓存经过gzip压缩的页面; 这个可以不写</span><br><span class="line">gzip_vary on;</span><br></pre></td></tr></table></figure><h2 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h2><p>图床能够很大程度降低响应延迟，本站使用的是七牛云作为图床。可以参考该<a href="https://www.imczw.com/post/tech/hexo-on-oss-all.html" target="_blank" rel="noopener">文章</a>搭建。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前有拿Wordpress搭建过博客，感觉还是太臃肿了，Hexo这种静态博客刚好满足我的需求，记录下折腾博客的过程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="博客" scheme="http://www.onebug.tech/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="测试" scheme="http://www.onebug.tech/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="博客" scheme="http://www.onebug.tech/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="hexo" scheme="http://www.onebug.tech/tags/hexo/"/>
    
  </entry>
  
</feed>
