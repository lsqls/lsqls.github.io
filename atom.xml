<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>冰冻橘子的自留地</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.onebug.tech/"/>
  <updated>2021-12-01T11:03:00.611Z</updated>
  <id>http://blog.onebug.tech/</id>
  
  <author>
    <name>冰冻橘子</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java并发队列简介</title>
    <link href="http://blog.onebug.tech/2021/12/01/java/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/%E5%B9%B6%E5%8F%91%E9%98%9F%E5%88%97/"/>
    <id>http://blog.onebug.tech/2021/12/01/java/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/%E5%B9%B6%E5%8F%91%E9%98%9F%E5%88%97/</id>
    <published>2021-11-30T16:00:00.000Z</published>
    <updated>2021-12-01T11:03:00.611Z</updated>
    
    <content type="html"><![CDATA[<p>JDK 中提供了一系列场景的并发安全队列。总的来说，按照实现方式的不同可分为阻塞队列和非阻塞队列，前者使用锁实现，而后者则使用CAS 非阻塞算法实现。</p><a id="more"></a><h1 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h1><p><code>ConcurrentLinkedQueue</code> 是线程安全的无界非阻塞队列，其底层数据结构使用单向链表实现，对于入队和出队操作<strong>使用CAS 来实现线程安全</strong>。</p><p><code>ConcurrentLinkedQueue</code> 的底层使用单向链表数据结构来保存队列元素，每个元素被包装成一个Node 节点。队列是靠头、尾节点来维护的，创建队列时头、尾节点指向一个item 为null 的哨兵节点。第一次执行<code>peek</code> 操作时会把head 指向第一个真正的队列元素。由于使用非阻塞CAS 算法，没有加锁，所以在计算size 时有可能进行了<code>offer</code>、 <code>poll</code> 或者<code>remove</code> 操作， 导致<strong>计算的元素个数不精确</strong>，所以在井发情况下<code>size</code> 函数不是很有用。</p><p>如图所示，入队、出队都是操作使用<code>volatile</code> 修饰的<code>tail</code> 、<code>head</code> 节点，要保证在多线程下出入队线程安全，<strong>只需要保证这两个Node 操作的可见性和原子性即可</strong>。由于<code>volatile</code> 本身可以保证可见性，所以只需要保证对两个变量操作的原子性即可。</p><p><img src="http://image.onebug.tech/image-20211201121242572.png" alt="image-20211201121242572"></p><h1 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h1><p><code>LinkedBlockingQueue</code>是使用独占锁实现的阻塞队列。<code>LinkedBlockingQueue</code> 的内部是通过单向链表实现的，使用头、尾节点来进行入队和出队操作，也就是入队操作都是对尾节点进行操作，出队操作都是对头节点进行操作。</p><p>如图所示，<strong>对头、尾节点的操作分别使用了单独的独占锁从而保证了原子性，所以出队和入队操作是可以同时进行的。</strong>另外对头、尾节点的独占锁都配备了一个条件队列，用来存放被阻塞的线程，并结合入队、出队操作实现了一个生产消费模型。</p><p><img src="http://image.onebug.tech/image-20211201121921403.png" alt="image-20211201121921403"></p><h1 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h1><p><code>ArrayBlockingQueue</code>是有界数组方式实现的阻塞队列。</p><p>如图所示， <code>ArrayBlockingQueue</code> 通过<strong>使用全局独占锁实现了同时只能有一个线程进行入队或者出队操作</strong>，这个锁的粒度比较大。</p><p>其中，<code>offer</code>和<code>poll</code> 操作通过简单的加锁进行入队、出队操作，而<code>put</code> 、<code>take</code> 操作则使用条件变量实现，如果队列满则等待，如果队列空则等待，然后分别在出队和入队操作中发送信号激活等待线程实现同步。</p><p>另外，<strong>相比<code>LinkedBlockingQueue</code>，<code>ArrayBlockingQueue</code> 的<code>size</code>操作的结果是精确的</strong>， 因为计算前加了全局锁。</p><p><img src="http://image.onebug.tech/image-20211201122330680.png" alt="image-20211201122330680"></p><h1 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h1><p><code>PriorityBlockingQueue</code> 是带优先级的无界阻塞队列，<strong>每次出队都返回优先级最高或者最低的元素</strong>。其内部是使用<strong>平衡二叉树堆</strong>实现的，所以直接遍历队列元素不保证有序。默认使用对象的<code>compareTo</code> 方法提供比较规则，如果你需要自定义比较规则则可以自定义<code>comparators</code> 。</p><p>PriorityBlockingQueue 队列在内部使用二叉树堆维护元素优先级，使用数组作为元素存储的数据结构，这个数组是可扩容的。当元素个数＞＝最大容量时会通过CAS 算法扩容。</p><p><code>PriorityBlockingQueue</code> 类似于<code>ArrayBlockingQueue</code> ，<strong>在内部使用一个独占锁来控制，同时只有一个线程可以进行入队和出队操作</strong>。另外，<code>PriorityBlockingQueue</code>只使用了一个<code>notEmpty</code> 条件变量而没有使用<code>notFull</code> ，这是因为前者是无界队列。</p><p><img src="http://image.onebug.tech/image-20211201122801247.png" alt="image-20211201122801247"></p><h1 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h1><p><code>DelayQueue</code> 并发队列是一个无界阻塞延迟队列，队列中的每个元素都有个过期时间，<strong>当从队列获取元素时，只有过期元素才会出队列</strong>。队列头元素是最快要过期的元素。</p><p><strong>DelayQueue 内部使用PriorityQueue存放数据</strong>，使用<code>ReentrantLock</code> 实现线程同步。另外，队列里面的<strong>元素要实现<code>Delayed</code> 接口</strong>，由于每个元素都有一个过期时间，所以要实现获知当前元素还剩下多少时间就过期了的接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Delayed</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Delayed</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//获知当前元素还剩下多少时间就过期</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://image.onebug.tech/image-20211201185757443.png" alt="image-20211201185757443"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JDK 中提供了一系列场景的并发安全队列。总的来说，按照实现方式的不同可分为阻塞队列和非阻塞队列，前者使用锁实现，而后者则使用CAS 非阻塞算法实现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://blog.onebug.tech/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://blog.onebug.tech/tags/java/"/>
    
      <category term="并发" scheme="http://blog.onebug.tech/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="笔记" scheme="http://blog.onebug.tech/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java并发编程之美" scheme="http://blog.onebug.tech/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>读多写少的性能考虑--ReentrantReadWriteLock的原理剖析</title>
    <link href="http://blog.onebug.tech/2021/11/27/java/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/%E8%AF%BB%E5%86%99%E9%94%81/"/>
    <id>http://blog.onebug.tech/2021/11/27/java/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/%E8%AF%BB%E5%86%99%E9%94%81/</id>
    <published>2021-11-26T16:00:00.000Z</published>
    <updated>2021-11-27T05:06:57.220Z</updated>
    
    <content type="html"><![CDATA[<p><code>ReentrantLock</code> 是独占锁， 某时只有一个线程可以获取该锁，而实际中会有写少读多的场景，<code>ReentrantReadWriteLock</code> 应运而生。<code>ReentrantReadWriteLock</code> 采用读写分离的策略，允许多个线程可以同时获取读锁。</p><p>读写锁的内部维护了一个<code>ReadLock</code> 和一个<code>WriteLock</code> ，它们依赖Sync 实现具体功能。</p><a id="more"></a><h1 id="state的含义"><a href="#state的含义" class="headerlink" title="state的含义"></a>state的含义</h1><p><code>ReentrantReadWriteLock</code> 需要维护读状态和写状态， 为了用一个state 表示写和读两种状态，<code>ReentrantReadWriteLock</code> 巧妙地使用<code>state</code> 的<strong>高16位表示读状态</strong>，也就是获取到读锁的次数；使用<strong>低16 位表示获取到写锁的线程的可重入次数</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT   = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_UNIT    = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT      = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回以count表示的共享持有的数量[读线程数]</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sharedCount</span><span class="params">(<span class="keyword">int</span> c)</span>    </span>&#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回count中所代表的排他性持有的数量[写锁可重入次数]</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//用来每个线程的读锁可重入数的计数器</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HoldCounter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> tid = getThreadId(Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h1><h2 id="写锁的获取"><a href="#写锁的获取" class="headerlink" title="写锁的获取"></a>写锁的获取</h2><p><strong>写锁是个独占锁</strong>， 某时只有一个线程可以获取该锁。如果当前没有线程获取到读锁和写锁， 则当前线程可以获取到写锁然后返回。如果当前己经有线程获取到读锁和写锁，则当前请求写锁的线程会被阻塞挂起。另外， 写锁是可重入锁，如果当前线程己经获取了该锁，再次获取只是简单地把可重入次数加1后直接返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            sync.acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>其中重写的<code>tryAcquire</code>方法的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line"><span class="comment">//w是写锁线程的可重入次数</span></span><br><span class="line">            <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">            <span class="comment">//c!=0 说明已经有线程获获取了读锁或写锁</span></span><br><span class="line">            <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line">                <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                <span class="comment">// Reentrant acquire</span></span><br><span class="line">                setState(c + acquires);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//第一个写线程获取先锁</span></span><br><span class="line"><span class="comment">//writerShouldBlock()用来实现公平锁和非公平锁的区分</span></span><br><span class="line">            <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">                !compareAndSetState(c, c + acquires))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><code>c</code>是AQS状态变量，<code>w</code>是<code>c</code>的低16位（写状态）。</p><p><code>c!=0&amp;&amp;w==0</code>时说明状态值的的高16位（读状态）不为0，这说明了已经有线程获取了读锁，返回<code>false</code>。</p><p><code>c!=0&amp;&amp;w!=0&amp;&amp;current!= getExclusiveOwnerThread()</code> 则说明当前已经有线程获取了写锁，但是当前线程不是写锁的持有者，返回<code>false</code> 。</p><h2 id="写锁的释放"><a href="#写锁的释放" class="headerlink" title="写锁的释放"></a>写锁的释放</h2><p>如果当前线程持有写锁，调用锁释放方法会让该线程对该线程持有的AQS状态值减1 ，如果减去1后当前状态值为0 则当前线程会释放该锁， 否则仅仅减1而己。其中重写的<code>tryRelease</code>方法如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//看是否是写锁拥有者调用的unlock</span></span><br><span class="line">            <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">   <span class="comment">//获取可重入值， 这里没有考虑高16位， 因为获取写锁时读锁状态值肯定为0</span></span><br><span class="line">            <span class="keyword">int</span> nextc = getState() - releases;</span><br><span class="line">    <span class="comment">//如采写锁可重入值为0 则释放锁，否则只是简单地更新状态值</span></span><br><span class="line">            <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (free)</span><br><span class="line">                setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> free;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h1 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h1><h2 id="读锁的获取"><a href="#读锁的获取" class="headerlink" title="读锁的获取"></a>读锁的获取</h2><p>写锁是共享锁。获取读锁，如果当前<strong>没有其他线程持有写锁</strong>，则当前线程可以获取读锁， AQS 的状态值state 的高16 位的值会增加1 ，然后方法返回。否则如果其他一个线程持有写锁， 则当前线程会被阻塞。共享锁的<code>tryAcquireShared</code>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取当前状态值</span></span><br><span class="line">            Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">//判断是否写锁被占用</span></span><br><span class="line">            <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                getExclusiveOwnerThread() != current)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//获取读锁计数，sharedCount返回c的高16位</span></span><br><span class="line">            <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">   <span class="comment">//更新AQS状态值， 多个读线程只有一个会成功，不成功的进入fullTryAcquireShared进行重试。</span></span><br><span class="line">            <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">                r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">                compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line"><span class="comment">//更新一些记录信息</span></span><br><span class="line">                <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">                    firstReader = current;</span><br><span class="line">                    firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">               </span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                    firstReaderHoldCount++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    HoldCounter rh = cachedHoldCounter;</span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                        cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                        readHolds.set(rh);</span><br><span class="line">                    rh.count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="comment">//fullTryAcquireShared类似tryAcquireShared ，但是是自旋获取</span></span><br><span class="line">            <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>如上代码首先查看是否有其他线程获取到了写锁，如果是则直接返回-1。</p><blockquote><p>如果当前要获取读锁的线程己经持有了写锁， 则也可以获取读锁。但是需要注意，当一个线程先获取了写锁，然后获取了读锁处理事情完毕后，要记得把读锁和写锁都释放掉，不能只释放写锁。</p></blockquote><p>在线程尝试获取读锁前，会进行<code>readerShouldBlock</code>检查，其中非公平锁的<code>readerShouldBlock</code> 实现代码如下，代码的作用是检查队列的第一个元素是否存在以及是不是正在尝试获取写锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> apparentlyFirstQueuedIsExclusive();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">apparentlyFirstQueuedIsExclusive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node h, s;</span><br><span class="line">    <span class="keyword">return</span> (h = head) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        (s = h.next)  != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        <span class="comment">//判断第一个元素是不是独占锁</span></span><br><span class="line">        !s.isShared()         &amp;&amp;</span><br><span class="line">        s.thread != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进行<code>readerShouldBlock</code>检查后，还要检查获取读锁的线程是否达到了最大值，然后才是执行CAS 操作将AQS 状态值的高16 位值增加1。</p><p>更新AQS状态值后，最后还要更新一些重要的变量：</p><ul><li><code>firstReader</code>：用来记录第一个获取到读锁的线程</li><li><code>firstReaderHoldCount</code>：记录第一个获取到读锁的线程获取读锁的可重入次数</li><li><code>cachedHoldCounter</code>：记录最后一个获取读锁的线程获取读锁的可重入次数</li><li><code>readHolds</code>：ThreadLocal 变量， 用来存放除去第一个获取读锁线程外的其他线程获取读锁的可重入次数</li></ul><p><code>fullTryAcquireShared</code>类似<code>tryAcquireShared</code> ，但是是自旋获取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullTryAcquireShared</span><span class="params">(Thread current)</span> </span>&#123;</span><br><span class="line">            HoldCounter rh = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//for循环，自旋获取</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">//..code</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">                 <span class="comment">//..code</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><h2 id="读锁的释放"><a href="#读锁的释放" class="headerlink" title="读锁的释放"></a>读锁的释放</h2><p><code>tryReleaseShared</code>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">            Thread current = Thread.currentThread();</span><br><span class="line">            <span class="comment">//code</span></span><br><span class="line">    <span class="comment">//循环直到自己的读计数-1 , CAS 更新成功</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> c = getState();</span><br><span class="line">                <span class="keyword">int</span> nextc = c - SHARED_UNIT;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                    <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>在无限循环里面，首先获取当前AQS 状态值并将其保存到变量c ，然后变量c被减去一个读计数单位后使用CAS 操作更新AQS 状态值，如果更新成功则<strong>查看当前AQS 状态值是否为0</strong> ，为0则说明当前己经没有读线程占用读锁，则<code>tryReleaseShared</code> 返回true 。然后会调用<code>doReleaseShared</code> 方法<strong>释放一个由于获取写锁而被阻塞的线程</strong>，如果当前AQS 状态值不为0 ，则说明当前还有其他线程持有了读锁，所以<code>trγReleaseShared</code> 返回false 。如果<code>tryReaseShared</code> 中的CAS 更新AQS 状态值失败，则自旋重试直到成功。</p><h1 id="读写锁使用案例"><a href="#读写锁使用案例" class="headerlink" title="读写锁使用案例"></a>读写锁使用案例</h1><p>改造List，使得在读多写少的情况下保持性能和线程安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读多写少</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecureList</span> &lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    线程不安全的List</span></span><br><span class="line">    List&lt;T&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">final</span> ReentrantReadWriteLock reentrantReadWriteLock=<span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">final</span> Lock writeLock=reentrantReadWriteLock.writeLock();</span><br><span class="line">    <span class="keyword">final</span> Lock readLock=reentrantReadWriteLock.readLock();</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> list.get(index);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index,T ele)</span></span>&#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            list.set(index,ele);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            list.remove(index);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="读写锁的改进"><a href="#读写锁的改进" class="headerlink" title="读写锁的改进"></a>读写锁的改进</h1><p><code>StampedLock</code> 是并发包里面JDK8 版本新增的一个锁，该锁提供了三种模式的读写控制，当调用获取锁的系列函数时，会返回一个long 型的变量，我们称之为戳记（ stamp)，这个戳记代表了锁的状态。其中t可系列获取锁的函数，当获取锁失败后会返回为0的stamp 值。当调用释放锁和转换锁的方法时需要传入获取锁时返回的stamp 值。</p><p><code>StampedLock</code> 提供的三种读写模式的锁分别如下：</p><ul><li>写锁<code>writeLock</code> ：独占锁。</li><li>悲观读锁<code>readLock</code> ：悲观是指在具体操作数据前其会悲观地认为其他线程可能要对自己操作的数据进行修改，所以需要先对数据加锁，这是在读少写多的情况下的一种考虑。</li><li>乐观读锁<code>tryOptimisticRead</code>：它是相对于悲观锁来说的，该锁的一个特点是适用于读多写少的场景， 因为获取读锁只是使用位操作进行检验，不涉及CAS 操作，所以效率会高很多，但是同时由于没有使用真正的锁，所以返回的不是最新的数据，但是一致性还是得到保障的。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;ReentrantLock&lt;/code&gt; 是独占锁， 某时只有一个线程可以获取该锁，而实际中会有写少读多的场景，&lt;code&gt;ReentrantReadWriteLock&lt;/code&gt; 应运而生。&lt;code&gt;ReentrantReadWriteLock&lt;/code&gt; 采用读写分离的策略，允许多个线程可以同时获取读锁。&lt;/p&gt;
&lt;p&gt;读写锁的内部维护了一个&lt;code&gt;ReadLock&lt;/code&gt; 和一个&lt;code&gt;WriteLock&lt;/code&gt; ，它们依赖Sync 实现具体功能。&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://blog.onebug.tech/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://blog.onebug.tech/tags/java/"/>
    
      <category term="并发" scheme="http://blog.onebug.tech/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="笔记" scheme="http://blog.onebug.tech/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java并发编程之美" scheme="http://blog.onebug.tech/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>AQS的经典应用--可重入独占锁的原理剖析</title>
    <link href="http://blog.onebug.tech/2021/11/22/java/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/%E7%8B%AC%E5%8D%A0%E9%94%81/"/>
    <id>http://blog.onebug.tech/2021/11/22/java/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/%E7%8B%AC%E5%8D%A0%E9%94%81/</id>
    <published>2021-11-21T16:00:00.000Z</published>
    <updated>2021-11-27T04:51:53.438Z</updated>
    
    <content type="html"><![CDATA[<p><code>ReentrantLock</code> 是可重入的独占锁， 同时只能有一个线程可以获取该锁，其他获取该锁的线程会被阻塞而被放入该锁的<code>AQS</code> 阻塞队列里面。</p><p><code>ReentrantLock</code> 根据参数来决定其内部是一个公平还是非公平锁，默认是非公平锁。其中Sync 类直接继承自AQS ， 它的子类<code>NonfairSync</code> 和<code>FairSync</code> 分别实现了获取锁的非公平与公平策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="state的含义"><a href="#state的含义" class="headerlink" title="state的含义"></a>state的含义</h1><p>在<code>ReentrantLock</code> 中， AQS 的<code>state</code> 状态值表示线程获取<strong>该锁的可重入次数</strong>， 在默认情况下， <code>state</code>的值为0 表示当前锁没有被任何线程持有。当一个线程第一次获取该锁时会尝试使用CAS设置<code>state</code> 的值为1，如果CAS 成功则当前线程获取了该锁，然后记录该锁的持有者为当前线程。在该线程没有释放锁的情况下第二次获取该锁后，状态值被设置为2 ， 这就是可重入次数。在该线程释放该锁时，会尝试使用CAS 让状态值减1 ， 如果减1后状态值为0,则当前线程释放该锁。</p><h1 id="锁的获取"><a href="#锁的获取" class="headerlink" title="锁的获取"></a>锁的获取</h1><p><code>ReentrantLock</code> 的l<code>ock()</code>委托给了<code>sync</code> 类，根据创建<code>ReentrantLock</code> 构造函数选择sync 的实现是<code>NonfairSync</code> 还是<code>FairSync</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="非公平锁的获取"><a href="#非公平锁的获取" class="headerlink" title="非公平锁的获取"></a>非公平锁的获取</h2><p>默认AQS 的状态值为0，所以第一个调用<code>lock</code> 的线程会通过CAS 设置状态值为1, CAS 成功则表示当前线程获取到了锁， 然后<code>setExclusiveOwnerThread</code>设置该锁持有者是当前线程。如果这时候有其他线程调用<code>lock</code>方法企图获取该锁， CAS 会失败，然后会调用AQS的<code>acquire</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//cas设置状态值</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//调用AQS的acquire方法</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AQS 并没有提供可用的<code>tryAcquire</code> 方法， <code>tryAcquire</code> 方法需要子类自己定制化，<code>ReentrantLock</code>需要重写<code>tryAcquire</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">//如果当前AQS状态为0</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//锁的持有锁是当前线程</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow，可重入次数溢出</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>nonfairTryAcquire</code>方法首先会查看当前锁的状态值是否为0 ，为0则说明当前该锁空闲，那么就尝试CAS 获取该锁，将AQS 的状态值从0 设置为1 ，并设置当前锁的持有者为当前线程然后返回 true 。如果当前状态值不为0 则说明该锁已经被某个线程持有，如果当前线程是该锁的持有者，则状态值加1 ，然后返回true 。 如果当前线程不是锁的持有者或者CAS获取锁失败则返回false，然后其会被放入AQS 阻塞队列。</p><p>需要注意的是，线程在CAS 获取锁前，并不会查看当前AQS 队列里面是否有比自己更早请求该锁的线程， 而是使用了抢夺策略，这就是不公平的体现。</p><h2 id="公平锁的获取"><a href="#公平锁的获取" class="headerlink" title="公平锁的获取"></a>公平锁的获取</h2><p>公平锁和非公平锁的获取不同之处在于重写的<code>tryAcquire</code>函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//公平性策略</span></span><br><span class="line">                <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>公平锁和非公平锁的<code>tryAcquire</code> 代码的类似，不同之处在于，<strong>公平锁在设置CAS 获取锁前添加了<code>hasQueuedPredecessors</code> 方法检查当前线程是否有前驱节点</strong>，该方法是实现公平性的核心代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">    <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">    <span class="comment">// thread is first in queue.</span></span><br><span class="line">    Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">    Node h = head;</span><br><span class="line">    <span class="comment">//s为队列的第一个元素</span></span><br><span class="line">    Node s;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line"><span class="comment">// 队列里面的第一个元素不是当前线程的判断：</span></span><br><span class="line">        <span class="comment">// h!=t&amp;&amp;s!=null&amp;&amp;s.thread!= Thread.cunentThread():</span></span><br><span class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果当前线程节点有前驱节点则返回true，否则如果当前AQS 队列为空或者当前线程节点是AQS 的第一个节点则返回false。</p><h1 id="锁的释放"><a href="#锁的释放" class="headerlink" title="锁的释放"></a>锁的释放</h1><p>如果当前线程持有该锁， 则调用该方法会让该线程对该线程持有的AQS状态值减1， 如果减去1 后当前状态值为0 ，则当前线程会释放该锁， 否则仅仅减1而己。同样.<code>ReentrantLock</code> 需要重写<code>tryRelease</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line"><span class="comment">//更新后的可重入次数</span></span><br><span class="line">            <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="comment">//如果当前线程不是锁的持有者，抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//可重入次数变为0，将线程持有者设置为null</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                free = <span class="keyword">true</span>;</span><br><span class="line">                setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="comment">//更新可重入次数</span></span><br><span class="line">            setState(c);</span><br><span class="line">            <span class="keyword">return</span> free;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h1 id="可重入锁使用案例"><a href="#可重入锁使用案例" class="headerlink" title="可重入锁使用案例"></a>可重入锁使用案例</h1><p>下面使用<code>ReentrantLock</code> 来实现一个简单的线程安全的list。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//线程不安全的list</span></span><br><span class="line">    List&lt;T&gt; list  = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//独占锁</span></span><br><span class="line">    <span class="keyword">final</span>  ReentrantLock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">//添加元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(T e)</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            list.add(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">            exception.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            list.remove(index);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">            exception.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取元素</span></span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> list.get(index);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">            exception.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码通过在操作<code>list</code>前进行加锁保证同一时间只有一个线程可以对<code>list</code>数组进行修改，但是也只能有一个线程对<code>list</code>元素进行访问。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;ReentrantLock&lt;/code&gt; 是可重入的独占锁， 同时只能有一个线程可以获取该锁，其他获取该锁的线程会被阻塞而被放入该锁的&lt;code&gt;AQS&lt;/code&gt; 阻塞队列里面。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ReentrantLock&lt;/code&gt; 根据参数来决定其内部是一个公平还是非公平锁，默认是非公平锁。其中Sync 类直接继承自AQS ， 它的子类&lt;code&gt;NonfairSync&lt;/code&gt; 和&lt;code&gt;FairSync&lt;/code&gt; 分别实现了获取锁的非公平与公平策略。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ReentrantLock&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sync = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; NonfairSync();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ReentrantLock&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; fair)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sync = fair ? &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; FairSync() : &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; NonfairSync();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://blog.onebug.tech/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://blog.onebug.tech/tags/java/"/>
    
      <category term="并发" scheme="http://blog.onebug.tech/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="笔记" scheme="http://blog.onebug.tech/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java并发编程之美" scheme="http://blog.onebug.tech/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>Java并发包的基石--抽象同步队列(AQS)</title>
    <link href="http://blog.onebug.tech/2021/10/27/java/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/AQS/"/>
    <id>http://blog.onebug.tech/2021/10/27/java/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/AQS/</id>
    <published>2021-10-26T16:00:00.000Z</published>
    <updated>2021-10-27T12:28:37.727Z</updated>
    
    <content type="html"><![CDATA[<p><code>AbstractQueuedSynchronizer</code> 抽象同步队列简称AQS ，它是实现同步器的基础组件，并发包中锁的底层就是使用AQS 实现的。另外，大多数开发者可能永远不会直接使用AQS ，但是知道其原理对于架构设计还是很有帮助的。</p><a id="more"></a><h1 id="LockSupport-工具类"><a href="#LockSupport-工具类" class="headerlink" title="LockSupport 工具类"></a>LockSupport 工具类</h1><p>在剖析AQS之前，我们先来介绍<code>LockSupport</code>工具类，<code>LockSupport</code> 是使用<code>Unsafe</code> 类实现的，它的主要作用是挂起和唤醒线程，该工具类是创建锁和其他同步类的基础。</p><p><code>LockSupport</code> 类与每个使用它的线程都会关联一个许可证，在默认情况下调用<code>LockSupport</code> 类的方法的线程是不持有许可证的。下面介绍<code>LockSupport</code> 中的几个主要函数：</p><ul><li><p><code>void park()</code>方法：<strong>用于挂起进程</strong>。如果调用<code>park</code> 方法的线程没有拿到了与<code>LockSupport</code> 关联的许可证，调用线程会被禁止参与线程的调度， 也就是会被阻塞挂起。</p></li><li><p><code>void unpark(Thread thread)</code>方法：<strong>用于唤醒进程</strong>。当一个线程调用<code>unpark</code> 时，如果参数thread 线程没有持有thread 与<code>LockSupport</code> 类关联的许可证， 则让thread 线程持有。如果thread 之前因调用<code>park()</code>而被挂起，则调用<code>unpark</code> 后，thread获得许可证，该线程会被唤醒。</p><blockquote><p>可以把许可证不恰当地比成一次性的“免死金牌”，<code>park()</code>的线程消耗”免死金牌”，如果没有”免死金牌“，那么只能”上法场”（线程阻塞挂起）了。<code>unpark(thread)</code>授予thread线程”免死金牌”</p></blockquote></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Thread thread=<span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">"child thread start park"</span>);</span><br><span class="line">    <span class="comment">//调用park ，由于当前线程不持有许可证，挂起自己</span></span><br><span class="line">    LockSupport.park();</span><br><span class="line">    System.out.println(<span class="string">"child thread begin unpark"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">thread.start();</span><br><span class="line"></span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">System.out.println (<span class="string">"main thread begin  unpark"</span>);</span><br><span class="line"><span class="comment">//调用unpark 使得 thread 持有许可证，park方法返回</span></span><br><span class="line">LockSupport.unpark(thread);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用thread的interrupt()方法会得到同样的输出</span></span><br></pre></td></tr></table></figure><p><img src="http://image.onebug.tech/image-20211024211304771.png" alt="image-20211024211304771"></p><h1 id="抽象同步队列AQS"><a href="#抽象同步队列AQS" class="headerlink" title="抽象同步队列AQS"></a>抽象同步队列AQS</h1><p><img src="http://image.onebug.tech/20200603222156602.png" alt="简单理解AQS （ 抽象的队列同步器）_迟到的help的博客-CSDN博客_抽象同步队列器"></p><p>AQS 是一个FIFO 的双向队列，其内部通过节点<code>head</code> 和<code>tail</code> 记录队首和队尾元素。</p><h2 id="节点元素"><a href="#节点元素" class="headerlink" title="节点元素"></a>节点元素</h2><p>我们首先讨论的是队列元素<code>Node</code> 。线程就保存在<code>Node</code>的<code>thread</code> 变量中。<code>Node</code> 的类型分为两种：</p><ul><li><code>SHARED</code> ：线程是获取共享资源时被阻塞挂起后放入AQS 队列</li><li><code>EXCLUSIVE</code>： 线程是获取独占资源时被挂起后放入AQS 队列的。</li></ul><p><code>Node</code>还拥有<code>waitStatus</code>变量，用于记录当前线程等待状态，可以为<code>CANCELLED</code> （线程被取消了）、<code>SIGNAL</code> （ 线程需要被唤醒）、<code>CONDITION</code> （线程在条件队列里面等待〉和<code>PROPAGATE</code> （释放共享资源时需要通知其他节点）。</p><h2 id="状态信息的获取"><a href="#状态信息的获取" class="headerlink" title="状态信息的获取"></a>状态信息的获取</h2><p>AQS 中维持了一个单一的状态信息<code>state</code>，可以通过<code>getState</code> 、<code>setState</code> 、<br><code>compareAndSetState</code> 函数修改其值。对于不同的锁阻塞和同步器，<code>state</code>拥有不同的含义。</p><p>对于AQS 来说，线程同步的关键是对状态值<code>state</code> 进行操作。根据<code>state</code> 是否属于一个线程，操作<code>state</code> 的方式分为<strong>独占方式</strong>和<strong>共享方式</strong>。</p><h3 id="独占方式"><a href="#独占方式" class="headerlink" title="独占方式"></a>独占方式</h3><p>使用独占方式获取的资源是与具体线程绑定的，就是说如果一个线程获取到了资源，就会<strong>标记</strong>是这个线程获取到了，其他线程再尝试操作<code>state</code> 获取资源时会发现当前该资源不是自己持有的，就会在获取失败后被阻塞。</p><p>在独占方式下，获取与释放资源的流程如下：</p><ol><li><p>当一个线程调用<code>acquire(int arg）</code> 方法获取独占资源时，会首先使用<code>tryAcquire</code> 方法尝试获取资源， 具体是设置状态变量<code>state</code> 的值，成功则直接返回，失败则将当前线程封装为类型为<code>Node.EXCLUSIVE</code> 的<code>Node</code> 节点后插入到AQS 阻塞队列的尾部，并调用<code>LockSupport.park(this)</code> 方法挂起自己。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//尝试获取state资源</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        <span class="comment">//获取资源失败则调用addWaiter方法创建节点，加入队列，阻塞挂起</span></span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        </span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当一个线程调用<code>release(int arg）</code>方法时会尝试使用<code>tryRelease</code> 操作释放资源，这里是设置状态变量<code>state</code> 的值，然后调用<code>LockSupport.unpark(thread)</code>方法激活AQS 队列里面被阻塞的一个线程 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置state值</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//唤醒队列中的进程</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>需要注意的是， AQS 类并没有提供可用的<code>tryAcquire</code> 和<code>tryRelease</code> 方法，正如AQS是锁阻塞和同步器的基础框架一样， <code>tryAcquire</code> 和<code>tryRelease</code> 需要由具体的子类来实现。子类在实现<code>tryAcquire</code> 和<code>tryRelease</code> 时要根据具体场景使用CAS 算法尝试修改<code>state</code> 状态值，成功则返回<code>true</code>，否则返回<code>false</code>。子类还需要明确，在调用<code>acquire</code> 和<code>release</code> 方法时<code>state</code>状态值的增减代表什么含义。</p><h3 id="共享方式"><a href="#共享方式" class="headerlink" title="共享方式"></a>共享方式</h3><p>对应共享方式的资源与具体线程是不相关的，当多个线程去请求资源时通过CAS 方式竞争获取资源，当一个线程获取到了资源后，另外一个线程再次去获取时如果当前资源还能满足它的需要，则当前线程只需要使用CAS 方式进行获取即可。</p><p>在共享方式下，获取与释放资源的流程如下：</p><ol><li><p>当线程调用<code>acquireShared(int arg)</code> 获取共享资源时，会首先使用<code>tryAcquireShared</code>操作尝试获取资源，具体是设置状态变量state 的值，成功则直接返回，失败则将当前线程封装为类型为<code>Node.SHARED</code> 的Node 节点后插入到AQS阻塞队列的尾部，并使用<code>LockSupport.park(this)</code> 方法挂起自己。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当一个线程调用<code>releaseShared(int arg）</code>时会尝试使用<code>tryReleaseShared</code> 操作释放资源，这里是设置状态变量<code>state</code> 的值，然后使用<code>LockSupport.unpark(thread)</code>激活AQS 队列里面被阻塞的线程。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AQS 类也没有提供可用的<code>tryAcquireShared</code> 和<code>tryReleaseShared</code>方法， 需要由具体的子类实现。</p><h3 id="中断的忽略"><a href="#中断的忽略" class="headerlink" title="中断的忽略"></a>中断的忽略</h3><p>独占方式下获取资源有两种函数：<code>void acquire(int arg)</code>和<code>void acquireInterruptibly(int arg)</code>，共享方式也是如此。不带<code>Interruptibly</code> 关键字的方法的意思是<strong>不对中断进行响应</strong>，也就是线程在调用方法获取资源时或者获取资源失败被挂起时，其他线程中断了该线程， 那么该线程不会因为被中断而抛出异常，它还是继续获取资源或者被挂起，也就是说不对中断进行响应，忽略中断。</p><h2 id="队列的维护"><a href="#队列的维护" class="headerlink" title="队列的维护"></a>队列的维护</h2><p>队列的维护主要看入队操作，当一个线程获取锁失败后该线程会被转换为Node 节点，然后就会使用<code>enq(final Node node）</code> 方法将该节点插入到AQS 的阻塞队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="comment">//如果队列为空，创建结点，同时被head和tail引用</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="comment">//cas设置尾结点，不成功就一直重试</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://image.onebug.tech/image-20211025162355530.png" alt="image-20211025162355530"></p><h1 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h1><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>和<code>notify</code> 和<code>wait</code> 是配合<code>synchronized</code> 内置锁实现线程间同步的基础设施类似，条件变量的<code>signal</code> 和<code>await</code> 方法是用来配合锁（使用AQS 实现的锁〉实现线程间同步的基础设施。</p><p>它们的不同在于， <code>synchronized</code> 同时只能与一个共享变量的<code>notify</code> 或<code>wait</code> 方法实现同步，<br>而AQS 的一个锁可以对应<strong>多个</strong>条件变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ReentrantLock reentrantLock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">//newCondition()方法返回reentrantLock对应的一个条件变量</span></span><br><span class="line">   <span class="keyword">static</span> Condition condition=reentrantLock.newCondition();</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">//获取独占锁</span></span><br><span class="line">               reentrantLock.lock();</span><br><span class="line">               System.out.println(<span class="string">"begin wait "</span>);</span><br><span class="line">               <span class="comment">//调用条件变量的await()方法阻塞挂起</span></span><br><span class="line">               condition.await();</span><br><span class="line">               System.out.println(<span class="string">"end wait"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">finally</span> &#123;</span><br><span class="line">               reentrantLock.unlock();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;).start();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">//获取独占锁</span></span><br><span class="line">               reentrantLock.lock();</span><br><span class="line">               Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">               System.out.println(<span class="string">"begin signal "</span>);</span><br><span class="line">               condition.signal();</span><br><span class="line">               System.out.println(<span class="string">"end signal"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">finally</span> &#123;</span><br><span class="line">               reentrantLock.unlock();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;).start();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><img src="http://image.onebug.tech/image-20211027192845636.png" alt="image-20211027192845636"></p><p>其实这里的<code>reentrantLock</code>对象等价于<code>synchronized</code> 加上共享变量，调用<code>reentrantLock.lock()</code>方法就相当于进入了<code>synchronized</code> 块（获取了共享变量的内置锁），调用<code>reentrantLock.iunlock()</code>方法就相当于退出<code>synchronized</code> 块。调用条件变量的<code>await()</code>方法就相当于调用共享变量的<code>wait()</code>方法，调用条件变量的<code>signal</code> 方法就相当于调用共享变量的<code>notify()</code>方法。调用条件变量的<code>signalAll()</code>方法就相当于调用共享变量的<code>notifyAll()</code>方法。</p><h2 id="原理剖析"><a href="#原理剖析" class="headerlink" title="原理剖析"></a>原理剖析</h2><p><code>lock.newCondition()</code>的作用其实是new 了一个在AQS 内部声明的<code>ConditionObject</code> 对象， <code>ConditionObject</code> 是AQS 的内部类，可以访问AQS 内部的变量（例如状态变量<code>state</code> ）和方法。在每个条件变量内部都维护了一个条件队列，用来存放调用条件变量的<code>await()</code>方法时被阻塞的线程。注意这个条件队列是单向队列，和AQS 队列不是一回事。</p><p><img src="http://image.onebug.tech/201912222329_295.jpg" alt="浅谈Java中的Condition条件队列，手摸手带你实现一个阻塞队列！ - Java填坑笔记- 博客园"></p><p>当线程调用条件变量的<code>await()</code>方法时（必须先调用锁的<code>lock()</code>方法获取锁），在内部会构造一个类型为<code>Node.CONDITION</code> 的node节点，然后将该节点插入条件队列末尾，之后当前线程会释放获取的锁（ 也就是会操作锁对应的<code>state</code> 变量的值），并被阻塞挂起。这时候如果有其他线程调用<code>lock.lock()</code> 尝试获取锁，就会有一个线程获取到锁，如果获取到锁的线程调用了条件变量的<code>await()</code>方法，则该线程也会被放入条件变量的阻塞队列，然后释放获取到的锁，在<code>await()</code>方法处阻塞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">     <span class="comment">//调用addConditionWaiter方法创建新的node节点，并插入到条件队列末尾</span></span><br><span class="line">         Node node = addConditionWaiter();</span><br><span class="line"><span class="comment">//释放当前锁</span></span><br><span class="line">         <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">         <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//调用park方法阻塞挂起当前线程</span></span><br><span class="line">         <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">             LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">             <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         ...</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           Node t = lastWaiter;</span><br><span class="line">           ...</span><br><span class="line">           <span class="comment">//创建类型为Node.CONDITON的节点</span></span><br><span class="line">           Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//向单向队列尾部插入一个元素</span></span><br><span class="line">           <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">               firstWaiter = node;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               t.nextWaiter = node;</span><br><span class="line">           lastWaiter = node;</span><br><span class="line">           <span class="keyword">return</span> node;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>当另外一个线程调用条件变量的<code>signaL</code>  方法时（ 必须先调用锁的<code>lock()</code> 方法获取锁），在内部会把条件队列里面队头的一个线程节点从条件队列里面移除并放入AQS 的阻塞队列里面， 然后激活这个线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//将队列头元素移动到AQS队列</span></span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;AbstractQueuedSynchronizer&lt;/code&gt; 抽象同步队列简称AQS ，它是实现同步器的基础组件，并发包中锁的底层就是使用AQS 实现的。另外，大多数开发者可能永远不会直接使用AQS ，但是知道其原理对于架构设计还是很有帮助的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://blog.onebug.tech/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://blog.onebug.tech/tags/java/"/>
    
      <category term="并发" scheme="http://blog.onebug.tech/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="笔记" scheme="http://blog.onebug.tech/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java并发编程之美" scheme="http://blog.onebug.tech/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>写时复制与弱一致性--CopyOnWriteArrayList源码剖析</title>
    <link href="http://blog.onebug.tech/2021/10/21/java/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/CopyOnWriteList/"/>
    <id>http://blog.onebug.tech/2021/10/21/java/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/CopyOnWriteList/</id>
    <published>2021-10-20T16:00:00.000Z</published>
    <updated>2021-10-21T13:03:21.676Z</updated>
    
    <content type="html"><![CDATA[<p><code>CopyOnWriteArrayList</code> 是一个线程安全的<code>ArrayList</code> ，对其进行的修改操作都是在底层的一个复制的数组（快照）上进行的，也就是使用了<strong>写时复制</strong>策略。</p><p><img src="http://image.onebug.tech/image-20211021195250084.png" alt="image-20211021195250084"></p><p>在<code>CopyOnWriteArrayList</code> 的类图中，每个<code>CopyOnWriteArrayList</code> 对象里面有一个使用<code>volatile</code>修饰的<code>array</code> 数组对象用来存放具体元素，独占锁<code>lock</code>用来保证同时只有1个线程对<code>array</code>进行修改。</p><a id="more"></a><h2 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h2><p><code>CopyOnWriteArrayList</code> 的写操作需要上锁，下面是<code>add(E e)</code>添加元素的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取独占锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取array</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">       <span class="comment">//复制array到新数组，添加元素到新数组</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        <span class="comment">//使用新数组替换原数组</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//释放独占锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">    array = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>add(E e)</code>操作是通过<code>加锁-复制-添加-覆盖-解锁</code>实现的，保证了线程安全。从代码可以知道，新数组的大小是原来数组大小加一，<code>CopyOnWriteArrayList</code> 是无界数组。</p><p>修改、删除、添加元素的这些写操作的思路都差不多，这里不进行赘述。</p><h2 id="弱一致性的迭代器"><a href="#弱一致性的迭代器" class="headerlink" title="弱一致性的迭代器"></a>弱一致性的迭代器</h2><p>在讨论读操作前，我们先讨论<code>CopyOnWriteArrayList</code> 中的迭代器的弱一致性。弱一致性是指返回迭代器后，其他线程对list 的增删改对迭代器是不可见的。例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">CopyOnWriteArrayList&lt;Integer&gt; copyOnWriteArrayList=</span><br><span class="line">    <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;(Arrays.asList(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">Thread thread=<span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    <span class="comment">//写操作</span></span><br><span class="line">    copyOnWriteArrayList.remove(<span class="number">1</span>);</span><br><span class="line">    copyOnWriteArrayList.set(<span class="number">0</span>,<span class="number">100</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//在写操作前获取迭代器</span></span><br><span class="line">Iterator&lt;Integer&gt; iterator=copyOnWriteArrayList.iterator();</span><br><span class="line"><span class="comment">//启动线程</span></span><br><span class="line">thread.start();</span><br><span class="line"><span class="comment">//等待线程执行完毕</span></span><br><span class="line">thread.join();</span><br><span class="line"><span class="comment">//迭代元素</span></span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://image.onebug.tech/image-20211021205356619.png" alt="image-20211021205356619"></p><p>源码剖析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> COWIterator&lt;E&gt;(getArray(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">COWIterator</span><span class="params">(Object[] elements, <span class="keyword">int</span> initialCursor)</span> </span>&#123;</span><br><span class="line">    cursor = initialCursor;</span><br><span class="line">    snapshot = elements;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (! hasNext())</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> (E) snapshot[cursor++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cursor &lt; snapshot.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用<code>iterator()</code>方法获取迭代器时实际上会返回一个<code>COWiterator</code> 对象， <code>COWiterator</code> 对象的<code>snapshot</code> 变量保存了当前list 的内容， <code>cursor</code> 是遍历list 时数据的下标。</p><p>为什么说snapshot 是list 的快照呢？明明是指针传递的引用啊，而不是副本。如果在该线程使用返回的迭代器代器遍历元素的过程中， 其他线程没有对list 进行增删改，那么snapshot 本身就是list 的array ， 因为它们是引用关系。但是如果在遍历期间其他线程对该list 进行了增删改，那么snapshot 就是快照了，因为增删改后list 里面的数组被新数组替换了，这时候老数组被snapshot引用。这也说明获取迭代器后， 使用该法代器元素时， 其他线程对该list 进行的增删改不可见，<strong>因为它们操作的是两个不同的数组</strong>， 这就是弱一致性。</p><h2 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h2><p><code>CopyOnWriteArrayList</code> 的读操作不会上锁，也就是说，<strong>读操作是允许多个线程进入的</strong>。下面是<code>get(int index)</code>获取元素操作的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在如上代码中， 当线程x 调用<code>get</code> 方法获取指定位置的元素时，分两步走， 首先获取<code>array</code> 数组（这里命名为步骤A ），然后通过下标访问指定位置的元素（这里命名为步骤B ) ，这是两步操作， 但是在整个过程中并没有进行加锁同步。也就是说，假设这时候List 内容如图所示，里面有1、2 、3 三个元素。</p><p><img src="http://image.onebug.tech/image-20211021201352808.png" alt="image-20211021201352808"></p><p>由于执行步骤A 和步骤B 没有加锁，这就可能导致在线程x执行完步骤A 后执行步骤B前， 另外一个线程y进行了<code>remove</code> 操作，假设要线程y要删除元素1， <code>remove</code> 操作首先会获取独占锁， 然后进行写时复制操作，也就是复制一份当前<code>array</code> 数组， 然后在复制的数组里面删除元素1 ，之后让<code>array</code>指向复制的新数组。而这时候<code>array</code>之前指向的数组的引用计数为1而不是0， 因为线程x 还在使用它，这时线程x 开始执行步骤B ，步骤B 操作的数组是线程y 删除元素之前的数组。</p><p><img src="http://image.onebug.tech/image-20211021201430872.png" alt="image-20211021201430872"></p><p>所以，虽然线程y己经删除了<code>index</code>处的元素，但是线程x 的步骤B 还是<strong>有可能</strong>会返回<code>index</code> 处的元素，这其实就是写时复制策略产生的<strong>弱一致性问题</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt; 是一个线程安全的&lt;code&gt;ArrayList&lt;/code&gt; ，对其进行的修改操作都是在底层的一个复制的数组（快照）上进行的，也就是使用了&lt;strong&gt;写时复制&lt;/strong&gt;策略。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://image.onebug.tech/image-20211021195250084.png&quot; alt=&quot;image-20211021195250084&quot;&gt;&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt; 的类图中，每个&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt; 对象里面有一个使用&lt;code&gt;volatile&lt;/code&gt;修饰的&lt;code&gt;array&lt;/code&gt; 数组对象用来存放具体元素，独占锁&lt;code&gt;lock&lt;/code&gt;用来保证同时只有1个线程对&lt;code&gt;array&lt;/code&gt;进行修改。&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://blog.onebug.tech/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://blog.onebug.tech/tags/java/"/>
    
      <category term="并发" scheme="http://blog.onebug.tech/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="笔记" scheme="http://blog.onebug.tech/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java并发编程之美" scheme="http://blog.onebug.tech/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>原子性操作类--高并发下的CAS解决方案</title>
    <link href="http://blog.onebug.tech/2021/10/19/java/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/AtomicLong%E5%92%8CLongAdder/"/>
    <id>http://blog.onebug.tech/2021/10/19/java/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/AtomicLong%E5%92%8CLongAdder/</id>
    <published>2021-10-18T16:00:00.000Z</published>
    <updated>2021-10-21T12:59:09.908Z</updated>
    
    <content type="html"><![CDATA[<p>JUC 包提供了一系列的原子性操作类，这些类都是使用非阻塞算法CAS 实现的，相比使用锁实现原子性操作这在性能上有很大提高。由于原子性操作类的原理都大致相同，所以本文只讲解最简单的<code>AtomicLong</code> 类及JDK 8 中新增的<code>LongAdder</code> 的实现原理。</p><a id="more"></a><h1 id="AtomicLong"><a href="#AtomicLong" class="headerlink" title="AtomicLong"></a>AtomicLong</h1><p>JUC 并发包中包含有<code>Atomiclnteger</code> 、<code>AtomicLong</code> 和<code>AtomicBoolean</code> 等原子性操作类，它们的原理类似。AtomicLong 是原子性递增或者递减类，其内部使用<code>Unsafe</code> 来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicLong</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="comment">//获取Unsafe实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="comment">//存放value的偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取value在AtomicLong的偏移量</span></span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicLong.class.getDeclaredField("value"));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//实际变量值，使用volatile修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment">//调用unsafe方法，原子性设置value值为原始值+1， 返回值为原始值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddLong(<span class="keyword">this</span>, valueOffset, <span class="number">1L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getAndIncrement()</code>、<code>getAndDecrement()</code>等主要数都是通过调用<code>Unsafe</code> 的<code>getAndAddLong</code> 方法来实现操作，其在JDK8中的实现为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getAndAddLong</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">long</span> var4)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> var6;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">//传入对象地址和实际值偏移量，获取实际值</span></span><br><span class="line">            var6 = <span class="keyword">this</span>.getLongVolatile(var1, var2);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//尝试CAS更新实际值，失败则重试</span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapLong(var1, var2, var6, var6 + var4));</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var6;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="LongAdder"><a href="#LongAdder" class="headerlink" title="LongAdder"></a>LongAdder</h1><p><code>AtomicLong</code> 通过CAS 提供了非阻塞的原子性操作，相比使用阻塞算法的同步器来说它的性能己经很好了，但是使用<code>AtomicLong</code> 时，在高并发下大量线程会同时去竞争更新同一个原子变量，但是由于同时只有一个线程的CAS 操作会成功，这就造成了大量线程竞争失败后，会通过无限循环不断进行自旋尝试CAS 的操作， 而这会白白浪费CPU 资源。JDK 8 新增了一个原子性递增或者递减类<code>LongAdder</code> 用来克服在高并发下使用<code>AtomicLong</code> 的缺点。</p><p>既然<code>AtomicLong</code> 的性能瓶颈是由于过多线程同时去竞争一个变量的更新而产生的，那么可以把一个变量分解为多个变量，让同样多的线程去竞争多个资源，从而解决性能问题，这就是<code>LongAdder</code>设计的思路。</p><p><img src="http://image.onebug.tech/LongAddr-CAS.png" alt="Java AtomicLong 和LongAdder | A Big Boy Blog - Tech Articls &amp; Notes"></p><p><code>LongAdder</code> 在内部维护多个<code>Cell</code> 变量，<code>Cell</code> 类型是<code>AtomicLong</code>的一个改进。这样，在同等并发量的情况下，争夺单个变量更新操作的线程量会减少，这变相地减少了争夺共享资源的并发量。另外，多个线程在争夺同一个<code>Cell</code> 原子变量时如果失败了， 它并不是在当前<code>Cell</code> 变量上一直自旋CAS 重试，而是尝试在其他<code>Cell</code>的变量上进行CAS 尝试，这个改变增加了当前线程重试CAS 成功的可能性。</p><p>最后，在获取<code>LongAdder</code>当前值时， 是把所有<code>Cell</code> 变量的value值累加后再加上<code>base</code>返回的。</p><p>由于<code>Cells</code> 占用的内存是相对比较大的，所以一开始并不创建它，而是在需要时创建，也就是惰性加载。<code>LongAdder</code> 维护了一个延迟初始化的原子性更新数组（默认情况下<code>Cell</code> 数组是<code>null</code>）和一个基值变量<code>base</code> 。</p><p><img src="http://image.onebug.tech/image-20211019171832480.png" alt="image-20211019171832480"></p><p> <code>LongAdder</code> 类内部维护着三个变量。获取<code>LongAdder</code> 的真实值时，得到的其实是<code>base</code> 的值与<code>cells</code> 数组里面所有<code>Cell</code> 元素中的<code>value</code> 值的累加，<code>base</code> 是个基础值，默认为0 。<code>cellsBusy</code> 用来实现自旋锁，状态值只有0 和1，使用CAS操作<code>cellsBusy</code> 来保证同时只有一个线程可以进行创建<code>Cell</code> 元素、扩容<code>cells</code> 数组、初始化<code>cells</code> 数组这些操作。</p><p><code>LongAdder</code> 类的主要函数有：</p><ul><li><code>long sum()</code>：返回当前的值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Cell[] as = cells; Cell a;</span><br><span class="line">   <span class="comment">//bash值加上所有Cell内部的value值后就是当前值</span></span><br><span class="line">       <span class="keyword">long</span> sum = base;</span><br><span class="line">       <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">               <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                   sum += a.value;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> sum;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>要注意的是，由于计算总和时没有对<code>cells</code>数组进行加锁，所以在累加过程中可能有其他线程对<code>Cell</code> 中的值进行了修改， 也有可能对数组进行了扩容，所以<code>sum</code>返回的值并不是非常精确的， 其返回值并不是一个调用<code>sum</code> 方法时的原子快照值。</p><ul><li><code>add(long x)</code>：增加给定值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">    Cell[] as; <span class="keyword">long</span> b, v; <span class="keyword">int</span> m; Cell a;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//cell是否为null，是的话就在基础变量base上累加</span></span><br><span class="line">    <span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> || !casBase(b = base, b + x)) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;  </span><br><span class="line">        <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            决定当前线程应该访问cells 数组里面的哪一个Cell元素</span></span><br><span class="line"><span class="comment">            其中m 是当前cells数组元素个数－1 , getProbe()获取的是当前线程中变量threadLocalRandomProbe的值</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            (a = as[getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//用CAS操作去更新分配到的Cell元素的value 值</span></span><br><span class="line">            !(uncontended = a.cas(v = a.value, v + x)))</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//初始化或扩容cells数组</span></span><br><span class="line">            longAccumulate(x, <span class="keyword">null</span>, uncontended);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>longAccumulate</code>源码解析： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">longAccumulate</span><span class="params">(<span class="keyword">long</span> x, LongBinaryOperator fn,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> wasUncontended)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    初始化当前线程的变量threadLocalRandomProbe的值，</span></span><br><span class="line"><span class="comment">    这个变量在计算当前线程应该被分配到cells数组的哪一个Cell 元素时会用到。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">     <span class="keyword">if</span> ((h = getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">         ThreadLocalRandom.current(); <span class="comment">// force initialization</span></span><br><span class="line">         h = getProbe();</span><br><span class="line">         wasUncontended = <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   </span><br><span class="line">     <span class="keyword">boolean</span> collide = <span class="keyword">false</span>;                <span class="comment">// True if last slot nonempty</span></span><br><span class="line">     <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">         Cell[] as; Cell a; <span class="keyword">int</span> n; <span class="keyword">long</span> v;</span><br><span class="line">         <span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">             </span><br><span class="line">             <span class="comment">//当前线程计算要访问的Cell元素下标，然后如果发现对应下标元素的值为null</span></span><br><span class="line">             <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                 <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;       <span class="comment">// Try to attach new Cell</span></span><br><span class="line">                     <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     新增一个Cell 元素到cell 数组，</span></span><br><span class="line"><span class="comment">                     并且在将其添加到cells 数组之前要竞争设置cellsBusy 为1</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                     Cell r = <span class="keyword">new</span> Cell(x);   <span class="comment">// Optimistically create</span></span><br><span class="line"></span><br><span class="line">                     <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                         <span class="keyword">boolean</span> created = <span class="keyword">false</span>;</span><br><span class="line">                         <span class="keyword">try</span> &#123;               <span class="comment">// Recheck under lock</span></span><br><span class="line">                             Cell[] rs; <span class="keyword">int</span> m, j;</span><br><span class="line">                             <span class="keyword">if</span> ((rs = cells) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                                 (m = rs.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                                 rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                 rs[j] = r;</span><br><span class="line">                                 created = <span class="keyword">true</span>;</span><br><span class="line">                             &#125;</span><br><span class="line">                         &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                             cellsBusy = <span class="number">0</span>;</span><br><span class="line">                         &#125;</span><br><span class="line">                         <span class="keyword">if</span> (created)</span><br><span class="line">                             <span class="keyword">break</span>;</span><br><span class="line">                         <span class="keyword">continue</span>;           <span class="comment">// Slot is now non-empty</span></span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">                 collide = <span class="keyword">false</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)       <span class="comment">// CAS already known to fail</span></span><br><span class="line">                 wasUncontended = <span class="keyword">true</span>;      <span class="comment">// Continue after rehash</span></span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (a.cas(v = a.value, ((fn == <span class="keyword">null</span>) ? v + x :</span><br><span class="line">                                          fn.applyAsLong(v, x))))</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= NCPU || cells != as)</span><br><span class="line">                 collide = <span class="keyword">false</span>;            <span class="comment">// At max size or stale</span></span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">                 collide = <span class="keyword">true</span>;</span><br><span class="line">             </span><br><span class="line">             <span class="comment">/*</span></span><br><span class="line"><span class="comment">             下面数组是扩容cells数组的代码，扩容条件的前提具体就是</span></span><br><span class="line"><span class="comment">             当前cells 的元素个数小于当前机器CPU个数</span></span><br><span class="line"><span class="comment">             并且当前多个线程访问了cells中同一个元素从而导致冲突使其中一个线程CAS失败。</span></span><br><span class="line"><span class="comment">             和初始化一样，需要cas设置cellsBusy值，保证cells数组的互斥访问。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                 <span class="keyword">try</span> &#123;</span><br><span class="line">                     <span class="keyword">if</span> (cells == as) &#123;      <span class="comment">// Expand table unless stale</span></span><br><span class="line">                         <span class="comment">//扩容为原来的两倍</span></span><br><span class="line">                         Cell[] rs = <span class="keyword">new</span> Cell[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                         <span class="comment">//将旧的cells数组复制新的cells数组</span></span><br><span class="line">                         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                             rs[i] = as[i];</span><br><span class="line">                         cells = rs;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                     cellsBusy = <span class="number">0</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">                 collide = <span class="keyword">false</span>;</span><br><span class="line">                 <span class="keyword">continue</span>;                   <span class="comment">// Retry with expanded table</span></span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">/*CAS 失败的线程重新计算当前线程的随机值threadLocalRandomProbe,</span></span><br><span class="line"><span class="comment">             以减少下次访问cells元素时的冲突机会*/</span></span><br><span class="line">             h = advanceProbe(h);</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">         <span class="comment">//下面是初始化cells数组的代码</span></span><br><span class="line">         </span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">         cellsBusy 是一个状态标识，</span></span><br><span class="line"><span class="comment">         为0说明当前cells 数组没有在被初始化或者扩容，也没有在新建Cell元素，</span></span><br><span class="line"><span class="comment">         当前线程通过casCellsBusy()设置cellsBusy 为l ，</span></span><br><span class="line"><span class="comment">         则当前线程在初始化cells数组时，其他线程就不能进行对cells数组进行初始化。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">             <span class="keyword">boolean</span> init = <span class="keyword">false</span>;</span><br><span class="line">             <span class="keyword">try</span> &#123;                           <span class="comment">// Initialize table</span></span><br><span class="line">                 <span class="keyword">if</span> (cells == as) &#123;</span><br><span class="line">                     <span class="comment">//初始化cells 数组元素个数为2</span></span><br><span class="line">                     Cell[] rs = <span class="keyword">new</span> Cell[<span class="number">2</span>];</span><br><span class="line">                     <span class="comment">//使用h&amp;1计算当前线程应该访问celll 数组的哪个位置</span></span><br><span class="line">                     rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> Cell(x);</span><br><span class="line">                     cells = rs;</span><br><span class="line">                     <span class="comment">//标识cells 数组已经被初始化</span></span><br><span class="line">                     init = <span class="keyword">true</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                 <span class="comment">/*重置了cellsBusy 标记。这里没有使用CAS 操作，却是线程安全的，</span></span><br><span class="line"><span class="comment">                 原因是cellsBusy 是volatile类型的，这保证了变量的内存可见性，</span></span><br><span class="line"><span class="comment">                 另外此时其他地方的代码没有机会修改cellsBusy的值*/</span></span><br><span class="line">                 cellsBusy = <span class="number">0</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (init)</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (casBase(v = base, ((fn == <span class="keyword">null</span>) ? v + x :</span><br><span class="line">                                     fn.applyAsLong(v, x))))</span><br><span class="line">             <span class="keyword">break</span>;                          <span class="comment">// Fall back on using base</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>阅读上面的源码后，我们基本可以回答以下几个重要问题：</p><ul><li><p>LongAdder 的结构是怎样的</p><p><code>base</code>基值变量，<code>cells</code>数组，<code>cellsBusy</code>标识</p></li><li><p>当前线程应该访问<code>cells</code>数组里面的哪一个<code>Cell</code> 元素</p><p>元素下标通过<code>cells</code>数组长度对<code>threadLocalRandomProbe</code>取模计算得到，<code>threadLocalRandomProbe</code>可以看成是<code>ThreadLocal</code>类型的变量，只与当前线程相关。</p></li><li><p>如何初始化<code>cells</code>数组？ 略</p></li><li><p><code>cells</code>数组如何扩容？略</p></li><li><p>线程访问分配的Cell 元素有冲突后如何处理：扩容（需要满足<code>cells</code> 数组元素个数小于CPU核心数），并重新计算当前线程的<code>threadLocalRandomProbe</code>，减小冲突概率</p></li><li><p>如何保证线程操作被分配的<code>Cell</code> 元素的原子性：CAS操作</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JUC 包提供了一系列的原子性操作类，这些类都是使用非阻塞算法CAS 实现的，相比使用锁实现原子性操作这在性能上有很大提高。由于原子性操作类的原理都大致相同，所以本文只讲解最简单的&lt;code&gt;AtomicLong&lt;/code&gt; 类及JDK 8 中新增的&lt;code&gt;LongAdder&lt;/code&gt; 的实现原理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://blog.onebug.tech/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://blog.onebug.tech/tags/java/"/>
    
      <category term="并发" scheme="http://blog.onebug.tech/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="笔记" scheme="http://blog.onebug.tech/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java并发编程之美" scheme="http://blog.onebug.tech/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>高并发下随机数的获取--ThreadlocalRandom</title>
    <link href="http://blog.onebug.tech/2021/10/16/java/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/ThreadLocal%20Random/"/>
    <id>http://blog.onebug.tech/2021/10/16/java/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/ThreadLocal%20Random/</id>
    <published>2021-10-15T16:00:00.000Z</published>
    <updated>2021-10-21T12:59:48.497Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Random类的局限性"><a href="#Random类的局限性" class="headerlink" title="Random类的局限性"></a>Random类的局限性</h1><p>每个Random 实例里面都有一个原子性的种子变量用来记录当前的种子值，当要生成新的随机数时需要根据当前种子计算新的种子并更新回原子变量。在多线程下使用单个Random 实例生成随机数时，当多个线程同时计算随机数来计算新的种子时，多个线程会竞争同一个原子变量的更新操作，由于原子变量的更新是CAS 操作，同时只有一个线程会成功，所以会造成大量线程进行自旋重试， 这会降低并发性能，所以<code>ThreadLocalRandom</code> 应运而生。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Random类的核心方法，CAS操作会导致高竞用情况下的性能下降</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> bits)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">long</span> oldseed, nextseed;</span><br><span class="line">       AtomicLong seed = <span class="keyword">this</span>.seed;</span><br><span class="line">       <span class="keyword">do</span> &#123;</span><br><span class="line">           oldseed = seed.get();</span><br><span class="line">           nextseed = (oldseed * multiplier + addend) &amp; mask;</span><br><span class="line">       &#125; <span class="keyword">while</span> (!seed.compareAndSet(oldseed, nextseed));</span><br><span class="line">       <span class="keyword">return</span> (<span class="keyword">int</span>)(nextseed &gt;&gt;&gt; (<span class="number">48</span> - bits));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="ThreadlocalRandom"><a href="#ThreadlocalRandom" class="headerlink" title="ThreadlocalRandom"></a>ThreadlocalRandom</h1><p>为了弥补多线程高并发情况下Random 的缺陷， <code>ThreadLocalRandom</code>类应运而生。<code>ThreadLocalRandom</code> 使用<code>ThreadLocal</code>的原理，让每个线程都持有一个本地的种子变量，该种子变量只有在使用随机数时才会被初始化。在多线程下计算新种子时是根据自己线程内维护的种子变量进行更新，从而避免了竞争。<br><code>ThreadLocalRandom</code> 类似于<code>ThreadLocal</code> 类，就是个工具类。当线程调用<code>ThreadLocalRandom</code> 的<code>current</code>方法时， <code>ThreadLocalRandom</code> 负责初始化调用线程的<code>threadLocalRandomSeed</code> 变量， 也就是初始化种子。<br>当调用<code>ThreadLocalRandom</code> 的<code>nextlnt</code> 方法时，实际上是获取当前线程的<code>threadLocalRandomSeed</code> 变量作为当前种子来计算新的种子，然后更新新的种子到当前线程的<code>threadLocalRandomSeed</code> 变量，而后再根据新种子并使用具体算法计算随机数。</p><blockquote><p><code>threadLocalRandomSeed</code> 变量是Thread 类里面的一个普通long 变量</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//ThreadLocalRandom类的核心代码</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">nextSeed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Thread t; <span class="keyword">long</span> r; <span class="comment">// read and update per-thread seed</span></span><br><span class="line">       UNSAFE.putLong(t = Thread.currentThread(), SEED,</span><br><span class="line">                      r = UNSAFE.getLong(t, SEED) + GAMMA);</span><br><span class="line">       <span class="keyword">return</span> r;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><img src="http://image.onebug.tech/image-20211016224505557.png" alt="image-20211016224505557"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Random类的局限性&quot;&gt;&lt;a href=&quot;#Random类的局限性&quot; class=&quot;headerlink&quot; title=&quot;Random类的局限性&quot;&gt;&lt;/a&gt;Random类的局限性&lt;/h1&gt;&lt;p&gt;每个Random 实例里面都有一个原子性的种子变量用来记录当前的种子值，当要生成新的随机数时需要根据当前种子计算新的种子并更新回原子变量。在多线程下使用单个Random 实例生成随机数时，当多个线程同时计算随机数来计算新的种子时，多个线程会竞争同一个原子变量的更新操作，由于原子变量的更新是CAS 操作，同时只有一个线程会成功，所以会造成大量线程进行自旋重试， 这会降低并发性能，所以&lt;code&gt;ThreadLocalRandom&lt;/code&gt; 应运而生。&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://blog.onebug.tech/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://blog.onebug.tech/tags/java/"/>
    
      <category term="并发" scheme="http://blog.onebug.tech/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="笔记" scheme="http://blog.onebug.tech/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java并发编程之美" scheme="http://blog.onebug.tech/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>java多线程编程基础（二）</title>
    <link href="http://blog.onebug.tech/2021/10/15/java/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://blog.onebug.tech/2021/10/15/java/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2021-10-14T16:00:00.000Z</published>
    <updated>2021-10-16T14:49:54.343Z</updated>
    
    <content type="html"><![CDATA[<h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><p><code>synchronized块</code>是Java 提供的一种原子性内置锁， <code>Java</code> 中的每个对象都可以把它当作一个同步锁来使用， 这些Java 内置的使用者看不到的锁被称为内部锁，也叫作监视器锁。<code>synchronized</code> 关键字底层原理属于 JVM 层面。线程的执行代码在进入<code>synchronized</code> 代码块前会自动获取内部锁，这时候其他线程访问该同步代码块时会被阻塞挂起。拿到内部锁的线程会在正常退出同步代码块或者抛出异常后或者在同步块内调用了该内置锁资源的<code>wait</code> 系列方法时释放该内置锁。内置锁是排它锁，也就是当一个线程获取这个锁后， 其他线程必须等待该线程释放锁后才能获取该锁。</p><a id="more"></a><p>由于Java 中的线程是与操作系统的原生线程一一对应的，所以当阻塞一个线程时，需要从用户态切换到内核态执行阻塞操作，这是很耗时的操作，而<code>synchronized</code>的使用就会导致上下文切换。</p><blockquote><p>庆幸的是，JDK1.6 对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销，所以现在的 <code>synchronized</code> 锁效率也很不错了。</p></blockquote><p><code>synchronized</code> 同时具有内存语义，这个内存语义可以解决共享变量内存可见性问题。进入<code>synchronized</code> 块的内存语义是把在<code>synchronized</code> 块内使用到的变量从线程的工作内存中清除，这样在<code>synchronized</code> 块内使用到该变量时就不会从线程的工作内存中获取，而是<strong>直接从主内存中获取</strong>。退出<code>synchronized</code> 块的内存语义是把在<code>synchronized</code> 块内对共享变量的修改刷新到主内存。</p><h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><p>使用锁的方式可以解决共享变量内存可见性问题，但是使用锁太笨重，因为它会带来线程上下文的切换开销。对于解决内存可见性问题， Java 还提供了一种弱形式的同步，也就是使用<code>volatile</code> 关键字。该关键字可以确保对一个变量的更新对其他线程马上可见。当一个变量被声明为<code>volatile</code> 时，线程在<strong>写入变量</strong>时不会把值缓存在寄存器或者其他地方，而是会把值<strong>刷新回主内存</strong>。当其他线程<strong>读取该共享变量</strong>时，会<strong>从主内存重新获取</strong>最新值，而不是使用当前线程的工作内存中的值。<code>volatile</code> 的内存语义和<code>synchronized</code> 的内存语义有相似之处，具体来说就是，当线程写入了<code>volatile</code> 变量值时就等价于线程退出<code>synchronized</code> 同步块（把写入工作内存的变量值同步到主内存），读取<code>volatile</code> 变量值时就相当于进入同步块（ 先清空本地内存变量值，再从主内存获取最新值）。</p><p><code>volatile</code> 只能保证共享变量的可见性，不能解决<code>读—改一写</code>等的原子性问题。下例中，<code>cnt</code>变量已经使用<code>volatile</code> 修饰，最终结果却不正确。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Unsafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCount</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="comment">//线程不安全</span></span><br><span class="line">        Thread[] threads=<span class="keyword">new</span> Thread[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;threads.length;i++)&#123;</span><br><span class="line">            threads[i]=<span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">10000</span>;j++)&#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"cnt:"</span>+cnt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://image.onebug.tech/image-20211015202422807.png" alt=""></p><p>一般来说，volatile适合状态验证，不适合累加值，在修饰状态标记量时，要保证对：</p><ul><li>变量的写操作不依赖于当前值</li><li>该变量没有包含在具有其他变量的式子中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//volatile经典用法</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> asleep</span><br><span class="line">...</span><br><span class="line"><span class="keyword">while</span>(!asleep)&#123;</span><br><span class="line"><span class="comment">//do some work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><p>在Java 中， 锁在并发处理中占据了一席之地，但是使用锁有一个不好的地方，就是当一个线程没有获取到锁时会被阻塞挂起， 这会导致线程上下文的切换和重新调度开销。Java 提供了非阻塞的<code>volatile</code> 关键字来解决共享变量的可见性问题， 这在一定程度上弥补了锁带来的开销问题，但是volatile 只能保证共享变量的可见性，不能解决<code>读—改一写</code>等的原子性问题。CAS 即Compare and Swap ，其是JDK 提供的非阻塞原子性操作， 它通过硬件保证了比较更新操作的原子性。JDK 里面的Unsafe 类提供了一系列的<code>compareAndSwap*</code>方法，例如:</p><ul><li><code>boolean compareAndSwapLong(Object obj ,long valueOffset,long expect, long update）</code>方<br>法： 其中<code>compareAndSwap</code> 的意思是比较并交换。CAS 有四个操作数， 分别为： 对象内存位置、对象中的变量的偏移量、变量预期值和新的值。其操作含义是， 如果对象<code>obj</code> 中内存偏移量为<code>valueOffset</code> 的变量值为<code>expect</code> ，则使用新的值<code>update</code> 替换旧的值<code>expect</code> 。这是处理器提供的一个原子性指令。</li></ul><h1 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h1><p>JDK 的<code>rt.jar</code>包中的<code>Unsafe</code> 类提供了硬件级别的原子性操作， <code>Unsafe</code> 类中的方法都是<code>native</code> 方法，它们使用JNI的方式访问本地C++实现，除了上文提到的<code>compareAndSwap*</code>方法，其中还有几个重要的方法：</p><ul><li><code>long objectFieldOffset(Field field）</code> 方法： 返回指定的变量在所属类中的内存偏移地址，该偏移地址仅仅在该Unsafe 函数中访问指定宇段时使用。</li><li><code>void park(boolean isAbsolute, long time）</code> 方法： 阻塞当前线程</li><li><code>void unpark(Object thread）</code> 方法：唤醒调用<code>park</code>后阻塞的线程。</li></ul><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h2><ul><li><p>悲观锁指对数据被外界修改持保守态度，认为数据很容易就会被其他线程修改，所以在数据被处理前先对数据进行加锁，并在整个数据处理过程中，使数据处于锁定状态。悲观锁的实现往往依靠数据库提供的锁机制，即在数据库中，在对数据记录操作前给记录加排它锁。如果获取锁失败， 则说明数据正在被其他线程修改， 当前线程则等待或者抛出异常。如果获取锁成功，则对记录进行操作，然后提交事务后释放排它锁。</p></li><li><p>乐观锁是相对悲观锁来说的，它认为数据在一般情况下不会造成冲突，所以在访问记录前不会加排它锁，而是在进行数据提交更新时，才会正式对数据冲突与否进行检测。</p></li></ul><h2 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h2><p>根据线程获取锁的抢占机制，锁可以分为公平锁和非公平锁：</p><ul><li>公平锁表示线程获取锁的顺序是按照线程请求锁的时间早晚来决定的，也就是最早请求锁的线程将最早获取到锁。</li><li>非公平锁可以在运行时闯入，也就是先来不一定先得。</li></ul><h2 id="独占锁和共享锁"><a href="#独占锁和共享锁" class="headerlink" title="独占锁和共享锁"></a>独占锁和共享锁</h2><p>根据锁只能被单个线程持有还是能被多个线程共同持有，锁可以分为独占锁和共享锁：</p><ul><li>独占锁保证任何时候都只有一个线程能得到锁， <code>ReentrantLock</code> 就是以独占方式实现的。独占锁是一种悲观锁，由于每次访问资源都先加上互斥锁，这限制了并发性，因为读操作并不会影响数据的一致性，而独占锁只允许在同一时间由一个线程读取数据，其他线程必须等待当前线程释放锁才能进行读取。</li><li>共享锁则可以同时由多个线程持有，例如<code>ReadWriteLock</code> 读写锁，它允许一个资源可以被多线程同时进行读操作。共享锁则是一种乐观锁，它放宽了加锁的条件，允许多个线程同时进行读操作</li></ul><h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><p>当一个线程要获取一个被其他线程持有的独占锁时，该线程会被阻塞，那么当一个线程再次获取它自己己经获取的锁时，如果不被阻塞，那么我们说该锁是可重入的，也就是只要该线程获取了该锁，那么可以无限次数（严格来说是有限次数）地进入被该锁锁住的代码。</p><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>由于Java 中的线程是与操作系统中的线程一一对应的，所以当一个线程在获取锁（比如独占锁）失败后，会被切换到内核状态而被挂起。当该线程获取到锁时又需要将其切换到内核状态而唤醒该线程。而从用户状态切换到内核状态的开销是比较大的，在一定程度上会影响并发性能。自旋锁则是，当前线程在获取锁时，如果发现锁已经被其他线程占有，它不马上阻塞自己，在不放弃CPU 使用权的情况下，多次尝试获取，很有可能在后面几次尝试中其他线程己经释放了锁。如果尝试指定的次数后仍没有获取到锁则当前线程才会被阻塞挂起。由此看来自旋锁是使用CPU 时间换取线程阻塞与调度的开销，但是很有可能这些CPU 时间白白浪费了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;synchronized&quot;&gt;&lt;a href=&quot;#synchronized&quot; class=&quot;headerlink&quot; title=&quot;synchronized&quot;&gt;&lt;/a&gt;synchronized&lt;/h1&gt;&lt;p&gt;&lt;code&gt;synchronized块&lt;/code&gt;是Java 提供的一种原子性内置锁， &lt;code&gt;Java&lt;/code&gt; 中的每个对象都可以把它当作一个同步锁来使用， 这些Java 内置的使用者看不到的锁被称为内部锁，也叫作监视器锁。&lt;code&gt;synchronized&lt;/code&gt; 关键字底层原理属于 JVM 层面。线程的执行代码在进入&lt;code&gt;synchronized&lt;/code&gt; 代码块前会自动获取内部锁，这时候其他线程访问该同步代码块时会被阻塞挂起。拿到内部锁的线程会在正常退出同步代码块或者抛出异常后或者在同步块内调用了该内置锁资源的&lt;code&gt;wait&lt;/code&gt; 系列方法时释放该内置锁。内置锁是排它锁，也就是当一个线程获取这个锁后， 其他线程必须等待该线程释放锁后才能获取该锁。&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://blog.onebug.tech/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://blog.onebug.tech/tags/java/"/>
    
      <category term="并发" scheme="http://blog.onebug.tech/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="笔记" scheme="http://blog.onebug.tech/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java并发编程之美" scheme="http://blog.onebug.tech/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>线程封闭的常用策略--ThreadLocal</title>
    <link href="http://blog.onebug.tech/2021/10/10/java/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/ThreadLocal/"/>
    <id>http://blog.onebug.tech/2021/10/10/java/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/ThreadLocal/</id>
    <published>2021-10-09T16:00:00.000Z</published>
    <updated>2021-10-21T12:59:37.057Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程封闭"><a href="#线程封闭" class="headerlink" title="线程封闭"></a>线程封闭</h1><p>当访问共享变量时，往往需要加锁来保证数据同步。<strong>一种避免使用同步的方式就是不共享数据。如果仅在单线程中访问数据，就不需要同步了，这种技术称为线程封闭。</strong></p><p>线程封闭技术有一个常见的应用，JDBC的Connection对象。Connection对象在实现的时候并没有对线程安全做太多的处理，JDBC的规范里也没有要求Connection对象必须是线程安全的。实际在服务器应用程序中，线程从连接池获取了一个Connection对象，使用完再把Connection对象返回给连接池，由于大多数请求都是由单线程采用同步的方式来处理的，并且在Connection对象返回之前，连接池不会将它分配给其他线程。因此这种连接管理模式处理请求时隐含的将Connection对象封闭在线程里面，这样我们使用的Connection对象虽然本身不是线程安全的，但是它通过线程封闭也做到了线程安全。</p><p>实现线程封闭，一般有三种方法：Ad-hoc 线程封闭、堆栈封闭、<strong>ThreadLocal线程封闭</strong>。</p><a id="more"></a><h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p>ThreadLocal 是JDK 包提供的，它提供了线程本地变量，也就是如果你创建了一个ThreadLocal 变量，那么访问这个变量的每个线程都会有这个变量的一个本地副本。当多个线程操作这个变量时，实际操作的是自己本地内存里面的变量，从而避免了线程安全问题。创建一个ThreadLocal 变量后，每个线程都会复制一个变量到自己的本地内存中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//   一个简单ThreadLocal示例</span></span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;String&gt; localVal=<span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        localVal.set(<span class="string">"main THREAD"</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            System.out.println(localVal.get());</span><br><span class="line">            localVal.set(<span class="string">"THREAD 1"</span>);</span><br><span class="line">            System.out.println(localVal.get());</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            localVal.set(<span class="string">"THREAD 2"</span>);</span><br><span class="line">            System.out.println(localVal.get());</span><br><span class="line">        &#125;).start();</span><br><span class="line">        </span><br><span class="line">        localVal.remove();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="http://image.onebug.tech/image-20211010191615958.png" alt="image-20211010191615958"></p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p><img src="http://image.onebug.tech/image-20211010191911770.png" alt="image-20211010191911770"></p><p><code>Thread</code> 类中有一个<code>threadLocals</code> 和一个<code>inheritableThreadLocals</code> ， 它们都是<code>ThreadLocalMap</code> 类型的变量， 而<code>ThreadLocalMap</code> 是一个定制化的<code>Hashmap</code> 。其实每个线程的本地变量不是存放在<code>ThreadLocal</code> 实例里面，而是存放在调用线程的<code>threadLocals</code> 变量里面。也就是说， <code>ThreadLocal</code> 类型的本地变量存放在具体的线程内存空间中。而<code>ThreadLocal</code> 就是一个工具壳类，它通过<code>set</code> 方法把<code>value</code> 值放入调用线程的<code>threadLocals</code> 里面并存放起来，当调用线程调用它的get 方法时，再从当前线程的<code>threadLocals</code> 变量里面将其拿出来使用。</p><p><code>ThreadLocal</code>工具类的<code>set</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">//获取线程对应的ThreadLocalMap</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">    <span class="comment">// 将this作为key,写入ThreadLocalMap </span></span><br><span class="line">    map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ThreadLocal</code>工具类的<code>get</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">    ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><p>内存泄露与预防：每个线程的本地变量存放在线程自己的内存变量<code>threadLocals</code> 中，如果当前线程一直不消亡， 那么这些本地变量会一直存在， 所以可能会造成内存溢出， 因此使用完毕后要记得调用<code>ThreadLocal</code> 的<code>remove</code> 方法删除对应线程的<code>threadLocals</code> 中的本地变量。</p></li><li><p><code>InheritableThreadLocal</code>：<code>InheritableThreadLocal</code>继承自<code>ThreadLocal</code> ， 其提供了一个特性，就是让子线程可以访问在父线程中设置的本地变量。它的实现原理是当父线程创建子线程时，构造函数会把父线程中<code>inheritableThreadLocals</code> 变量里面的本地变量复制一份保存到子线程的<code>inheritableThreadLocals</code> 变量里面。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;线程封闭&quot;&gt;&lt;a href=&quot;#线程封闭&quot; class=&quot;headerlink&quot; title=&quot;线程封闭&quot;&gt;&lt;/a&gt;线程封闭&lt;/h1&gt;&lt;p&gt;当访问共享变量时，往往需要加锁来保证数据同步。&lt;strong&gt;一种避免使用同步的方式就是不共享数据。如果仅在单线程中访问数据，就不需要同步了，这种技术称为线程封闭。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;线程封闭技术有一个常见的应用，JDBC的Connection对象。Connection对象在实现的时候并没有对线程安全做太多的处理，JDBC的规范里也没有要求Connection对象必须是线程安全的。实际在服务器应用程序中，线程从连接池获取了一个Connection对象，使用完再把Connection对象返回给连接池，由于大多数请求都是由单线程采用同步的方式来处理的，并且在Connection对象返回之前，连接池不会将它分配给其他线程。因此这种连接管理模式处理请求时隐含的将Connection对象封闭在线程里面，这样我们使用的Connection对象虽然本身不是线程安全的，但是它通过线程封闭也做到了线程安全。&lt;/p&gt;
&lt;p&gt;实现线程封闭，一般有三种方法：Ad-hoc 线程封闭、堆栈封闭、&lt;strong&gt;ThreadLocal线程封闭&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://blog.onebug.tech/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://blog.onebug.tech/tags/java/"/>
    
      <category term="并发" scheme="http://blog.onebug.tech/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="笔记" scheme="http://blog.onebug.tech/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java并发编程之美" scheme="http://blog.onebug.tech/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>java多线程编程基础（一）</title>
    <link href="http://blog.onebug.tech/2021/10/08/java/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://blog.onebug.tech/2021/10/08/java/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2021-10-07T16:00:00.000Z</published>
    <updated>2021-10-15T12:46:15.879Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h1><p>在讨论什么是线程前有必要先说下什么是进程，因为线程是进程中的一个实体，线程本身是不会独立存在的。进程是代码在数据集合上的一次运行活动， 是系统进行资源分配和调度的基本单位， 线程则是进程的一个执行路径， 一个进程中至少有一个线程，进程中的多个线程共享进程的资源。操作系统在分配资源时是把资源分配给进程的， 但是CPU 资源比较特殊， 它是被分配到线程的， 因为真正要占用C PU 运行的是线程， 所以也说线程是CPU 分配的基本单位。</p><a id="more"></a><h1 id="线程的创建与启动"><a href="#线程的创建与启动" class="headerlink" title="线程的创建与启动"></a>线程的创建与启动</h1><p>Java 中有三种线程创建方式，分别为：</p><h2 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h2><p>实现<code>Runnable</code> 接口的<code>run</code> 方法。使用<code>lambda</code>简化代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Runnable task = () -&gt; &#123; System.out.println(<span class="string">"Task #1 is running"</span>); &#125;;</span><br><span class="line"><span class="keyword">new</span> Thread(task).start();</span><br></pre></td></tr></table></figure><h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><p>继承<code>Thread</code> 类并重写<code>run</code> 的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"child thread run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ThreadTest().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><p>使用<code>FutureTask</code> 方式。<code>FutureTask</code>实现了<code>Callable</code>接口，能够获取异步任务的返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建异步任务</span></span><br><span class="line">FutureTask&lt;Integer&gt; futureTask=<span class="keyword">new</span> FutureTask&lt;&gt;(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">"task#2: cal 1+2"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+<span class="number">2</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">//启动任务</span></span><br><span class="line"><span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待任务执行完毕，并返回结果</span></span><br><span class="line"><span class="keyword">int</span> result=futureTask.get();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"result is "</span>+result);</span><br></pre></td></tr></table></figure><h1 id="线程通知与等待"><a href="#线程通知与等待" class="headerlink" title="线程通知与等待"></a>线程通知与等待</h1><h2 id="wait-和notify"><a href="#wait-和notify" class="headerlink" title="wait()和notify()"></a>wait()和notify()</h2><p>当一个线程调用一个共享变量的<code>wait()</code>方法时， 该调用线程会被阻塞挂起， 直到发生下面几件事情之一才返回： </p><ul><li>其他线程调用了该共享对象的<code>notify()</code>或者<code>notifyAll()</code>方法；</li><li>其他线程调用了该线程的<code>interrupt()</code>方法， 该线程抛出<code>InterruptedException</code> 异常返回。</li></ul><p>一个线程调用共享对象的notify（）方法后，会唤醒一个在该共享变量上调用<code>wait</code>系列方法后被挂起的线程。一个共享变量上可能会有多个线程在等待，具体唤醒哪个等待的线程是<strong>随机</strong>的。不同于<code>notify()</code>函数只会唤醒一个被阻塞到该共享变量上的线程，<code>notifyAll()</code>方法则会唤醒所有在该共享变量上由于调用<code>wait</code> 系列方法而被挂起的线程。</p><p><code>notify</code>和<code>wait</code>系列方法，都需要当前线程获取到了共享变量的监视器锁后，才可以调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Thread thread1=<span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!prepare)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread()+<span class="string">"阻塞挂起中..."</span>);</span><br><span class="line">                lock.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread()+<span class="string">"被唤醒"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"线程被中断"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">thread1.start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            prepare=<span class="keyword">true</span>;</span><br><span class="line">            System.out.println(Thread.currentThread()+<span class="string">"唤醒其他阻塞挂起的线程"</span>);</span><br><span class="line">            lock.notify();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><p><img src="http://image.onebug.tech/image-20211008205319745.png" alt="image-20211008205319745"></p><blockquote><p>另外需要注意的是，当前线程调用共享变量的<code>wait()</code>方法后只会释放当前共享变量上的锁，如果当前线程还持有其他共享变量的锁，则这些锁是不会被释放的</p></blockquote><h2 id="虚假唤醒"><a href="#虚假唤醒" class="headerlink" title="虚假唤醒"></a>虚假唤醒</h2><p>另外需要注意的是，一个线程可以从挂起状态变为可以运行状态（ 也就是被唤醒）即使该线程没有被其他线程调用<code>notify()</code>、<code>notifyAll()</code>方法进行通知，或者被中断，或者等待超时，这就是所谓的虚假唤醒。<br>虽然虚假唤醒在应用实践中很少发生，但要防患于未然，做法就是不停地去测试该线程被唤醒的条件是否满足，不满足则继续等待，也就是说在一个循环中调用<code>wait()</code>方法进行防范。退出循环的条件是满足了唤醒该线程的条件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">synchronized (obj)&#123;</span><br><span class="line">    while (!prepare)&#123;</span><br><span class="line">        &#x2F;&#x2F;阻塞挂起</span><br><span class="line">        obj.wait();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="wait超时"><a href="#wait超时" class="headerlink" title="wait超时"></a>wait超时</h2><ul><li><code>wait(long timeout)</code>：该方法相比<code>wait()</code> 方法多了一个超时参数，它的不同之处在于，如果一个线程调用共享对象的该方法挂起后， 没有在指定的timeout ms 时间内被唤醒，那么该函数还是会因为超时而返回。</li></ul><h1 id="线程的其他方法"><a href="#线程的其他方法" class="headerlink" title="线程的其他方法"></a>线程的其他方法</h1><h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><p>在项目实践中经常会遇到一个场景，就是是需要等待某几件事情完成后才能继续往下执行，比如多个线程加载资源， 需要等待多个线程全部加载完毕再汇总处理。Thread 类中有一个简单的<code>join</code> 方法就可以做这个事情。（事实上不太使用该方法，<code>AQS</code>中的<code>CountdownLatch</code>更为强大和常用）</p><h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h2><p>Thread 类中有一个静态的<code>sleep</code>方法，当一个执行中的线程调用了<code>Thread</code> 的<code>sleep</code> 方法后，调用线程会暂时让出指定时间的执行权，也就是在这期间不参与CPU的调度。指定的睡眠时间到了后该函数会正常返回，线程就处于就绪状态，然后参与CPU 的调度，获取到CPU 资源后就可以继续运行了。不同于<code>wait</code>方法，线程在调用<code>sleep</code>方法后，该线程所拥有的监视器资源，比如锁还是持有不让出的。</p><h2 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h2><p>Thread 类中有一个静态的yield 方法，当一个线程调用<code>yield</code>方法时，实际就是在暗示线程调度器当前线程请求让出自己的CPU使用，但是线程调度器可以无条件忽略这个暗示。当一个线程调用<code>yield</code> 方法时， 当前线程会让出CPU使用权，然后处于就绪状态，线程调度器会从线程就绪队列里面获取一个线程优先级最高的线程，当然也有可能会调度到刚刚让出CPU 的那个线程来获取CPU 执行权，这也是<code>yield</code>和<code>sleep</code>不同的地方。</p><h1 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h1><p>Java 中的线程中断是一种线程间的协作模式，通过设置线程的中断标志并不能直接终止该线程的执行， 而是被中断的线程根据中断状态自行处理。</p><ul><li><code>void interrup()</code> 方法： 中断线程， 例如，当线程A 运行时，线程B 可以调用钱程A的<code>interrupt()</code>方法来设置线程A 的中断标志为true 并立即返回。<strong>设置标志仅仅是设置标志， 线程A 实际并没有被中断， 它会继续往下执行</strong>。如果线程A 因为调用了<code>wait</code> 系列函数、<code>join</code> 方法或者<code>sleep</code> 方法而被阻塞挂起，这时候若线程B 调用线程A 的<code>interrupt()</code> 方法，线程A 会在调用这些方法的地方抛出<code>InterruptedException</code> 异常而返回。</li><li><code>boolean isinterrupte()</code> 方法： 检测当前线程是否被中断，如果是返回<code>true</code> ， 否则返回<code>false</code> 。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Thread thread=<span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">float</span> i=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (i&lt;<span class="number">1000</span>) &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//                clean up if required</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        thread.interrupt();</span><br><span class="line">        System.out.println(<span class="string">"中断线程"</span>+thread);</span><br></pre></td></tr></table></figure><p><img src="http://image.onebug.tech/image-20211008212955074.png" alt="image-20211008212955074"></p><p>可以看到，程序没有抛出异常，而是正常执行。</p><h1 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h1><p>死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的互相等待的现象，在无外力作用的情况下，这些线程会一直相互等待而无法继续运行下去。</p><p>死锁的产生必须具备以下四个条件：</p><ul><li>互斥条件： 指线程对己经获取到的资源进行排它性使用， 即该资源同时只由一个线程占用。如果此时还有其他线程请求获取该资源，则请求者只能等待，直至占有资源的线程释放该资源。</li><li>请求并持有条件： 指一个线程己经持有了至少一个资源， 但又提出了新的资源请求，而新资源己被其他线程占有，所以当前线程会被阻塞，但阻塞的同时并不释放自己己经获取的资源。</li><li>不可剥夺条件： 指线程获取到的资源在自己使用完之前不能被其他线程抢占， 只有在自己使用完毕后才由自己释放该资源。</li><li>环路等待条件： 指在发生死锁时， 必然存在一个线程→资源的环形链， 即线程集合{TO , TL T2 ，…， Tn ｝中的TO 正在等待一个Tl 占用的资源， Tl 正在等待T2 占用的资源，……Tn 正在等待己被TO 占用的资源。</li></ul><p>一个线程死锁的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> Object resource1=<span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> Object resource2=<span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread threadA=<span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">"threadA 尝试获取 resource1中..."</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (resource1)&#123;</span><br><span class="line">                System.out.println(<span class="string">"threadA 获取 resource1成功"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"threadA 尝试获取 resource2中..."</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (resource2)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"threadA 获取 resource2成功"</span>);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Thread threadB=<span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">"threadB 尝试获取 resource2中..."</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (resource2)&#123;</span><br><span class="line">                System.out.println(<span class="string">"threadB 获取 resource2成功"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"threadB尝试获取 resource1中..."</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (resource1)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"threadB 获取 resource1成功"</span>);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://image.onebug.tech/image-20211008214107190.png" alt="image-20211008214107190"></p><p>如图所示，<code>threadA</code>和<code>threadB</code>形成了线程死锁。</p><p><img src="http://image.onebug.tech/image-20211008213421323.png" alt="image-20211008213421323"></p><p>关于如何避免线程死锁，操作系统中有详细介绍，这里不赘述。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是线程&quot;&gt;&lt;a href=&quot;#什么是线程&quot; class=&quot;headerlink&quot; title=&quot;什么是线程&quot;&gt;&lt;/a&gt;什么是线程&lt;/h1&gt;&lt;p&gt;在讨论什么是线程前有必要先说下什么是进程，因为线程是进程中的一个实体，线程本身是不会独立存在的。进程是代码在数据集合上的一次运行活动， 是系统进行资源分配和调度的基本单位， 线程则是进程的一个执行路径， 一个进程中至少有一个线程，进程中的多个线程共享进程的资源。操作系统在分配资源时是把资源分配给进程的， 但是CPU 资源比较特殊， 它是被分配到线程的， 因为真正要占用C PU 运行的是线程， 所以也说线程是CPU 分配的基本单位。&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://blog.onebug.tech/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://blog.onebug.tech/tags/java/"/>
    
      <category term="并发" scheme="http://blog.onebug.tech/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="笔记" scheme="http://blog.onebug.tech/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java并发编程之美" scheme="http://blog.onebug.tech/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>Netty的优化</title>
    <link href="http://blog.onebug.tech/2021/09/30/java/netty/Netty%E4%BC%98%E5%8C%96/"/>
    <id>http://blog.onebug.tech/2021/09/30/java/netty/Netty%E4%BC%98%E5%8C%96/</id>
    <published>2021-09-29T16:00:00.000Z</published>
    <updated>2021-09-30T02:23:47.673Z</updated>
    
    <content type="html"><![CDATA[<h1 id="共享Handler"><a href="#共享Handler" class="headerlink" title="共享Handler"></a>共享Handler</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap</span><br><span class="line">                .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> </span>&#123;</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> Spliter());<span class="comment">//帧解码器</span></span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> PacketDecoder());<span class="comment">//数据包解码器</span></span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> HandlerA());<span class="comment">//业务Handler</span></span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> HandlerB());<span class="comment">//业务Handler</span></span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> HandlerC());<span class="comment">//业务Handler</span></span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> PacketEncoder());<span class="comment">//数据包编码器</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure><p>每次有新连接到来的时候，都会调用 <code>ChannelInitializer</code> 的 <code>initChannel()</code> 方法，然后这里相关的 <code>handler</code> 都会被 <code>new</code> 一次。许多 <code>handler</code>，他们内部都是没有成员变量的，也就是说是无状态的，我们完全可以使用单例模式，即调用 <code>pipeline().addLast()</code> 方法的时候，都直接使用单例，不需要每次都 <code>new</code>，提高效率，也避免了创建很多小的对象。</p><p>单例改造：对于无状态<code>Handler</code>，使用单例模式，多个channel共享一个实例</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 1. 加上注解标识，表明该 handler 是可以多个 channel 共享的</span></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerA</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">APacket</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 构造单例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> HandlerA INSTANCE = <span class="keyword">new</span> HandlerA();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">HandlerA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>@ChannelHandler.Sharable</code> 显示地告诉 Netty，这个 handler 是支持多个 channel 共享的，否则会报错。</p></blockquote><h1 id="合并编解码器"><a href="#合并编解码器" class="headerlink" title="合并编解码器"></a>合并编解码器</h1><p>Netty 内部提供了一个类，叫做 <code>MessageToMessageCodec</code>，使用它可以让我们的编解码操作放到一个类里面去实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PacketCodecHandler</span> <span class="keyword">extends</span> <span class="title">MessageToMessageCodec</span>&lt;<span class="title">ByteBuf</span>,<span class="title">Packet</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> PacketCodecHandler INSTANCE=<span class="keyword">new</span> PacketCodecHandler();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Packet msg, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        out.add(PacketCodeC.DEFAULT.encode(ctx.alloc(),msg));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf msg, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        out.add(PacketCodeC.DEFAULT.decode(msg));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>PacketCodecHandler</code>一般是一个无状态的 <code>handler</code>，因此，同样可以使用单例模式来实现。我们需要实现 <code>MessageToMessageCodec</code>的<code>decode()</code> 和 <code>encode()</code> 方法，<code>decode</code> 是将二进制数据 <code>ByteBuf</code> 转换为 java 对象 <code>Packet</code>，而 <code>encode</code> 操作是一个相反的过程，在 <code>encode()</code> 方法里面，我们需要传入了 <code>channel</code> 的 内存分配器，手工分配了 <code>ByteBuf</code>。</p><h1 id="缩短事件传播路径"><a href="#缩短事件传播路径" class="headerlink" title="缩短事件传播路径"></a>缩短事件传播路径</h1><h2 id="合并平行-handler"><a href="#合并平行-handler" class="headerlink" title="合并平行 handler"></a>合并平行 handler</h2><p>在很多情况下，每次 decode 出来一个指令对象之后，其实只会在一个指令 <code>handler</code> 上进行处理，因此，我们其实可以把这么多的指令 <code>handler</code> 压缩为一个 <code>handler</code>实现路由功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@ChannelHandler.Sharable</span><br><span class="line">public class RouteHandler extends SimpleChannelInboundHandler&lt;Packet&gt; &#123;</span><br><span class="line">    public static final RouteHandler INSTANCE &#x3D; new RouteHandler();</span><br><span class="line"></span><br><span class="line">    private Map&lt;Byte, SimpleChannelInboundHandler&lt;? extends Packet&gt;&gt; routeMap;</span><br><span class="line"></span><br><span class="line">    private IMHandler() &#123;</span><br><span class="line">        routeMap &#x3D; new HashMap&lt;Byte, SimpleChannelInboundHandler&lt;? extends Packet&gt;&gt;()&#123;&#123;</span><br><span class="line">            put(CommandA, HandlerA.INSTANCE);</span><br><span class="line">           put(CommandB, HandlerB.INSTANCE);</span><br><span class="line">           put(CommandC, HandlerC.INSTANCE);</span><br><span class="line"></span><br><span class="line">        &#125;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void channelRead0(ChannelHandlerContext ctx, Packet packet) throws Exception &#123;</span><br><span class="line">        routeMap.get(packet.getCommand()).channelRead(ctx, packet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过上述优化方法后，我们的<code>pipeline</code>最终变成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap</span><br><span class="line">                .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    protected void initChannel(NioSocketChannel ch) &#123;</span><br><span class="line">                        ch.pipeline().addLast(new Spliter());&#x2F;&#x2F;帧解码器</span><br><span class="line">                        ch.pipeline().addLast(new PacketCodecHandler.INSTANCE());&#x2F;&#x2F;数据包编解码器</span><br><span class="line">                        ch.pipeline().addLast(RouteHandler.INSTANCE);&#x2F;&#x2F;路由</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure><blockquote><p>第一个<code>Handler</code>是帧解码器 <code>Spliter</code>，我们是无法使用单例模式进行改造的，因为他内部实现是与每个 <code>channel</code> 有关，每个 <code>Spliter</code> 需要维持每个 channel 当前读到的数据，也就是说他是有状态的。</p></blockquote><h2 id="更改事件传播源"><a href="#更改事件传播源" class="headerlink" title="更改事件传播源"></a>更改事件传播源</h2><p>如果你的 <code>outBound</code> 类型的 <code>handler</code> 较多，在写数据的时候能用 <code>ctx.writeAndFlush()</code> 就用这个方法。</p><p><code>ctx.writeAndFlush()</code> 是从 pipeline 链中的当前节点开始往前找到第一个 outBound 类型的 handler 把对象往前进行传播，如果这个对象确认不需要经过其他 outBound 类型的 handler 处理，就使用这个方法。</p><p><img src="http://image.onebug.tech/1664b767ddcf7711~tplv-t2oaga2asx-watermark.awebp" alt="image.png"></p><p><code>ctx.channel().writeAndFlush()</code> 是从 <code>pipeline</code> 链中的最后一个 <code>outBound</code> 类型的 <code>handler</code> 开始，把对象往前进行传播，如果你确认当前创建的对象需要经过后面的 <code>outBound</code> 类型的 handler，那么就调用此方法。</p><p><img src="http://image.onebug.tech/1664b767de0cf5ea~tplv-t2oaga2asx-watermark.awebp" alt="image.png"></p><h1 id="减少阻塞主线程的操作"><a href="#减少阻塞主线程的操作" class="headerlink" title="减少阻塞主线程的操作"></a>减少阻塞主线程的操作</h1><p>通常我们的应用程序会涉及到数据库或者网络，比如以下这个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, T packet)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. balabala 一些逻辑</span></span><br><span class="line">    <span class="comment">// 2. 数据库或者网络等一些耗时的操作</span></span><br><span class="line">    <span class="comment">// 3. writeAndFlush()</span></span><br><span class="line">    <span class="comment">// 4. balabala 其他的逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于Netty是基于事件驱动的异步网络框架，一个 <code>handler</code> 中的 <code>channelRead0()</code> 方法阻塞了 NIO 线程，最终都会拖慢绑定在该 NIO 线程上的其他所有的 <code>channel</code>。对于耗时的操作，我们需要把这些耗时的操作丢到我们的业务线程池或利用消息队列中去处理，这样，就可以避免一些耗时的操作影响 Netty 的 NIO 线程，从而影响其他的 <code>channel</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;共享Handler&quot;&gt;&lt;a href=&quot;#共享Handler&quot; class=&quot;headerlink&quot; title=&quot;共享Handler&quot;&gt;&lt;/a&gt;共享Handler&lt;/h1&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;serverBootstrap&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                .childHandler(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ChannelInitializer&amp;lt;NioSocketChannel&amp;gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;initChannel&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(NioSocketChannel ch)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        ch.pipeline().addLast(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Spliter());&lt;span class=&quot;comment&quot;&gt;//帧解码器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        ch.pipeline().addLast(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; PacketDecoder());&lt;span class=&quot;comment&quot;&gt;//数据包解码器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        ch.pipeline().addLast(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; HandlerA());&lt;span class=&quot;comment&quot;&gt;//业务Handler&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        ch.pipeline().addLast(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; HandlerB());&lt;span class=&quot;comment&quot;&gt;//业务Handler&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        ch.pipeline().addLast(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; HandlerC());&lt;span class=&quot;comment&quot;&gt;//业务Handler&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        ch.pipeline().addLast(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; PacketEncoder());&lt;span class=&quot;comment&quot;&gt;//数据包编码器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;每次有新连接到来的时候，都会调用 &lt;code&gt;ChannelInitializer&lt;/code&gt; 的 &lt;code&gt;initChannel()&lt;/code&gt; 方法，然后这里相关的 &lt;code&gt;handler&lt;/code&gt; 都会被 &lt;code&gt;new&lt;/code&gt; 一次。许多 &lt;code&gt;handler&lt;/code&gt;，他们内部都是没有成员变量的，也就是说是无状态的，我们完全可以使用单例模式，即调用 &lt;code&gt;pipeline().addLast()&lt;/code&gt; 方法的时候，都直接使用单例，不需要每次都 &lt;code&gt;new&lt;/code&gt;，提高效率，也避免了创建很多小的对象。&lt;/p&gt;
&lt;p&gt;单例改造：对于无状态&lt;code&gt;Handler&lt;/code&gt;，使用单例模式，多个channel共享一个实例&lt;/p&gt;
    
    </summary>
    
    
      <category term="netty" scheme="http://blog.onebug.tech/categories/netty/"/>
    
    
      <category term="java" scheme="http://blog.onebug.tech/tags/java/"/>
    
      <category term="netty" scheme="http://blog.onebug.tech/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>心跳与空闲检测</title>
    <link href="http://blog.onebug.tech/2021/09/30/java/netty/%E5%BF%83%E8%B7%B3%E4%B8%8E%E7%A9%BA%E9%97%B2%E6%A3%80%E6%B5%8B/"/>
    <id>http://blog.onebug.tech/2021/09/30/java/netty/%E5%BF%83%E8%B7%B3%E4%B8%8E%E7%A9%BA%E9%97%B2%E6%A3%80%E6%B5%8B/</id>
    <published>2021-09-29T16:00:00.000Z</published>
    <updated>2021-09-30T02:23:56.078Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-网络问题"><a href="#1-网络问题" class="headerlink" title="1. 网络问题"></a>1. 网络问题</h2><p>下图是网络应用程序普遍会遇到的一个问题：连接假死</p><p><img src="http://image.onebug.tech/1664c39eb393e946~tplv-t2oaga2asx-watermark.awebp" alt="image.png"></p><p>连接假死的现象是：在某一端（服务端或者客户端）看来，底层的 TCP 连接已经断开了，但是应用程序并没有捕获到，因此会认为这条连接仍然是存在的，从 TCP 层面来说，只有收到四次握手数据包或者一个 RST 数据包，连接的状态才表示已断开。</p><p>连接假死会带来以下两大问题</p><a id="more"></a><ol><li>对于服务端来说，因为每条连接都会耗费 cpu 和内存资源，大量假死的连接会逐渐耗光服务器的资源，最终导致性能逐渐下降，程序奔溃。</li><li>对于客户端来说，连接假死会造成发送数据超时，影响用户体验。</li></ol><p>通常，连接假死由以下几个原因造成的</p><ol><li>应用程序出现线程堵塞，无法进行数据的读写。</li><li>客户端或者服务端网络相关的设备出现故障，比如网卡，机房故障。</li><li>公网丢包。公网环境相对内网而言，非常容易出现丢包，网络抖动等现象，如果在一段时间内用户接入的网络连续出现丢包现象，那么对客户端来说数据一直发送不出去，而服务端也是一直收不到客户端来的数据，连接就一直耗着。</li></ol><p>如果我们的应用是面向用户的，那么公网丢包这个问题出现的概率是非常大的。对于内网来说，内网丢包，抖动也是会有一定的概率发生。一旦出现此类问题，客户端和服务端都会受到影响，接下来，我们分别从服务端和客户端的角度来解决连接假死的问题。</p><h2 id="2-服务端空闲检测"><a href="#2-服务端空闲检测" class="headerlink" title="2. 服务端空闲检测"></a>2. 服务端空闲检测</h2><p>对于服务端来说，客户端的连接如果出现假死，那么服务端将无法收到客户端的数据，也就是说，如果能一直收到客户端发来的数据，那么可以说明这条连接还是活的，因此，服务端对于连接假死的应对策略就是空闲检测。</p><p>何为空闲检测？空闲检测指的是每隔一段时间，检测这段时间内是否有数据读写，简化一下，我们的服务端只需要检测一段时间内，是否收到过客户端发来的数据即可，Netty 自带的 <code>IdleStateHandler</code> 就可以实现这个功能。</p><p>接下来，我们写一个类继承自 <code>IdleStateHandler</code>，来定义检测到假死连接之后的逻辑。</p><blockquote><p>IMIdleStateHandler.java</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class IMIdleStateHandler extends IdleStateHandler &#123;</span><br><span class="line"></span><br><span class="line">    private static final int READER_IDLE_TIME &#x3D; 15;</span><br><span class="line"></span><br><span class="line">    public IMIdleStateHandler() &#123;</span><br><span class="line">        super(READER_IDLE_TIME, 0, 0, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void channelIdle(ChannelHandlerContext ctx, IdleStateEvent evt) &#123;</span><br><span class="line">        System.out.println(READER_IDLE_TIME + &quot;秒内未读到数据，关闭连接&quot;);</span><br><span class="line">        ctx.channel().close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先，我们观察一下 <code>IMIdleStateHandler</code> 的构造函数，他调用父类 <code>IdleStateHandler</code> 的构造函数，有四个参数，其中第一个表示读空闲时间，指的是在这段时间内如果没有数据读到，就表示连接假死；第二个是写空闲时间，指的是 在这段时间如果没有写数据，就表示连接假死；第三个参数是读写空闲时间，表示在这段时间内如果没有产生数据读或者写，就表示连接假死。写空闲和读写空闲为0，表示我们不关心者两类条件；最后一个参数表示时间单位。在我们的例子中，表示的是：如果 15 秒内没有读到数据，就表示连接假死。</li><li>连接假死之后会回调 <code>channelIdle()</code> 方法，我们这个方法里面打印消息，并手动关闭连接。</li></ol><p>接下来，我们把这个 handler 插入到服务端 pipeline 的最前面</p><blockquote><p>NettyServer.java</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap</span><br><span class="line">        .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">            protected void initChannel(NioSocketChannel ch) &#123;</span><br><span class="line">                &#x2F;&#x2F; 空闲检测</span><br><span class="line">                ch.pipeline().addLast(new IMIdleStateHandler());</span><br><span class="line">                ch.pipeline().addLast(new Spliter());</span><br><span class="line">                &#x2F;&#x2F; ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>为什么要插入到最前面？是因为如果插入到最后面的话，如果这条连接读到了数据，但是在 inBound 传播的过程中出错了或者数据处理完完毕就不往后传递了（我们的应用程序属于这类），那么最终 <code>IMIdleStateHandler</code> 就不会读到数据，最终导致误判。</p><p>服务端的空闲检测时间完毕之后，接下来我们再思考一下，在一段时间之内没有读到客户端的数据，是否一定能判断连接假死呢？并不能，如果在这段时间之内客户端确实是没有发送数据过来，但是连接是 ok 的，那么这个时候服务端也是不能关闭这条连接的，为了防止服务端误判，我们还需要在客户端做点什么。</p><h2 id="3-客户端定时发心跳"><a href="#3-客户端定时发心跳" class="headerlink" title="3. 客户端定时发心跳"></a>3. 客户端定时发心跳</h2><p>服务端在一段时间内没有收到客户端的数据，这个现象产生的原因可以分为以下两种：</p><ol><li>连接假死。</li><li>非假死状态下确实没有发送数据。</li></ol><p>我们只需要排除掉第二种可能性，那么连接自然就是假死的。要排查第二种情况，我们可以在客户端定期发送数据到服务端，通常这个数据包称为心跳数据包，接下来，我们定义一个 handler，定期发送心跳给服务端</p><blockquote><p>HeartBeatTimerHandler.java</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class HeartBeatTimerHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    private static final int HEARTBEAT_INTERVAL &#x3D; 5;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        scheduleSendHeartBeat(ctx);</span><br><span class="line"></span><br><span class="line">        super.channelActive(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void scheduleSendHeartBeat(ChannelHandlerContext ctx) &#123;</span><br><span class="line">        ctx.executor().schedule(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            if (ctx.channel().isActive()) &#123;</span><br><span class="line">                ctx.writeAndFlush(new HeartBeatRequestPacket());</span><br><span class="line">                scheduleSendHeartBeat(ctx);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;, HEARTBEAT_INTERVAL, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ctx.executor()</code> 返回的是当前的 channel 绑定的 NIO 线程，不理解没关系，只要记住就行，然后，NIO 线程有一个方法，<code>schedule()</code>，类似 jdk 的延时任务机制，可以隔一段时间之后执行一个任务，而我们这边是实现了每隔 5 秒，向服务端发送一个心跳数据包，这个时间段通常要比服务端的空闲检测时间的一半要短一些，我们这里直接定义为空闲检测时间的三分之一，主要是为了排除公网偶发的秒级抖动。</p><p>实际在生产环境中，我们的发送心跳间隔时间和空闲检测时间可以略长一些，可以设置为几分钟级别，具体应用可以具体对待，没有强制的规定。</p><p>我们上面其实解决了服务端的空闲检测问题，服务端这个时候是能够在一定时间段之内关掉假死的连接，释放连接的资源了，但是对于客户端来说，我们也需要检测到假死的连接。</p><h2 id="4-服务端回复心跳与客户端空闲检测"><a href="#4-服务端回复心跳与客户端空闲检测" class="headerlink" title="4. 服务端回复心跳与客户端空闲检测"></a>4. 服务端回复心跳与客户端空闲检测</h2><p>客户端的空闲检测其实和服务端一样，依旧是在客户端 pipeline 的最前方插入 <code>IMIdleStateHandler</code></p><blockquote><p>NettyClient.java</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bootstrap</span><br><span class="line">        .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">            public void initChannel(SocketChannel ch) &#123;</span><br><span class="line">                &#x2F;&#x2F; 空闲检测</span><br><span class="line">                ch.pipeline().addLast(new IMIdleStateHandler());</span><br><span class="line">                ch.pipeline().addLast(new Spliter());</span><br><span class="line">                &#x2F;&#x2F; ...</span><br></pre></td></tr></table></figure><p>然后为了排除是否是因为服务端在非假死状态下确实没有发送数据，服务端也要定期发送心跳给客户端。</p><p>而其实在前面我们已经实现了客户端向服务端定期发送心跳，服务端这边其实只要在收到心跳之后回复客户端，给客户端发送一个心跳响应包即可。如果在一段时间之内客户端没有收到服务端发来的数据，也可以判定这条连接为假死状态。</p><p>因此，服务端的 pipeline 中需要再加上如下一个 handler - <code>HeartBeatRequestHandler</code>，由于这个 handler 的处理其实是无需登录的，所以，我们将该 handler 放置在 <code>AuthHandler</code> 前面</p><blockquote><p>NettyServer.java</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap</span><br><span class="line">                ch.pipeline().addLast(new IMIdleStateHandler());</span><br><span class="line">                ch.pipeline().addLast(new Spliter());</span><br><span class="line">                ch.pipeline().addLast(PacketCodecHandler.INSTANCE);</span><br><span class="line">                ch.pipeline().addLast(LoginRequestHandler.INSTANCE);</span><br><span class="line">                &#x2F;&#x2F; 加在这里</span><br><span class="line">                ch.pipeline().addLast(HeartBeatRequestHandler.INSTANCE);</span><br><span class="line">                ch.pipeline().addLast(AuthHandler.INSTANCE);</span><br><span class="line">                ch.pipeline().addLast(IMHandler.INSTANCE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p><code>HeartBeatRequestHandler</code> 相应的实现为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@ChannelHandler.Sharable</span><br><span class="line">public class HeartBeatRequestHandler extends SimpleChannelInboundHandler&lt;HeartBeatRequestPacket&gt; &#123;</span><br><span class="line">    public static final HeartBeatRequestHandler INSTANCE &#x3D; new HeartBeatRequestHandler();</span><br><span class="line"></span><br><span class="line">    private HeartBeatRequestHandler() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void channelRead0(ChannelHandlerContext ctx, HeartBeatRequestPacket requestPacket) &#123;</span><br><span class="line">        ctx.writeAndFlush(new HeartBeatResponsePacket());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现非常简单，只是简单地回复一个 <code>HeartBeatResponsePacket</code> 数据包。客户端在检测到假死连接之后，断开连接，然后可以有一定的策略去重连，重新登录等等，这里就不展开了，留给读者自行实现。</p><p>关于心跳与健康检测相关的内容就讲解到这里，原理理解清楚了并不难实现，最后，我们来对本小节内容做一下总结。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><ol><li>我们首先讨论了连接假死相关的现象以及产生的原因。</li><li>要处理假死问题首先我们要实现客户端与服务端定期发送心跳，在这里，其实服务端只需要对客户端的定时心跳包进行回复。</li><li>客户端与服务端如果都需要检测假死，那么直接在 pipeline 的最前方插入一个自定义 <code>IdleStateHandler</code>，在 <code>channelIdle()</code> 方法里面自定义连接假死之后的逻辑。</li><li>通常空闲检测时间要比发送心跳的时间的两倍要长一些，这也是为了排除偶发的公网抖动，防止误判。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-网络问题&quot;&gt;&lt;a href=&quot;#1-网络问题&quot; class=&quot;headerlink&quot; title=&quot;1. 网络问题&quot;&gt;&lt;/a&gt;1. 网络问题&lt;/h2&gt;&lt;p&gt;下图是网络应用程序普遍会遇到的一个问题：连接假死&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://image.onebug.tech/1664c39eb393e946~tplv-t2oaga2asx-watermark.awebp&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;连接假死的现象是：在某一端（服务端或者客户端）看来，底层的 TCP 连接已经断开了，但是应用程序并没有捕获到，因此会认为这条连接仍然是存在的，从 TCP 层面来说，只有收到四次握手数据包或者一个 RST 数据包，连接的状态才表示已断开。&lt;/p&gt;
&lt;p&gt;连接假死会带来以下两大问题&lt;/p&gt;
    
    </summary>
    
    
      <category term="netty" scheme="http://blog.onebug.tech/categories/netty/"/>
    
    
      <category term="java" scheme="http://blog.onebug.tech/tags/java/"/>
    
      <category term="netty" scheme="http://blog.onebug.tech/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>TCP的拆包和粘包</title>
    <link href="http://blog.onebug.tech/2021/09/06/java/netty/%E6%8B%86%E5%8C%85%E4%B8%8E%E7%B2%98%E5%8C%85/"/>
    <id>http://blog.onebug.tech/2021/09/06/java/netty/%E6%8B%86%E5%8C%85%E4%B8%8E%E7%B2%98%E5%8C%85/</id>
    <published>2021-09-05T16:00:00.000Z</published>
    <updated>2021-09-06T12:14:35.413Z</updated>
    
    <content type="html"><![CDATA[<h1 id="粘包、半包"><a href="#粘包、半包" class="headerlink" title="粘包、半包"></a>粘包、半包</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在网络传输中，粘包和半包应该是最常出现的问题。</p><p>TCP 传输中，客户端发送数据，实际是把数据写入到了 TCP 的缓存中，粘包和半包也就会在此时产生。</p><p>客户端给服务端发送了两条消息<code>ABC</code>和<code>DEF</code>，服务端这边的接收会有多少种情况呢？有可能是一次性收到了所有的消息<code>ABCDEF</code>，有可能是收到了三条消息<code>AB</code>、<code>CD</code>、<code>EF</code>。</p><p>上面所说的一次性收到了所有的消息<code>ABCDEF</code>，类似于粘包。如果客户端发送的包的大小比 TCP 的缓存容量小，并且 TCP 缓存可以存放多个包，那么客户端和服务端的一次通信就可能传递了多个包，这时候服务端从 TCP 缓存就可能一下读取了多个包，这种现象就叫<code>粘包</code>。</p><p>上面说的后面那种收到了三条消息<code>AB</code>、<code>CD</code>、<code>EF</code>，类似于半包。如果客户端发送的包的大小比 TCP 的缓存容量大，那么这个数据包就会被分成多个包，通过 Socket 多次发送到服务端，服务端第一次从接受缓存里面获取的数据，实际是整个包的一部分，这时候就产生了<code>半包</code>(半包不是说只收到了全包的一半，是说收到了全包的一部分)。</p><a id="more"></a><h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><p>因为TCP是面向连接的传输协议，TCP传输的数据是以流的形式，而流数据是没有明确的开始结尾边界，所以TCP也没办法判断哪一段流属于一个消息。</p><p><img src="http://image.onebug.tech/1460000021175323" alt="TCP协议传输过程.jpg"></p><p>因为TCP会根据缓冲区的实际情况进行包的划分，在业务上认为，有的包被拆分成多个包进行发送，也可能多个晓小的包封装成一个大的包发送，这就是TCP的粘包或者拆包。</p><p><img src="http://image.onebug.tech/1460000021175317" alt="粘包拆包图解.png"></p><p>假设客户端分别发送了两个数据包D1和D2给服务端，由于服务端一次读取到字节数是不确定的，故可能存在以下几种情况：</p><ol><li>服务端分两次读取到两个独立的数据包，分别是D1和D2，没有粘包和拆包。</li><li>服务端一次接收到了两个数据包，D1和D2粘在一起，发生粘包。</li><li>服务端分两次读取到数据包，第一次读取到了完整的D1包和D2包的部分内容，第二次读取到了D2包的剩余内容，发生拆包。</li><li>服务端分两次读取到数据包，第一次读取到部分D1包，第二次读取到剩余的D1包和全部的D2包。</li></ol><p>当TCP缓存再小一点的话，会把D1和D2分别拆成多个包发送。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>解决半包粘包的问题其实就是定义消息边界的问题。因为TCP只负责数据发送，并不处理业务上的数据，所以只能在上层应用协议栈解决，目前的解决方案归纳：</p><ol><li>消息定长，每个报文的大小固定，如果数据不够，空位补空格。</li><li>在包的尾部加回车换行符标识。</li><li>将消息分为消息头与消息体，消息头中包含消息总长度。</li><li>设计更复杂的协议。</li></ol><h1 id="Netty解决方案"><a href="#Netty解决方案" class="headerlink" title="Netty解决方案"></a>Netty解决方案</h1><h2 id="LineBasedFrameDecoder"><a href="#LineBasedFrameDecoder" class="headerlink" title="LineBasedFrameDecoder"></a>LineBasedFrameDecoder</h2><p>基于回车换行符的解码器，当遇到”n”或者 “rn”结束符时，分为一组。支持携带结束符或者不带结束符两种编码方式，也支持配置单行的最大长度。</p><h2 id="DelimiterBasedFrameDecoder"><a href="#DelimiterBasedFrameDecoder" class="headerlink" title="DelimiterBasedFrameDecoder"></a>DelimiterBasedFrameDecoder</h2><p>分隔符解码器，可以指定消息结束的分隔符，它可以自动完成以分隔符作为码流结束标识的消息的解码。回车换行解码器实际上是一种特殊的DelimiterBasedFrameDecoder解码器。</p><h2 id="FixedLengthFrameDecoder"><a href="#FixedLengthFrameDecoder" class="headerlink" title="FixedLengthFrameDecoder"></a>FixedLengthFrameDecoder</h2><p>固定长度解码器，它能够按照指定的长度对消息进行自动解码,当制定的长度过大，消息过短时会有资源浪费，但是使用起来简单。</p><h2 id="LengthFieldBasedFrameDecoder"><a href="#LengthFieldBasedFrameDecoder" class="headerlink" title="LengthFieldBasedFrameDecoder"></a>LengthFieldBasedFrameDecoder</h2><p>通用解码器，一般协议头中带有长度字段，通过使用LengthFieldBasedFrameDecoder传入特定的参数，来解决拆包粘包。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;粘包、半包&quot;&gt;&lt;a href=&quot;#粘包、半包&quot; class=&quot;headerlink&quot; title=&quot;粘包、半包&quot;&gt;&lt;/a&gt;粘包、半包&lt;/h1&gt;&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;在网络传输中，粘包和半包应该是最常出现的问题。&lt;/p&gt;
&lt;p&gt;TCP 传输中，客户端发送数据，实际是把数据写入到了 TCP 的缓存中，粘包和半包也就会在此时产生。&lt;/p&gt;
&lt;p&gt;客户端给服务端发送了两条消息&lt;code&gt;ABC&lt;/code&gt;和&lt;code&gt;DEF&lt;/code&gt;，服务端这边的接收会有多少种情况呢？有可能是一次性收到了所有的消息&lt;code&gt;ABCDEF&lt;/code&gt;，有可能是收到了三条消息&lt;code&gt;AB&lt;/code&gt;、&lt;code&gt;CD&lt;/code&gt;、&lt;code&gt;EF&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;上面所说的一次性收到了所有的消息&lt;code&gt;ABCDEF&lt;/code&gt;，类似于粘包。如果客户端发送的包的大小比 TCP 的缓存容量小，并且 TCP 缓存可以存放多个包，那么客户端和服务端的一次通信就可能传递了多个包，这时候服务端从 TCP 缓存就可能一下读取了多个包，这种现象就叫&lt;code&gt;粘包&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;上面说的后面那种收到了三条消息&lt;code&gt;AB&lt;/code&gt;、&lt;code&gt;CD&lt;/code&gt;、&lt;code&gt;EF&lt;/code&gt;，类似于半包。如果客户端发送的包的大小比 TCP 的缓存容量大，那么这个数据包就会被分成多个包，通过 Socket 多次发送到服务端，服务端第一次从接受缓存里面获取的数据，实际是整个包的一部分，这时候就产生了&lt;code&gt;半包&lt;/code&gt;(半包不是说只收到了全包的一半，是说收到了全包的一部分)。&lt;/p&gt;
    
    </summary>
    
    
      <category term="netty" scheme="http://blog.onebug.tech/categories/netty/"/>
    
    
      <category term="java" scheme="http://blog.onebug.tech/tags/java/"/>
    
      <category term="netty" scheme="http://blog.onebug.tech/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty的责任链</title>
    <link href="http://blog.onebug.tech/2021/09/05/java/netty/pipeline%E5%92%8CchannelHandler/"/>
    <id>http://blog.onebug.tech/2021/09/05/java/netty/pipeline%E5%92%8CchannelHandler/</id>
    <published>2021-09-04T16:00:00.000Z</published>
    <updated>2021-09-05T13:41:59.018Z</updated>
    
    <content type="html"><![CDATA[<p>为了避免逻辑判断泛滥导致的拓展性受限问题，Netty 发明了 <code>pipeline</code> 和 <code>channelHandler</code> 。它通过<strong>责任链设计模式</strong>来组织代码逻辑，并且能够支持逻辑的动态添加和删除 ，Netty 能够支持各类协议的扩展，比如 HTTP，WebSocket，Redis，靠的就是 <code>pipeline</code> 和 <code>channelHandler</code>。</p><a id="more"></a><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p><img src="http://image.onebug.tech/image-20210905211158604.png" alt="image-20210905211158604"></p><p>在 Netty 整个框架里面，一条连接对应着一个 <code>Channel</code>，这条 <code>Channel</code> 所有的处理逻辑都在一个叫做 <code>ChannelPipeline</code> 的对象里面，<code>ChannelPipeline</code> 是一个双向链表结构，他和 <code>Channel</code> 之间是一对一的关系。</p><p><code>ChannelPipeline</code> 里面每个节点都是一个 <code>ChannelHandlerContext</code> 对象，这个对象能够拿到和 Channel 相关的所有的上下文信息，然后这个对象包着一个重要的对象，那就是逻辑处理器 <code>ChannelHandler</code>。</p><h1 id="channelHandler-家族"><a href="#channelHandler-家族" class="headerlink" title="channelHandler 家族"></a>channelHandler 家族</h1><p><img src="http://image.onebug.tech/image-20210905211319568.png" alt="image-20210905211319568"></p><p>入站操作和数据由 <code>ChannelInboundHandler</code>处理。 在开始组装响应之前的所有的逻辑，都可以放置在 <code>ChannelInboundHandler</code> 里处理，它的一个最重要的方法就是 <code>channelRead()</code>。比如，我们在一端读到一段数据，首先要解析这段数据，然后对这些数据做一系列逻辑处理，最终把响应写到对端。</p><p>出站操作和数据将由<code>ChannelOutboundHandler</code> 处理。它是定义我们一端在组装完响应之后，把数据写到对端的逻辑，它里面最核心的一个方法就是 <code>write()</code>。比如，我们封装好一个 <code>response</code> 对象，接下来我们有可能对这个 <code>response</code> 做一些其他的特殊逻辑，然后，再编码成 <code>ByteBuf</code>，最终写到对端。</p><p>这两个子接口分别有对应的默认实现，<code>ChannelInboundHandlerAdapter</code>和 <code>ChanneloutBoundHandlerAdapter</code>，它们分别实现了两大接口的所有功能，默认情况下会把读写事件传播到下一个 <code>handler</code>。</p><h1 id="事件传播"><a href="#事件传播" class="headerlink" title="事件传播"></a>事件传播</h1><p>Netty通过<strong>责任链设计模式</strong>来组织代码逻辑，所谓的事件传播其实就是事件在<code>ChannelPipeline</code>上移动。</p><p>可以看到<code>ChannelPipeline</code>是由一系列<code>ChannelHandlers</code>组成，其还提供了通过自身传播事件的方法，<strong>当进站事件触发时，其从<code>ChannelPipeline</code>的头部传递到尾部，而出站事件会从右边传递到左边。</strong></p><p>当管道传播事件时，其会确定下一个<code>ChannelHandler</code>的类型是否与移动方向匹配，若不匹配，则会跳过并寻找下一个，直至找到相匹配的<code>ChannelHandler</code>（一个处理器可以会同时实现<code>ChannelInboundHandler</code>和<code>ChannelOutboundHandler</code>）。</p><p><img src="http://image.onebug.tech/616953-20170524202716435-790612436.png" alt="img"></p><p>关于<code>ChannelInboundHandler</code> 和<code>ChanneloutBoundHandler</code>的传播顺序的不同，可以看下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap</span><br><span class="line">        .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// inBound，处理读数据的逻辑链</span></span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> InBoundHandlerA());</span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> InBoundHandlerB());</span><br><span class="line">                </span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> OutBoundHandlerD());</span><br><span class="line"></span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> InBoundHandlerC());</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// outBound，处理写数据的逻辑链</span></span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> OutBoundHandlerE());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>在该例子中，<code>pipeline</code> 的执行顺序是：<code>InBoundHandlerA</code>-&gt;<code>InBoundHandlerB()</code>-&gt;<code>InBoundHandlerC()</code>-&gt;<code>OutBoundHandlerE()</code></p><blockquote><p><code>channelPipeline</code>是双向链表，<code>inBoundHandler</code> 的事件通常只会传播到下一个 <code>inBoundHandler</code>，<code>outBoundHandler</code> 的事件通常只会传播到下一个 <code>outBoundHandler</code>，两者相互不受干扰。</p></blockquote><p><code>inBoundHandler</code> 的执行顺序与我们实际的添加顺序相同，而 <code>outBoundHandler</code> 则相反。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了避免逻辑判断泛滥导致的拓展性受限问题，Netty 发明了 &lt;code&gt;pipeline&lt;/code&gt; 和 &lt;code&gt;channelHandler&lt;/code&gt; 。它通过&lt;strong&gt;责任链设计模式&lt;/strong&gt;来组织代码逻辑，并且能够支持逻辑的动态添加和删除 ，Netty 能够支持各类协议的扩展，比如 HTTP，WebSocket，Redis，靠的就是 &lt;code&gt;pipeline&lt;/code&gt; 和 &lt;code&gt;channelHandler&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="netty" scheme="http://blog.onebug.tech/categories/netty/"/>
    
    
      <category term="java" scheme="http://blog.onebug.tech/tags/java/"/>
    
      <category term="netty" scheme="http://blog.onebug.tech/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty的字节容器---ByteBuf</title>
    <link href="http://blog.onebug.tech/2021/09/04/java/netty/ByteBuf/"/>
    <id>http://blog.onebug.tech/2021/09/04/java/netty/ByteBuf/</id>
    <published>2021-09-03T16:00:00.000Z</published>
    <updated>2021-09-05T12:36:12.806Z</updated>
    
    <content type="html"><![CDATA[<p>网络数据的基本单位总是字节。Java NIO 提供了<code>ByteBuffer</code> 作为它的字节容器，但是这个类使用起来过于复杂，而且也有些繁琐。Netty 的<code>ByteBuffer</code> 替代品是<code>ByteBuf</code>，一个强大的实现，既解决了JDK API 的局限性，又为网络应用程序的开发者提供了更好的API。<code>ByteBuf</code>本质的原理就是引用了一段内存，这段内存可以是堆内也可以是堆外的，然后用引用计数来控制这段内存是否需要被释放，使用读写指针来控制对 <code>ByteBuf</code> 的读写，可以理解为是外观模式的一种使用。</p><a id="more"></a><h1 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h1><p><img src="http://image.onebug.tech/image-20210903174536572.png" alt="image-20210903174536572"></p><ul><li><p><code>ByteBuf</code> 是一个字节容器，容器里面的的数据分为三个部分，第一个部分是已经丢弃的字节，这部分数据是无效的；第二部分是可读字节，这部分数据是 <code>ByteBuf</code> 的主体数据， 从 <code>ByteBuf</code> 里面读取的数据都来自这一部分;最后一部分的数据是可写字节，所有写到 <code>ByteBuf</code> 的数据都会写到这一段。</p></li><li><p>以上三段内容是被两个指针给划分出来的，从左到右，依次是读指针（<code>readerIndex</code>）、写指针（<code>writerIndex</code>），然后还有一个变量 <code>capacity</code>，表示 <code>ByteBuf</code> 底层内存的总容量。</p></li><li><p>从 <code>ByteBuf</code> 中每读取一个字节，<code>readerIndex</code> 自增1，<code>ByteBuf</code> 里面总共有 <code>writerIndex-readerIndex</code> 个字节可读, 由此可以推论出当 <code>readerIndex</code> 与 <code>writerIndex</code> 相等的时候，<code>ByteBuf</code> 不可读。</p></li><li><p>写数据是从 <code>writerIndex</code> 指向的部分开始写，每写一个字节，<code>writerIndex</code> 自增1，直到增到 <code>capacity</code>，这个时候，表示 <code>ByteBuf</code> 已经不可写了</p></li></ul><blockquote><p><code>ByteBuf</code> 里面其实还有一个参数 <code>maxCapacity</code>，当向 <code>ByteBuf</code> 写数据的时候，如果容量不足，那么这个时候可以进行扩容，直到 <code>capacity</code> 扩容到 <code>maxCapacity</code>，超过 <code>maxCapacity</code> 就会报错</p></blockquote><h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><h2 id="容量"><a href="#容量" class="headerlink" title="容量"></a>容量</h2><table><thead><tr><th>名 称</th><th>描 述</th></tr></thead><tbody><tr><td>capacity()</td><td>表示 <code>ByteBuf</code> 底层占用了多少字节的内存（包括丢弃的字节、可读字节、可写字节）</td></tr><tr><td>maxCapacity()</td><td>表示 <code>ByteBuf</code> 底层最大能够占用多少字节的内存，当向 <code>ByteBuf</code> 中写数据的时候，如果发现容量不足，则进行扩容，直到扩容到 <code>maxCapacity</code>，超过这个数，就抛异常</td></tr><tr><td>readableBytes()</td><td>表示 ByteBuf 当前可读的字节数，它的值等于 <code>writerIndex-readerIndex</code>，如果两者相等，则不可读，<code>isReadable()</code> 方法返回 <code>false</code></td></tr><tr><td>writableBytes()</td><td><code>ByteBuf</code> 当前可写的字节数，它的值等于 capacity-writerIndex，如果两者相等，则表示不可写，<code>isWritable()</code> 返回 <code>false</code>，但是这个时候，并不代表不能往 <code>ByteBuf</code> 中写数据了， 如果发现往 <code>ByteBuf</code> 中写数据写不进去的话，Netty 会自动扩容 <code>ByteBuf</code>，直到扩容到底层的内存大小为 <code>maxCapacity</code>，而 <code>maxWritableBytes()</code> 就表示可写的最大字节数，它的值等于 <code>maxCapacity-writerIndex</code></td></tr></tbody></table><h2 id="索引管理"><a href="#索引管理" class="headerlink" title="索引管理"></a>索引管理</h2><table><thead><tr><th>名 称</th><th>描 述</th></tr></thead><tbody><tr><td>readerIndex()</td><td>返回当前的读指针</td></tr><tr><td>writeIndex()</td><td>返回当前的写指针</td></tr><tr><td>markReaderIndex()</td><td>把当前的读指针保存起来</td></tr><tr><td>resetReaderIndex()</td><td>把当前的读指针恢复到之前保存的值</td></tr></tbody></table><h2 id="读写操作"><a href="#读写操作" class="headerlink" title="读写操作"></a>读写操作</h2><p>有两种类别的读/写操作：</p><ul><li><code>get()</code>和<code>set()</code>操作，从给定的索引开始，并且保持索引不变；</li><li><code>read()</code>和<code>write()</code>操作，从给定的索引开始，并且会根据已经访问过的字节数对索引进行调整。</li></ul><p>基于读写指针和容量、最大可扩容容量，衍生出一系列的读写方法。其中比较重要的有：</p><table><thead><tr><th>名 称</th><th>描 述</th></tr></thead><tbody><tr><td>readByte()</td><td>返回当前<code>readerIndex</code> 处的字节，并将<code>readerIndex</code> 增加1（从 <code>ByteBuf</code> 中读取一个字节）</td></tr><tr><td>writeByte(int)</td><td>在当前<code>writerIndex</code> 处写入一个字节值，并将<code>writerIndex</code> 增加1（往 <code>ByteBuf</code> 中写一个字节）</td></tr><tr><td>readBytes(destination byte[])</td><td>把 <code>ByteBuf</code> 里面的数据全部读取到 <code>destination</code>（<code>ByteBuf</code>-&gt;<code>destination</code>）</td></tr><tr><td>writeBytes(source byte[])</td><td>把字节数组 <code>source</code> 里面的数据写到 <code>ByteBuf</code>（<code>source</code>-&gt;<code>ByteBuf</code>）</td></tr></tbody></table><p>类似的 API 还有 <code>writeBoolean()</code>、<code>writeChar()</code>、<code>writeShort()</code>、<code>writeInt()</code>、<code>writeLong()</code>、<code>writeFloat()</code>、<code>writeDouble()</code> 与 <code>readBoolean()</code>、<code>readChar()</code>、<code>readShort()</code>、<code>readInt()</code>、<code>readLong()</code>、<code>readFloat()</code>、<code>readDouble()</code> ，这里就不一一赘述了。</p><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>由于 Netty 可以使用堆外内存，而堆外内存是不被 <code>jvm</code> 直接管理的，也就是说申请到的内存无法被垃圾回收器直接回收，所以需要我们手动回收，否则会造成内存泄漏。Netty 的 <code>ByteBuf</code> 是通过<strong>引用计数</strong>的方式管理的，如果一个 <code>ByteBuf</code> 没有地方被引用到，需要回收底层内存。默认情况下，当创建完一个 <code>ByteBuf</code>，它的引用为1，然后每次调用 <code>retain()</code> 方法， 它的引用就<code>+1</code>， release() 方法原理是将引用计数<code>-1</code>，减完之后如果发现引用计数为0，则直接回收 <code>ByteBuf</code> 底层的内存。</p><h2 id="池化"><a href="#池化" class="headerlink" title="池化"></a>池化</h2><p>为了降低分配和释放内存的开销，Netty 通过 <code>ByteBufAllocator</code> 实现了<code>ByteBuf</code> 的池化，它可以用来分配我们所描述过的任意类型的<code>ByteBuf</code> 实例（直接内存、堆内存）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从Channel 获取一个到 ByteBufAllocator 的引用</span></span><br><span class="line">ByteBufAllocator allocator = channel.alloc();</span><br><span class="line"></span><br><span class="line"><span class="comment">//从ChannelHandlerContext 获取一个到ByteBufAllocator 的引用</span></span><br><span class="line">ByteBufAllocator allocator2 = ctx.alloc();</span><br></pre></td></tr></table></figure><p>一般使用<code>buffer(int initialCapacity, int maxCapacity);</code>返回一个基于堆或者直接内存存储的<code>ByteBuf</code>。</p><h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p><code>slice()</code>、<code>duplicate()</code>、<code>copy()</code>三者的返回值都是一个新的 <code>ByteBuf</code> 对象：</p><ul><li><p><code>slice()</code> 方法从原始 <code>ByteBuf</code> 中截取一段，这段数据是从 <code>readerIndex</code> 到 <code>writeIndex</code>，同时，返回的新的 <code>ByteBuf</code> 的最大容量 <code>maxCapacity</code> 为原始 <code>ByteBuf</code> 的 <code>readableBytes()</code></p></li><li><p><code>duplicate()</code> 方法把整个 <code>ByteBuf</code> 都截取出来，包括所有的数据，指针信息</p><blockquote><p><code>slice()</code> 方法与 <code>duplicate()</code> 方法不会拷贝数据，它们只是通过改变读写指针来改变读写的行为。底层内存以及引用计数与原始的 <code>ByteBuf</code> 共享，也就是说返回的 <code>ByteBuf</code> 调用 <code>write</code> 系列方法都会影响到原始的 <code>ByteBuf</code>，但是它们都维持着与原始 <code>ByteBuf</code> 不同的读写指针。</p></blockquote></li><li><p><code>copy()</code> 会直接从原始的 <code>ByteBuf</code> 中拷贝所有的信息，包括读写指针以及<strong>底层对应的数据</strong>，因此， <code>copy()</code> 返回的 <code>ByteBuf</code> 中写数据不会影响到原始的 <code>ByteBuf</code></p></li><li><p><code>retainedSlice()</code> 与 <code>retainedDuplicate()</code>它们的作用是在截取内存片段的同时，增加内存的引用计数。</p></li></ul><p>多个 <code>ByteBuf</code> 可以引用同一段内存，而Netty会通过引用计数来控制内存的释放，应当遵循谁 <code>retain()</code> 谁 <code>release()</code> 的原则。我们建议，在一个函数体里面，只要增加了引用计数（包括 <code>ByteBuf</code> 的创建和手动调用 <code>retain()</code> 方法），就必须调用 <code>release()</code> 方法，否则往往会出现内存泄露的问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网络数据的基本单位总是字节。Java NIO 提供了&lt;code&gt;ByteBuffer&lt;/code&gt; 作为它的字节容器，但是这个类使用起来过于复杂，而且也有些繁琐。Netty 的&lt;code&gt;ByteBuffer&lt;/code&gt; 替代品是&lt;code&gt;ByteBuf&lt;/code&gt;，一个强大的实现，既解决了JDK API 的局限性，又为网络应用程序的开发者提供了更好的API。&lt;code&gt;ByteBuf&lt;/code&gt;本质的原理就是引用了一段内存，这段内存可以是堆内也可以是堆外的，然后用引用计数来控制这段内存是否需要被释放，使用读写指针来控制对 &lt;code&gt;ByteBuf&lt;/code&gt; 的读写，可以理解为是外观模式的一种使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="netty" scheme="http://blog.onebug.tech/categories/netty/"/>
    
    
      <category term="java" scheme="http://blog.onebug.tech/tags/java/"/>
    
      <category term="ByteBuf" scheme="http://blog.onebug.tech/tags/ByteBuf/"/>
    
      <category term="netty" scheme="http://blog.onebug.tech/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>JAVA NIO</title>
    <link href="http://blog.onebug.tech/2021/05/08/java/javaIO/java%20NIO%E4%B8%8ESelector/"/>
    <id>http://blog.onebug.tech/2021/05/08/java/javaIO/java%20NIO%E4%B8%8ESelector/</id>
    <published>2021-05-07T16:00:00.000Z</published>
    <updated>2021-05-08T09:56:19.424Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JAVA-NIO"><a href="#JAVA-NIO" class="headerlink" title="JAVA NIO"></a>JAVA NIO</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java NIO 由以下几个核心部分组成：</p><ul><li>Channels</li><li>Buffers</li><li>Selectors</li></ul><p>虽然Java NIO 中除此之外还有很多类和组件，但在我看来，Channel，Buffer 和 Selector 构成了核心的API。其它组件，如Pipe和FileLock，只不过是与三个核心组件共同使用的工具类。</p><p>基本上，所有的 IO 在NIO 中都从一个Channel 开始。Channel，国内大多翻译成“通道”，有点像流。 不同的是，数据可以从Channel读到Buffer中，也可以从Buffer 写到Channel中。</p><p>Selector允许单线程处理多个 Channel。如果你的应用打开了多个连接（通道），但每个连接的流量都很低，使用Selector就会很方便。</p><a id="more"></a><h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><p><strong>发送给一个通道的所有数据都必须首先放到缓冲区中，同样地，从通道中读取的任何数据都要先读到缓冲区中</strong>。也就是说，不会直接对通道进行读写数据，而是要先经过缓冲区。缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问该块内存。</p><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>Java NIO 有以下Buffer类型</p><ul><li>ByteBuffer</li><li>MappedByteBuffer</li><li>CharBuffer</li><li>DoubleBuffer</li><li>FloatBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>ShortBuffer</li></ul><p>这些Buffer类型代表了不同的数据类型。换句话说，就是可以通过char，short，int，long，float 或 double类型来操作缓冲区中的字节。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p><strong>基本用法</strong></p><p>使用Buffer读写数据一般遵循以下四个步骤：</p><ol><li><p>写入数据到Buffer</p></li><li><p>调用<code>flip()</code>方法，从写模式切换到读模式，在读模式下，可以读取之前写入到buffer的所有数据。</p></li><li><p>从Buffer中读取数据</p></li><li><p>调用<code>clear()</code>方法或者<code>compact()</code>方法，清空缓冲区</p><blockquote><p>clear()方法会清空整个缓冲区。compact()方法只会清除已经读过的数据。任何未读的数据都被移到缓冲区的起始处，新写入的数据将放到缓冲区未读数据的后面。</p></blockquote></li></ol><p><strong>Buffer的分配</strong></p><p>要想获得一个Buffer对象首先要进行分配。 每一个Buffer类都有一个allocate方法。下面是一个分配48字节capacity的ByteBuffer的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br></pre></td></tr></table></figure><p><strong>向Buffer中写入数据</strong></p><p>写数据到Buffer有两种方式：</p><ul><li><p>从Channel写到Buffer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> bytesRead = inChannel.read(buf); <span class="comment">//read into buffer.</span></span><br></pre></td></tr></table></figure></li><li><p>通过Buffer的put()方法写到Buffer里，put方法有很多版本，允许你以不同的方式把数据写入到Buffer中。例如， 写到一个指定的位置，或者把一个字节数组写入到Buffer。 更多Buffer实现的细节参考JavaDoc。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.put(<span class="number">127</span>);</span><br></pre></td></tr></table></figure></li></ul><p><strong>读取数据</strong></p><p>从Buffer中读取数据有两种方式：</p><ul><li>从Buffer读取数据到Channel。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//read from buffer into channel.</span></span><br><span class="line"><span class="keyword">int</span> bytesWritten = inChannel.write(buf);</span><br></pre></td></tr></table></figure><ul><li>使用get()方法从Buffer中读取数据，get方法有很多版本，允许你以不同的方式从Buffer中读取数据。例如，从指定position读取，或者从Buffer中读取数据到字节数组。更多Buffer实现的细节参考JavaDoc。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> aByte = buf.get();</span><br></pre></td></tr></table></figure><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>Buffer简单地理解为一组基本数据类型的元素列表，它通过几个变量来保存这个数据的当前位置状态：</p><table><thead><tr><th><strong>索引</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>capacity</td><td>缓冲区数组的总长度</td></tr><tr><td>position</td><td>下一个要操作的数据元素的位置</td></tr><tr><td>limit</td><td>缓冲区数组中不可操作的下一个元素的位置：limit&lt;=capacity</td></tr></tbody></table><p>状态变量的改变过程举例：</p><p>① 通过<code>ByteBuffer.allocate(8)</code>新建一个大小为 8 个字节的缓冲区，此时 position 为 0，而 limit = capacity = 8。capacity 变量不会改变，下面的讨论会忽略它。</p><p><img src="http://image.onebug.tech/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f31626561333938662d313761372d346636372d613930622d3965326432343365616139612e706e67" alt="img"></p><p>② 从输入通道中读取 5 个字节数据写入缓冲区中，此时 position 为 5，limit 保持不变。</p><p><img src="http://image.onebug.tech/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38303830346635322d383831352d343039362d623530362d3438656566336565643563362e706e67" alt="img"></p><p>③ 在将缓冲区的数据写到输出通道之前，需要先调用 flip() 方法，这个方法将 limit 设置为当前 position，并将 position 设置为 0。</p><p><img src="http://image.onebug.tech/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39353265303662642d356136352d346361622d383265342d6464313533363436326633382e706e67" alt="img"></p><p>④ 从缓冲区中取 4 个字节到输出缓冲中，此时 position 设为 4。</p><p><img src="http://image.onebug.tech/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f62356264636265322d623935382d346165662d393135312d3661643936336362323862342e706e67" alt="img"></p><p>⑤ 最后需要调用 clear() 方法来清空缓冲区，此时 position 和 limit 都被设置为最初位置。</p><p><img src="http://image.onebug.tech/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36376266353438372d633435642d343962362d623963302d6130353864386336383930322e706e67" alt="img"></p><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>Java NIO的通道类似流，但又有些不同：</p><ul><li>既可以从通道中读取数据，又可以写数据到通道。但流的读写通常是单向的。</li><li>通道可以异步地读写。</li><li>通道中的数据总是要先读到一个Buffer，或者总是要从一个Buffer中写入。</li></ul><p>正如上面所说，从通道读取数据到缓冲区，从缓冲区写入数据到通道。如下图所示：</p><p><img src="http://image.onebug.tech/overview-channels-buffers.png" alt="img"></p><p>这些是Java NIO中最重要的通道的实现：</p><ul><li>FileChannel 从文件中读写数据</li><li>DatagramChannel 能通过UDP读写网络中的数据</li><li>SocketChannel  能通过TCP读写网络中的数据</li><li>ServerSocketChannel 可以监听新进来的TCP连接，像Web服务器那样。对每一个新进来的连接都会创建一个SocketChannel</li></ul><h3 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h3><p>Java NIO中的FileChannel是一个连接到文件的通道。可以通过文件通道读写文件。FileChannel无法设置为非阻塞模式，它总是运行在阻塞模式下。</p><p><strong>打开</strong></p><p>在使用FileChannel之前，必须先打开它。但是，我们无法直接打开一个FileChannel，需要通过使用一个InputStream、OutputStream或RandomAccessFile来获取一个FileChannel实例。下面是通过RandomAccessFile打开FileChannel的示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile aFile &#x3D; new RandomAccessFile(&quot;data&#x2F;nio-data.txt&quot;, &quot;rw&quot;);</span><br><span class="line">FileChannel inChannel &#x3D; aFile.getChannel();</span><br></pre></td></tr></table></figure><p><strong>读取</strong></p><p>打开FileChannel后，调用多个read()方法之一从FileChannel中读取数据。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line"><span class="keyword">int</span> bytesRead = inChannel.read(buf);</span><br></pre></td></tr></table></figure><p>首先，分配一个Buffer。从FileChannel中读取的数据将被读到Buffer中。然后，调用<code>FileChannel.read()</code>方法。该方法将数据从FileChannel读取到Buffer中。<strong>read()方法返回的int值表示了有多少字节被读到了Buffer中</strong>。如果返回<strong>-1，表示到了文件末尾</strong>。</p><p><strong>写入</strong></p><p>使用<code>FileChannel.write()</code>方法向FileChannel写数据，该方法的参数是一个Buffer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String newData = <span class="string">"New String to write to file..."</span> + System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">buf.clear();</span><br><span class="line">buf.put(newData.getBytes());</span><br><span class="line"></span><br><span class="line">buf.flip();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(buf.hasRemaining()) &#123;</span><br><span class="line">channel.write(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意<code>FileChannel.write()</code>是在while循环中调用的。因为无法保证write()方法一次能向FileChannel写入多少字节，因此需要重复调用write()方法，直到Buffer中已经没有尚未写入通道的字节。</p><p><strong>读文件示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nioReadFile</span><span class="params">()</span></span>&#123;</span><br><span class="line">       RandomAccessFile file = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">try</span>&#123;</span><br><span class="line">           aFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"test.txt"</span>,<span class="string">"rw"</span>);</span><br><span class="line">           FileChannel fileChannel = aFile.getChannel();</span><br><span class="line">           ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">           <span class="keyword">int</span> bytesRead = fileChannel.read(buf);</span><br><span class="line">           System.out.println(bytesRead);</span><br><span class="line">           <span class="keyword">while</span>(bytesRead != -<span class="number">1</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               buf.flip();</span><br><span class="line">               <span class="keyword">while</span>(buf.hasRemaining())</span><br><span class="line">               &#123;</span><br><span class="line">                   System.out.print((<span class="keyword">char</span>)buf.get());</span><br><span class="line">               &#125;</span><br><span class="line">               buf.compact();</span><br><span class="line">               bytesRead = fileChannel.read(buf);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">           <span class="keyword">try</span>&#123;</span><br><span class="line">               <span class="keyword">if</span>(aFile != <span class="keyword">null</span>)&#123;</span><br><span class="line">                   aFile.close();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h3><p>Java NIO中的SocketChannel是一个连接到TCP网络套接字的通道。</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p><strong>打开</strong></p><p>可以通过以下2种方式创建SocketChannel：</p><ul><li><p>打开一个SocketChannel并连接到互联网上的某台服务器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">8081</span>));</span><br></pre></td></tr></table></figure></li><li><p>一个新连接到达ServerSocketChannel时，会创建一个SocketChannel。</p></li></ul><p><strong>从 SocketChannel 读取数据</strong></p><p>要从SocketChannel中读取数据，和FileChannel一样，需要结合Buffer使用，调用read()的方法。以下是例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line"><span class="keyword">int</span> bytesRead = socketChannel.read(buf);</span><br></pre></td></tr></table></figure><p><strong>写入 SocketChannel</strong></p><p>写数据到SocketChannel用的是<code>SocketChannel.write()</code>方法，该方法以一个Buffer作为参数。示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String newData = <span class="string">"New String to write to file..."</span> + System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">buf.clear();</span><br><span class="line">buf.put(newData.getBytes());</span><br><span class="line"></span><br><span class="line">buf.flip();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(buf.hasRemaining()) &#123;</span><br><span class="line">    channel.write(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关闭</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socketChannel.close();</span><br></pre></td></tr></table></figure><h4 id="非阻塞模式"><a href="#非阻塞模式" class="headerlink" title="非阻塞模式"></a>非阻塞模式</h4><p>NIO的强大功能部分来自于Channel的非阻塞特性，套接字的某些操作可能会无限期地阻塞。例如，对accept()方法的调用可能会因为等待一个客户端连接而阻塞；对read()方法的调用可能会因为没有数据可读而阻塞，直到连接的另一端传来新的数据。总的来说，创建/接收连接或读写数据等I/O调用，都可能无限期地阻塞等待，直到底层的网络实现发生了什么。慢速的，有损耗的网络，或仅仅是简单的网络故障都可能导致任意时间的延迟。然而不幸的是，在调用一个方法之前无法知道其是否阻塞。NIO的channel抽象的一个重要特征就是可以通过配置它的阻塞行为，以实现非阻塞式的信道。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.configureBlocking(false)</span><br></pre></td></tr></table></figure><p>在非阻塞式信道上调用一个方法总是会立即返回。这种调用的返回值指示了所请求的操作完成的程度：</p><ul><li>非阻塞模式下，write()方法在尚未写出任何内容时可能就返回了。所以需要在循环中调用write()。</li><li>非阻塞模式下,read()方法在尚未读取到任何数据时可能就返回了。所以需要关注它的int返回值，它会告诉你读取了多少字节。</li><li>在非阻塞模式下，调用connect()，该方法可能在连接建立之前就返回了。为了确定连接是否建立，可以调用<code>finishConnect()</code>的方法。</li></ul><p>非阻塞模式与选择器搭配会工作的更好，通过将一或多个SocketChannel注册到Selector，可以询问选择器哪个通道已经准备好了读取，写入等。</p><p><strong>NIO客户端</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">client</span><span class="params">()</span></span>&#123;</span><br><span class="line">       ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">       SocketChannel socketChannel = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">try</span></span><br><span class="line">       &#123;</span><br><span class="line">           socketChannel = SocketChannel.open();</span><br><span class="line">           socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">           socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"10.10.195.115"</span>,<span class="number">8080</span>));</span><br><span class="line">           <span class="keyword">if</span>(socketChannel.finishConnect())</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">               <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">               &#123;</span><br><span class="line">                   TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                   String info = <span class="string">"I'm "</span>+i+++<span class="string">"-th information from client"</span>;</span><br><span class="line">                   buffer.clear();</span><br><span class="line">                   buffer.put(info.getBytes());</span><br><span class="line">                   buffer.flip();</span><br><span class="line">                   <span class="keyword">while</span>(buffer.hasRemaining())&#123;</span><br><span class="line">                       System.out.println(buffer);</span><br><span class="line">                       socketChannel.write(buffer);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">catch</span> (IOException | InterruptedException e)</span><br><span class="line">       &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">finally</span>&#123;</span><br><span class="line">           <span class="keyword">try</span>&#123;</span><br><span class="line">               <span class="keyword">if</span>(socketChannel!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                   socketChannel.close();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="ServerSocketChannel"><a href="#ServerSocketChannel" class="headerlink" title="ServerSocketChannel"></a>ServerSocketChannel</h3><p>Java NIO中的 ServerSocketChannel 是一个可以监听新进来的TCP连接的通道, 就像标准IO中的ServerSocket一样。</p><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p><strong>打开 ServerSocketChannel</strong></p><p>通过调用 <code>ServerSocketChannel.open()</code> 方法来打开ServerSocketChannel.如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9999</span>));</span><br></pre></td></tr></table></figure><p><strong>监听连接</strong></p><p>通过 <code>ServerSocketChannel.accept()</code> 方法监听新进来的连接。当 accept()方法返回的时候,它返回一个包含新进来的连接的 SocketChannel。因此, accept()方法会一直阻塞到有新连接到达。</p><p>通常不会仅仅只监听一个连接,在while循环中调用 accept()方法. 如下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    SocketChannel socketChannel =</span><br><span class="line">            serverSocketChannel.accept();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//do something with socketChannel...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServerSocketChannel可以设置成非阻塞模式。在非阻塞模式下，accept() 方法会立刻返回，如果还没有新进来的连接,返回的将是null。 因此，需要检查返回的SocketChannel是否是null.如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9999</span>));</span><br><span class="line">serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    SocketChannel socketChannel =</span><br><span class="line">            serverSocketChannel.accept();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(socketChannel != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//do something with socketChannel...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关闭 ServerSocketChannel</strong></p><p>通过调用<code>ServerSocketChannel.close()</code> 方法来关闭</p><h2 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h2><p>对于操作系统来说，线程之间上下文切换的开销很大，而且每个线程都要占用系统的一些资源（如内存）。Selector（选择器）能够检测一到多个NIO通道，并能够知晓通道是否为诸如读写事件做好准备的组件。一个单独的线程可以管理多个channel，从而管理多个网络连接。Selector类可以用于避免使用阻塞式客户端中很浪费资源的“忙等”方法。</p><p><img src="http://image.onebug.tech/overview-selectors.png" alt="img"></p><h3 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h3><p><strong>创建</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure><p><strong>向Selector注册通道</strong><br>为了将Channel和Selector配合使用，必须将channel注册到selector上。通过<code>SelectableChannel.register()</code>方法来实现，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">SelectionKey key = channel.register(selector,Selectionkey.OP_READ);</span><br></pre></td></tr></table></figure><p>与Selector一起使用时，Channel必须处于非阻塞模式下。这意味着不能将FileChannel与Selector一起使用，因为FileChannel不能切换到非阻塞模式。而套接字通道都可以。</p><p>注意register()方法的第二个参数。这是一个“interest集合”，意思是在通过Selector监听Channel时对什么事件感兴趣。通道触发了一个事件意思是该事件已经就绪，可以监听四种不同类型的事件：</p><ul><li><code>SelectionKey.OP_CONNECT</code> ： 某个channel成功连接到另一个服务器称为“连接就绪”</li><li><code>SelectionKey.OP_ACCEPT</code>：一个ServerSocketchannel准备好接收新进入的连接称为“接收就绪”。</li><li><code>SelectionKey.OP_READ</code>：一个有数据可读的通道可以说是“读就绪”。</li><li><code>SelectionKey.OP_WRITE</code>：等待写数据的通道可以说是“写就绪”。</li></ul><p>如果你对不止一种事件感兴趣，那么可以用“位或”操作符将常量连接起来，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure><p><strong>通过Selector选择通道</strong></p><p>一旦向Selector注册了一或多个通道，就可以调用几个重载的select()方法。这些方法返回你所感兴趣的事件（如连接、接受、读或写）已经准备就绪的那些通道。换句话说，如果你对“读就绪”的通道感兴趣，select()方法会返回读事件已经就绪的那些通道。</p><ul><li>int select()：阻塞到至少有一个通道在你注册的事件上就绪了。</li><li>int select(long timeout)：和select()一样，除了最长会阻塞timeout毫秒(参数)。</li><li>int selectNow()：不会阻塞，不管什么通道就绪都立刻返回</li></ul><p><strong>获取已选择键值</strong></p><p>一旦调用了select()方法，并且返回值表明有一个或更多个通道就绪了，然后可以通过调用selector的<code>selectedKeys()</code>方法，访问“已选择键集（selected key set）”中的就绪通道。如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set selectedKeys = selector.selectedKeys();</span><br></pre></td></tr></table></figure><p>当像Selector注册Channel时，<code>Channel.register()</code>方法会返回一个SelectionKey 对象。这个对象代表了注册到该Selector的通道（token）。可以通过SelectionKey的selectedKeySet()方法访问这些对象。</p><p>可以遍历这个已选择的键集合来访问就绪的通道。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Set selectedKeys = selector.selectedKeys();</span><br><span class="line">Iterator keyIterator = selectedKeys.iterator();</span><br><span class="line"><span class="keyword">while</span>(keyIterator.hasNext()) &#123;</span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line">    <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was accepted by a ServerSocketChannel.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was established with a remote server.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for reading</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for writing</span></span><br><span class="line">    &#125;</span><br><span class="line">    keyIterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个循环遍历已选择键集中的每个键，并检测各个键所对应的通道的就绪事件。注意每次迭代末尾的<code>keyIterator.remove()</code>调用。Selector不会自己从已选择键集中移除SelectionKey实例。必须在处理完通道时自己移除，否则下次该通道变成就绪时，Selector会再次将其放入已选择键集中。</p><h3 id="SelectionKey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a>SelectionKey</h3><p>当向Selector注册Channel时，register()方法会返回一个SelectionKey对象，代表SelectableChannel与Selector的注册的token。这个对象包含了一些属性：</p><ul><li>interest集合</li><li>ready集合</li><li>Channel</li><li>Selector</li><li>附加的对象（可选）</li></ul><p><strong>interest</strong></p><p>interest集合是你所选择的感兴趣的事件集合。可以通过SelectionKey读写interest集合，像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interestSet = selectionKey.interestOps();</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInConnect = interestSet &amp; SelectionKey.OP_CONNECT;</span><br></pre></td></tr></table></figure><p><strong>ready集合</strong></p><p>ready 集合是通道已经准备就绪的操作的集合。在一次选择(Selection)之后，你会首先访问这个ready set。Selection将在下一小节进行解释。可以这样访问ready集合：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int readySet &#x3D; selectionKey.readyOps();</span><br></pre></td></tr></table></figure><p>可以用像检测interest集合那样的方法，来检测channel中什么事件或操作已经就绪。但是，也可以使用以下四个方法，它们都会返回一个布尔类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">selectionKey.isAcceptable();</span><br><span class="line">selectionKey.isConnectable();</span><br><span class="line">selectionKey.isReadable();</span><br><span class="line">selectionKey.isWritable();</span><br></pre></td></tr></table></figure><p><strong>Channel、Selector</strong></p><p>从SelectionKey访问对应的Channel和Selector很简单。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Channel  channel  = selectionKey.channel();</span><br><span class="line">Selector selector = selectionKey.selector();</span><br></pre></td></tr></table></figure><p><strong>附加对象</strong></p><p>可以将一个对象或者更多信息附着到SelectionKey上，这样就能方便的识别某个给定的通道。例如，可以附加 与通道一起使用的Buffer，或是包含聚集数据的某个对象。使用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">selectionKey.attach(theObject);</span><br><span class="line">Object attachedObj = selectionKey.attachment();</span><br></pre></td></tr></table></figure><p>还可以在用register()方法向Selector注册Channel的时候附加对象。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ, theObject);</span><br></pre></td></tr></table></figure><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerConnect</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUF_SIZE=<span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">8080</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIMEOUT = <span class="number">3000</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        selector();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleAccept</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        ServerSocketChannel ssChannel = (ServerSocketChannel)key.channel();</span><br><span class="line">        SocketChannel sc = ssChannel.accept();</span><br><span class="line">        sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        sc.register(key.selector(), SelectionKey.OP_READ,ByteBuffer.allocateDirect(BUF_SIZE));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleRead</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        SocketChannel sc = (SocketChannel)key.channel();</span><br><span class="line">        ByteBuffer buf = (ByteBuffer)key.attachment();</span><br><span class="line">        <span class="keyword">long</span> bytesRead = sc.read(buf);</span><br><span class="line">        <span class="keyword">while</span>(bytesRead&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            buf.flip();</span><br><span class="line">            <span class="keyword">while</span>(buf.hasRemaining())&#123;</span><br><span class="line">                System.out.print((<span class="keyword">char</span>)buf.get());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            buf.clear();</span><br><span class="line">            bytesRead = sc.read(buf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(bytesRead == -<span class="number">1</span>)&#123;</span><br><span class="line">            sc.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleWrite</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        ByteBuffer buf = (ByteBuffer)key.attachment();</span><br><span class="line">        buf.flip();</span><br><span class="line">        SocketChannel sc = (SocketChannel) key.channel();</span><br><span class="line">        <span class="keyword">while</span>(buf.hasRemaining())&#123;</span><br><span class="line">            sc.write(buf);</span><br><span class="line">        &#125;</span><br><span class="line">        buf.compact();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Selector selector = <span class="keyword">null</span>;</span><br><span class="line">        ServerSocketChannel ssc = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            ssc= ServerSocketChannel.open();</span><br><span class="line">            ssc.socket().bind(<span class="keyword">new</span> InetSocketAddress(PORT));</span><br><span class="line">            ssc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(selector.select(TIMEOUT) == <span class="number">0</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"=="</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();</span><br><span class="line">                <span class="keyword">while</span>(iter.hasNext())&#123;</span><br><span class="line">                    SelectionKey key = iter.next();</span><br><span class="line">                    <span class="keyword">if</span>(key.isAcceptable())&#123;</span><br><span class="line">                        handleAccept(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">                        handleRead(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(key.isWritable() &amp;&amp; key.isValid())&#123;</span><br><span class="line">                        handleWrite(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(key.isConnectable())&#123;</span><br><span class="line">                        System.out.println(<span class="string">"isConnectable = true"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    iter.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(selector!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    selector.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(ssc!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    ssc.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JAVA-NIO&quot;&gt;&lt;a href=&quot;#JAVA-NIO&quot; class=&quot;headerlink&quot; title=&quot;JAVA NIO&quot;&gt;&lt;/a&gt;JAVA NIO&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Java NIO 由以下几个核心部分组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Channels&lt;/li&gt;
&lt;li&gt;Buffers&lt;/li&gt;
&lt;li&gt;Selectors&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;虽然Java NIO 中除此之外还有很多类和组件，但在我看来，Channel，Buffer 和 Selector 构成了核心的API。其它组件，如Pipe和FileLock，只不过是与三个核心组件共同使用的工具类。&lt;/p&gt;
&lt;p&gt;基本上，所有的 IO 在NIO 中都从一个Channel 开始。Channel，国内大多翻译成“通道”，有点像流。 不同的是，数据可以从Channel读到Buffer中，也可以从Buffer 写到Channel中。&lt;/p&gt;
&lt;p&gt;Selector允许单线程处理多个 Channel。如果你的应用打开了多个连接（通道），但每个连接的流量都很低，使用Selector就会很方便。&lt;/p&gt;
    
    </summary>
    
    
      <category term="javaio" scheme="http://blog.onebug.tech/categories/javaio/"/>
    
    
      <category term="java" scheme="http://blog.onebug.tech/tags/java/"/>
    
      <category term="网络编程" scheme="http://blog.onebug.tech/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
      <category term="NIO" scheme="http://blog.onebug.tech/tags/NIO/"/>
    
      <category term="Selector" scheme="http://blog.onebug.tech/tags/Selector/"/>
    
  </entry>
  
  <entry>
    <title>java UDP网络编程</title>
    <link href="http://blog.onebug.tech/2021/05/08/java/javaIO/java%20UDP/"/>
    <id>http://blog.onebug.tech/2021/05/08/java/javaIO/java%20UDP/</id>
    <published>2021-05-07T16:00:00.000Z</published>
    <updated>2021-05-08T09:58:08.703Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><p>在 TCP/IP 协议的传输层除了一个 TCP 协议之外，还有一个 UDP 协议。UDP 协议是用户数据报协议的简称，也用于网络数据的传输。虽然 UDP 协议是一种不太可靠的协议，但有时在需要较快地接收数据并且可以忍受较小错误的情况下，UDP 就会表现出更大的优势。</p><p>下面是在 <a href="http://c.biancheng.net/java/" target="_blank" rel="noopener">Java</a> 中使用 UDP 协议发送数据的步骤。</p><ol><li>使用 DatagramSocket() 创建一个数据包套接字。</li><li>使用 DatagramPacket() 创建要发送的数据包。</li><li>使用 DatagramSocket 类的 send() 方法发送数据包。</li></ol><p>接收 UDP 数据包的步骤如下：</p><ul><li>使用 DatagramSocket 创建数据包套接字，并将其绑定到指定的端口。</li><li>使用 DatagramPacket 创建字节数组来接收数据包。</li><li>使用 DatagramPacket 类的 receive() 方法接收 UDP 包。</li></ul><a id="more"></a><h2 id="DatagramPacket-类"><a href="#DatagramPacket-类" class="headerlink" title="DatagramPacket 类"></a>DatagramPacket 类</h2><p>java.net 包中的 DatagramPacket 类用来表示数据报包，数据报包用来实现无连接包投递服务。每条报文仅根据该包中包含的信息从一台机器路由到另一台机器。从一台机器发送到另一台机器的多个包可能选择不同的路由，也可能按不同的顺序到达。</p><table><thead><tr><th>构造方法</th><th>说明</th></tr></thead><tbody><tr><td>DatagramPacket(byte[] buf,int length)</td><td>构造 DatagramPacket，用来接收长度为 length 的数据包。</td></tr><tr><td>DatagramPacket(byte[] buf,int offset, int length)</td><td>构造 DatagramPacket，用来接收长度为 length 的包，在缓 冲区中指定了偏移量。</td></tr><tr><td>DatagramPacket(byte[] buf,int length, InetAddress address,int port)</td><td>构造 DatagramPacket，用来将长度为 length 的包发送到指定主机上的指定端口。</td></tr><tr><td>DatagramPacket(byte[] buf,int length, SocketAddress address)</td><td>构造数据报包，用来将长度为 length 的包发送到指定主机上 的指定端口。</td></tr><tr><td>DatagramPacket(byte[] buf,int offset, int length,InetAddress address,int port)</td><td>构造 DatagramPacket，用来将长度为 length 偏移量为 offset 的包发送到指定主机上的指定端口。</td></tr><tr><td>DatagramPacket(byte[] buf,int offset, int length,SocketAddress address)</td><td>构造数据报包，用来将长度为 length、偏移量为 offset 的包发 送到指定主机上的指定端口。</td></tr></tbody></table><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>InetAddress getAddress()</td><td>返回某台机器的 IP 地址，此数据报将要发往该机器或者 从该机器接收。</td></tr><tr><td>byte[] getData()</td><td>返回数据缓冲区。</td></tr><tr><td>int getLength()</td><td>返回将要发送或者接收的数据的长度。</td></tr><tr><td>int getOffset()</td><td>返回将要发送或者接收的数据的偏移量。</td></tr><tr><td>int getPort()</td><td>返回某台远程主机的端口号，此数据报将要发往该主机或 者从该主机接收。</td></tr><tr><td>getSocketAddress()</td><td>获取要将此包发送或者发出此数据报的远程主机的 SocketAddress（通常为 IP地址+端口号）。</td></tr><tr><td>void setAddress(InetAddress addr)</td><td>设置要将此数据报发往的目的机器的IP地址。</td></tr><tr><td>void setData(byte[] buf)</td><td>为此包设置数据缓冲区。</td></tr><tr><td>void setData(byte[] buf,int offset, int length)</td><td>为此包设置数据缓冲区。</td></tr><tr><td>void setLength(int length)</td><td>为此包设置长度。</td></tr><tr><td>void setPort(int port)</td><td>设置要将此数据报发往的远程主机的端口号。</td></tr><tr><td>void setSocketAddress(SocketAddress address)</td><td>设置要将此数据报发往的远程主机的 SocketAddress（通常为 IP地址+端口号）。</td></tr></tbody></table><h2 id="DatagramSocket-类"><a href="#DatagramSocket-类" class="headerlink" title="DatagramSocket 类"></a>DatagramSocket 类</h2><p>DatagramSocket 类用于表示发送和接收数据报包的套接字。数据报包套接字是包投递服务的发送或接收点。每个在数据报包套接字上发送或接收的包都是单独编址和路由的。从一台机器发送到另一台机器的多个包可能选择不同的路由，也可能按不同的顺序到达。</p><table><thead><tr><th>构造方法</th><th>说明</th></tr></thead><tbody><tr><td>DatagramSocket()</td><td>构造数据报包套接字并将其绑定到本地主机上任何可用的端口。</td></tr><tr><td>DatagramSocket(int port)</td><td>创建数据报包套接字并将其绑定到本地主机上的指定端口。</td></tr><tr><td>DatagramSocket(int port,InetAddressaddr)</td><td>创建数据报包套接字，将其绑定到指定的本地地址。</td></tr><tr><td>DatagramSocket(SocketAddress,bindaddr)</td><td>创建数据报包套接字，将其绑定到指定的本地套接字地址。</td></tr></tbody></table><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>void bind(SocketAddress addr)</td><td>将此 DatagramSocket 绑定到特定的地址和端口。</td></tr><tr><td>void close()</td><td>关闭此数据报包套接字。</td></tr><tr><td>void connect(InetAddress address,int port)</td><td>将套接字连接到此套接字的远程地址。</td></tr><tr><td>void connect(SocketAddress addr)</td><td>将此套接子连接到远程套接子地址（IP地址+端口号）。</td></tr><tr><td>void disconnect()</td><td>断开套接字的连接。</td></tr><tr><td>InetAddress getInetAddress()</td><td>返回此套接字连接的地址。</td></tr><tr><td>InetAddress getLocalAddress()</td><td>获取套接字绑定的本地地址。</td></tr><tr><td>int getLocalPort()</td><td>返回此套接字绑定的本地主机上的端口号。</td></tr><tr><td>int getPort()</td><td>返回此套接字的端口。</td></tr></tbody></table><h2 id="例"><a href="#例" class="headerlink" title="例"></a>例</h2><p>编写 UDP 程序，要求客户端程序可以向服务器端发送多条数据，服务器端程序可以接收客户端发送的多条数据并将其信息输出在控制台，主要步骤如下所示。</p><p><strong>客户端</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            DatagramSocket udpScoket=<span class="keyword">new</span> DatagramSocket();</span><br><span class="line">            InetAddress serverAddress=InetAddress.getByName(<span class="string">"127.0.0.1"</span>);</span><br><span class="line">            <span class="keyword">int</span> serverPort=<span class="number">8082</span>;</span><br><span class="line"></span><br><span class="line">            DatagramPacket udPacket=<span class="keyword">null</span>;</span><br><span class="line">            String[] messages=&#123;<span class="string">"YOLO"</span>,<span class="string">"HELLO"</span>,<span class="string">"JUST DO IT"</span>&#125;;</span><br><span class="line">            <span class="keyword">for</span> (String message:messages)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">byte</span>[] data=message.getBytes();</span><br><span class="line">                udPacket=<span class="keyword">new</span> DatagramPacket(data,data.length,serverAddress,serverPort);</span><br><span class="line">                udpScoket.send(udPacket);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            udpScoket.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(IOException | InterruptedException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>服务器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            DatagramSocket ds=<span class="keyword">new</span> DatagramSocket(<span class="number">8082</span>);</span><br><span class="line">            System.out.println(<span class="string">"UDP服务器已启动。。。"</span>);</span><br><span class="line">            DatagramPacket dpReceive;</span><br><span class="line">            <span class="keyword">byte</span>[] b=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span>(ds.isClosed()==<span class="keyword">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dpReceive=<span class="keyword">new</span> DatagramPacket(b, b.length);</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ds.receive(dpReceive);</span><br><span class="line">                    <span class="keyword">byte</span>[] Data=dpReceive.getData();</span><br><span class="line">                    <span class="keyword">int</span> len=Data.length;</span><br><span class="line">                    System.out.println(<span class="string">"UDP客户端"</span>+dpReceive.getSocketAddress()+<span class="string">"发送的内容是："</span> + <span class="keyword">new</span> String(Data, <span class="number">0</span>, len).trim());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span>(IOException e)</span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(SocketException e1)</span><br><span class="line">        &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UDP服务器已启动。。。</span><br><span class="line">UDP客户端&#x2F;127.0.0.1:64656发送的内容是：YOLO                             </span><br><span class="line">UDP客户端&#x2F;127.0.0.1:64656发送的内容是：HELLO                                             </span><br><span class="line">UDP客户端&#x2F;127.0.0.1:64656发送的内容是：JUST DO IT</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;UDP&quot;&gt;&lt;a href=&quot;#UDP&quot; class=&quot;headerlink&quot; title=&quot;UDP&quot;&gt;&lt;/a&gt;UDP&lt;/h1&gt;&lt;p&gt;在 TCP/IP 协议的传输层除了一个 TCP 协议之外，还有一个 UDP 协议。UDP 协议是用户数据报协议的简称，也用于网络数据的传输。虽然 UDP 协议是一种不太可靠的协议，但有时在需要较快地接收数据并且可以忍受较小错误的情况下，UDP 就会表现出更大的优势。&lt;/p&gt;
&lt;p&gt;下面是在 &lt;a href=&quot;http://c.biancheng.net/java/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java&lt;/a&gt; 中使用 UDP 协议发送数据的步骤。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用 DatagramSocket() 创建一个数据包套接字。&lt;/li&gt;
&lt;li&gt;使用 DatagramPacket() 创建要发送的数据包。&lt;/li&gt;
&lt;li&gt;使用 DatagramSocket 类的 send() 方法发送数据包。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;接收 UDP 数据包的步骤如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 DatagramSocket 创建数据包套接字，并将其绑定到指定的端口。&lt;/li&gt;
&lt;li&gt;使用 DatagramPacket 创建字节数组来接收数据包。&lt;/li&gt;
&lt;li&gt;使用 DatagramPacket 类的 receive() 方法接收 UDP 包。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="javaio" scheme="http://blog.onebug.tech/categories/javaio/"/>
    
    
      <category term="java" scheme="http://blog.onebug.tech/tags/java/"/>
    
      <category term="IO" scheme="http://blog.onebug.tech/tags/IO/"/>
    
      <category term="网络编程" scheme="http://blog.onebug.tech/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
      <category term="UDP" scheme="http://blog.onebug.tech/tags/UDP/"/>
    
  </entry>
  
  <entry>
    <title>Linux IO 模式</title>
    <link href="http://blog.onebug.tech/2021/05/07/java/javaIO/Linux%20IO%E6%A8%A1%E5%BC%8F/"/>
    <id>http://blog.onebug.tech/2021/05/07/java/javaIO/Linux%20IO%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-05-06T16:00:00.000Z</published>
    <updated>2021-05-08T09:56:00.285Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-IO模式"><a href="#Linux-IO模式" class="headerlink" title="Linux IO模式"></a>Linux IO模式</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="用户空间与内核空间"><a href="#用户空间与内核空间" class="headerlink" title="用户空间与内核空间"></a>用户空间与内核空间</h3><p>现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对Linux操作系统而言，将最高的1G字节（从虚拟地址<code>0xC0000000</code>到<code>0xFFFFFFFF</code>），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址<code>0x00000000</code>到<code>0xBFFFFFFF</code>），供各个进程使用，称为用户空间。</p><p>每个进程可以通过系统调用进入内核，因此，Linux内核由系统内的所有进程共享。于是，从具体进程的角度来看，每个进程可以拥有4G字节的虚拟空间。</p><p><img src="http://image.onebug.tech/29f80b4c7e9aa6f9dd77da9721433cf5.png" alt="Linux 内核空间与用户空间_程序地带"></p><a id="more"></a><h3 id="文件描述符fd"><a href="#文件描述符fd" class="headerlink" title="文件描述符fd"></a>文件描述符fd</h3><p>文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。</p><p>文件描述符在形式上是一个非负整数。实际上，它是<strong>一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表</strong>。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p><blockquote><p>Socket：正如应用程序使用文件描述符访问文件一样，应用程序也使用套接字描述符(socket descriptors )访问套接字。<strong>套接字描述符在 UNIX 系统中作为文件描述符实现</strong>，这也符合UNIX系统“一切皆文件”的设计思想。</p></blockquote><h3 id="缓存-I-O"><a href="#缓存-I-O" class="headerlink" title="缓存 I/O"></a>缓存 I/O</h3><p>缓存 IO 又被称作标准 IO，大多数文件系统的默认 IO 操作都是缓存 IO。在 Linux 的缓存 IO 机制中，操作系统会将 IO 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。</p><p><img src="http://image.onebug.tech/image-20210507184156017.png" alt="image-20210507184156017"></p><h2 id="Linux-IO-模式"><a href="#Linux-IO-模式" class="headerlink" title="Linux IO 模式"></a>Linux IO 模式</h2><p>对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生时，它会经历<strong>两个阶段</strong>：</p><ol><li><strong>等待数据准备 (Waiting for the data to be ready)</strong></li><li><strong>将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)</strong> </li></ol><p>在整个请求过程中，数据输入至buffer需要时间，而从buffer复制数据至进程也需要时间。因此根据在这两段时间内等待方式的不同，I/O动作可以分为以下五种模式：</p><ul><li>阻塞 I/O（blocking IO）</li><li>非阻塞 I/O（nonblocking IO）</li><li>I/O 多路复用（ IO multiplexing）</li><li>信号驱动 I/O（ signal driven IO）</li><li>异步 I/O（asynchronous IO）</li></ul><blockquote><p>由于signal driven IO在实际中并不常用，这里不做介绍。</p></blockquote><p>在数据传输的过程中，避免数据在操作系统内核地址空间的缓冲区和用户应用程序地址空间的缓冲区之间进行拷贝。有的时候，应用程序在数据进行传输的过程中不需要对数据进行访问，那么，将数据从 Linux 的页缓存拷贝到用户进程的缓冲区中就可以完全避免，传输的数据在页缓存中就可以得到处理。在某些特殊的情况下，这种零拷贝技术可以获得较好的性能。Linux 中提供类似的系统调用主要有 <code>mmap()</code>，<code>sendfile()</code> 以及 <code>splice()</code>。</p><p>如果使用<code>mmap()</code>，磁盘上的数据会通过 <code>DMA</code>被拷贝的内核缓冲区，接着操作系统会把这段内核缓冲区与应用程序共享，这样就不需要把内核缓冲区的内容往用户空间拷贝。应用程序调用 <code>write()</code>时，操作系统直接将内核缓冲区的内容拷贝到 <code>socket</code>缓冲区中，这一切都发生在内核态，最后， <code>socket</code>缓冲区再把数据发到网卡去。相对于<code>read()</code>很明显减少了一次拷贝，当拷贝数据量很大时，无疑提升了效率。</p><p><img src="http://image.onebug.tech/image-20210507184628247.png" alt="image-20210507184628247"></p><h3 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a>阻塞IO</h3><p>在Linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样：</p><p><img src="http://image.onebug.tech/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f313439323932383431363831325f342e706e67" alt="img"></p><p>当用户进程调用了<code>recvfrom</code>这个系统调用，kernel就开始了IO的第一个阶段：准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的，而在用户进程这边，整个进程会被阻塞。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除阻塞的状态，重新运行起来。</p><p>所以，所以，阻塞IO的特点就是<strong>在IO执行的两个阶段都被block了。</strong></p><h3 id="非阻塞-I-O"><a href="#非阻塞-I-O" class="headerlink" title="非阻塞 I/O"></a>非阻塞 I/O</h3><p>Linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子</p><p><img src="http://image.onebug.tech/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f313439323932393030303336315f352e706e67" alt="img"></p><p>当用户进程调用<code>recvfrom</code>时，系统不会阻塞用户进程，而是立刻返回一个<code>ewouldblock</code>错误，从用户进程角度讲 ，并不需要等待，而是马上就得到了一个结果。用户进程判断标志是<code>ewouldblock</code>时，就知道数据还没准备好，于是它就可以去做其他的事了，于是它可以再次发送<code>recvfrom</code>，一旦内核中的数据准备好了。并且又再次收到了用户进程的系统，那么它马上就将数据拷贝到了用户内存，然后返回。</p><p>当一个应用程序在一个循环里对一个非阻塞调用<code>recvfrom</code>，我们称为轮询。应用程序不断轮询内核，看看是否已经准备好了某些操作。这通常是浪费CPU时间，但这种模式偶尔会遇到。</p><h3 id="I-O-复用"><a href="#I-O-复用" class="headerlink" title="I/O 复用"></a>I/O 复用</h3><p>IO multiplexing就是我们说的select，poll，epoll，有时候也称这种IO方式为事件驱动IO（event driven IO）。select/epoll的好处就在于单个进程就可以同时处理多个网络连接的IO。当某个socket有数据到达了，就通知用户进程。</p><p><img src="http://image.onebug.tech/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f313439323932393434343831385f362e706e67" alt="img"></p><p>当用户进程调用了select，那么整个进程会被阻塞，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</p><p>这个图和阻塞IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要进行两次系统调用 (select 和 <code>recvfrom</code>)，而阻塞IO只进行一次系统调用 (<code>recvfrom</code>)。但是，用select的优势在于它可以同时处理多个连接。</p><p>所以处理的连接数不是很高的话，使用【select/epoll】的服务器不一定比使用【多线程 + 阻塞IO】的web server性能更好，可能延迟还更大。</p><p>在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。</p><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>基本原理：select 函数监视的文件描述符分3类，分别是<code>writefds</code>、<code>readfds</code>、和<code>exceptfds</code>。调用后select函数会阻塞，直到有描述符就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以通过<strong>遍历</strong><code>fdset</code>，来找到就绪的描述符。</p><p>缺点:</p><ul><li>select最大的缺陷就是<strong>单个进程所打开的FD是有一定限制的</strong>，它由<code>FDSETSIZE</code>设置，32位机默认是1024个，64位机默认是2048。 一般来说这个数目和系统内存关系很大</li><li>对socket进行扫描时是<strong>线性扫描，效率较低</strong>。 当套接字比较多的时候，每次select()都要通过遍历<code>FDSETSIZE</code>个Socket来完成调度，不管哪个Socket是活跃的，都遍历一遍。这会浪费很多CPU时间。</li><li>需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时<strong>复制开销大</strong>。</li></ul><h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>poll本质上和select基本没有区别。特点是<strong>没有最大连接数的限制，原因是它是基于链表来存储的</strong>，但是线性遍历和复制开销大的缺点仍然存在。poll还有一个特点是“水平触发”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。</p><p>事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，如果采用线性遍历方式，随着监视的描述符数量的增长，其效率也会线性下降。</p><blockquote><p>水平触发模式（level trigger）：当检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用会再次响应应用程序并通知此事件。<br>边缘触发模式（edge trigger）：当检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用时，不会再次响应应用程序并通知此事件。</p></blockquote><h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p>epoll是在Linux 2.6内核中提出的，是之前的select和poll的增强版本。相对于select和poll来说，epoll更加灵活：</p><ul><li><p>没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）</p></li><li><p>效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。 只有活跃可用的FD才会调用callback函数；即epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关</p></li><li><p>内存拷贝，利用<code>mmap()</code>文件映射内存加速与内核空间的消息传递，减少了无用的复制</p></li><li><p>epoll支持水平触发和边缘触发</p></li></ul><blockquote><p>JDK1.5_update10版本使用epoll替代了传统的select/poll，极大的提升了NIO通信的性能。</p></blockquote><h3 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a>异步I/O</h3><p>应用进程执行 <code>aio_read</code> 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。</p><p>异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O。</p><p><img src="http://image.onebug.tech/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f313439323933303234333238365f382e706e67" alt="img"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>同步 I/O：将数据从内核缓冲区复制到应用进程缓冲区的阶段（第二阶段），应用进程会阻塞。</li><li>异步 I/O：第二阶段应用进程不会阻塞。</li></ul><p>同步 I/O 包括阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O ，它们的主要区别在第一个阶段。</p><p>非阻塞式 I/O 、信号驱动 I/O 和异步 I/O 在第一阶段不会阻塞。</p><p>从同步、异步，以及阻塞、非阻塞两个维度来划分来看，IO模式可以分为：</p><p><img src="http://image.onebug.tech/image-20210507185322599.png" alt="image-20210507185322599"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux-IO模式&quot;&gt;&lt;a href=&quot;#Linux-IO模式&quot; class=&quot;headerlink&quot; title=&quot;Linux IO模式&quot;&gt;&lt;/a&gt;Linux IO模式&lt;/h1&gt;&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;h3 id=&quot;用户空间与内核空间&quot;&gt;&lt;a href=&quot;#用户空间与内核空间&quot; class=&quot;headerlink&quot; title=&quot;用户空间与内核空间&quot;&gt;&lt;/a&gt;用户空间与内核空间&lt;/h3&gt;&lt;p&gt;现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对Linux操作系统而言，将最高的1G字节（从虚拟地址&lt;code&gt;0xC0000000&lt;/code&gt;到&lt;code&gt;0xFFFFFFFF&lt;/code&gt;），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址&lt;code&gt;0x00000000&lt;/code&gt;到&lt;code&gt;0xBFFFFFFF&lt;/code&gt;），供各个进程使用，称为用户空间。&lt;/p&gt;
&lt;p&gt;每个进程可以通过系统调用进入内核，因此，Linux内核由系统内的所有进程共享。于是，从具体进程的角度来看，每个进程可以拥有4G字节的虚拟空间。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://image.onebug.tech/29f80b4c7e9aa6f9dd77da9721433cf5.png&quot; alt=&quot;Linux 内核空间与用户空间_程序地带&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="javaio" scheme="http://blog.onebug.tech/categories/javaio/"/>
    
    
      <category term="linux" scheme="http://blog.onebug.tech/tags/linux/"/>
    
      <category term="java" scheme="http://blog.onebug.tech/tags/java/"/>
    
      <category term="IO" scheme="http://blog.onebug.tech/tags/IO/"/>
    
      <category term="socket" scheme="http://blog.onebug.tech/tags/socket/"/>
    
  </entry>
  
  <entry>
    <title>【转】零拷贝技术</title>
    <link href="http://blog.onebug.tech/2021/05/07/java/javaIO/zeroCopy/"/>
    <id>http://blog.onebug.tech/2021/05/07/java/javaIO/zeroCopy/</id>
    <published>2021-05-06T16:00:00.000Z</published>
    <updated>2021-05-08T09:58:32.191Z</updated>
    
    <content type="html"><![CDATA[<h1 id="【转】零拷贝技术详解"><a href="#【转】零拷贝技术详解" class="headerlink" title="【转】零拷贝技术详解"></a>【转】<a href="https://mp.weixin.qq.com/s?__biz=MzU0MzQ5MDA0Mw==&mid=2247483913&idx=1&sn=2da53737b8e8908cf3efdae9621c9698&chksm=fb0be89dcc7c618b0d5a1ba8ac654295454cfc2fa81fbae5a6de49bf0a91a305ca707e9864fc&scene=21#wechat_redirect" target="_blank" rel="noopener">零拷贝技术详解</a></h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>考虑这样一种常用的情形：你需要将静态内容（类似图片、文件）展示给用户。那么这个情形就意味着你需要先将静态内容从磁盘中拷贝出来放到一个内存buf中，然后将这个buf通过socket传输给用户，进而用户或者静态内容的展示。这看起来再正常不过了，但是实际上这是很低效的流程，我们把上面的这种情形抽象成下面的过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read(file, tmp_buf, len);</span><br><span class="line">write(socket, tmp_buf, len);</span><br></pre></td></tr></table></figure><a id="more"></a><p>首先调用<code>read</code>将静态内容，这里假设为文件A，读取到<code>tmp_buf</code>, 然后调用<code>write</code>将<code>tmp_buf</code>写入到socket中，如图：</p><p><img src="http://image.onebug.tech/640" alt="图片"></p><p>在这个过程中文件A的经历了<strong>4次cop</strong>y的过程：</p><ol><li>首先，调用<code>read</code>时，文件A拷贝到了kernel模式；</li><li>之后，CPU控制将kernel模式数据copy到user模式下；</li><li>调用<code>write</code>时，先将user模式下的内容copy到kernel模式下的socket的buffer中；</li><li>最后将kernel模式下的socket buffer的数据copy到网卡设备中传送；</li></ol><p>从上面的过程可以看出，数据白白从kernel模式到user模式走了一圈，浪费了2次copy(第一次，从kernel模式拷贝到user模式；第二次从user模式再拷贝回kernel模式，即上面4次过程的第2和3步骤。)。而且上面的过程中kernel和user模式的<strong>上下文的切换也是4次</strong>。</p><p>幸运的是，你可以用一种叫做Zero-Copy的技术来去掉这些无谓的copy。应用程序用Zero-Copy来请求kernel直接把disk的data传输给socket，而不是通过应用程序传输。Zero-Copy大大提高了应用程序的性能，并且减少了kernel和user模式上下文的切换。</p><hr><h2 id="详述"><a href="#详述" class="headerlink" title="详述"></a>详述</h2><p>Zero-Copy技术省去了将操作系统的read buffer拷贝到程序的buffer，以及从程序buffer拷贝到socket buffer的步骤，直接将read buffer拷贝到socket buffer。Java <code>NIO</code>中的<code>FileChannal.transferTo()</code>方法就是这样的实现，这个实现是依赖于操作系统底层的<code>sendFile()</code>实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> transferTo​(<span class="keyword">long</span> position, <span class="keyword">long</span> count, WritableByteChannel target)</span><br></pre></td></tr></table></figure><p>他底层的调用时系统调用<code>sendFile()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line"><span class="function">ssize_t <span class="title">sendfile</span><span class="params">(<span class="keyword">int</span> out_fd, <span class="keyword">int</span> in_fd, off_t *offset, size_t count)</span></span>;</span><br></pre></td></tr></table></figure><p>下图展示了在<code>transferTo()</code>之后的数据流向：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/HV4yTI6PjbKgic1MvAjpofibyQwiauK9swkLT7QYEgjoSWgksiaPm1m7mHlicH0YquHnicwnBcsJpyUJOcH3EuvWyVWA/640?tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>下图展示了在使用<code>transferTo()</code>之后的上下文切换：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/HV4yTI6PjbKgic1MvAjpofibyQwiauK9swkxXxl8mCQDdzXJKmZJogZthpx2g5wEJrFZSib6cJFEFqNcCqws3bgUcg/640?tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>使用了Zero-Copy技术之后，整个过程如下：</p><ol><li><code>transferTo()</code>方法使得文件A的内容直接拷贝到一个read buffer（kernel buffer）中；</li><li>然后数据(kernel buffer)拷贝到socket buffer中。</li><li>最后将socket buffer中的数据拷贝到网卡设备（protocol engine）中传输；</li></ol><p>这显然是一个伟大的进步：这里把<strong>上下文的切换次数从4次减少到2次，同时也把数据copy的次数从4次降低到了3次。</strong></p><p>但是这是Zero-Copy么，答案是否定的。</p><hr><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>Linux 2.1内核开始引入了<code>sendfile</code>函数（上一节有提到）,用于将文件通过socket传送。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sendfile(socket, file, len);</span><br></pre></td></tr></table></figure><p>该函数通过一次系统调用完成了文件的传送，减少了原来read/write方式的模式切换。此外更是减少了数据的copy， <code>sendfile</code>的详细过程如图：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/HV4yTI6PjbKgic1MvAjpofibyQwiauK9swklziaq26RXuQ5OhkostSBhs3uNxbtJYnalq4CfAGtWqfbBjXoT1SELrA/640?tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>通过<code>sendfile</code>传送文件只需要一次系统调用，当调用<code>sendfile</code>时：</p><ol><li>首先（通过DMA）将数据从磁盘读取到kernel buffer中；</li><li>然后将kernel buffer拷贝到socket buffer中；</li><li>最后将socket buffer中的数据copy到网卡设备（protocol engine）中发送；</li></ol><p>这个过程就是第二节（详述）中的那个步骤。</p><p><code>sendfile</code>与read/write模式相比，少了一次copy。但是从上述过程中也可以发现从kernel buffer中将数据copy到socket buffer是没有必要的。</p><p>Linux 2.4 内核对<code>sendfile</code>做了改进，如图：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/HV4yTI6PjbKgic1MvAjpofibyQwiauK9swk48yndvPialCSfyx5pMzpeicmzNXGugFUJfYR3oPuPr2egIZ3Vz5WJ2EA/640?tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>改进后的处理过程如下：</p><ol><li>将文件拷贝到kernel buffer中；</li><li>向socket buffer中追加当前要发生的数据在kernel buffer中的<strong>位置和偏移量</strong>；</li><li>根据socket buffer中的位置和偏移量直接将kernel buffer的数据copy到网卡设备（protocol engine）中；</li></ol><p>经过上述过程，<strong>数据只经过了2次copy就从磁盘传送出去了。这个才是真正的Zero-Copy</strong>(这里的零拷贝是针对kernel来讲的，数据在kernel模式下是Zero-Copy)。</p><p>正是Linux 2.4的内核做了改进，Java中的<code>TransferTo()</code>实现了Zero-Copy,如下图：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/HV4yTI6PjbKgic1MvAjpofibyQwiauK9swkIr4RdZunnVfczbFdpJT1bFQRBdicslA4bW92FJBvtiacojo6KgBDial6A/640?tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>Zero-Copy技术的使用场景有很多，比如Kafka, 又或者是Netty等，可以大大提升程序的性能。</p><blockquote><p>转载：<a href="https://mp.weixin.qq.com/s?__biz=MzU0MzQ5MDA0Mw==&mid=2247483913&idx=1&sn=2da53737b8e8908cf3efdae9621c9698&chksm=fb0be89dcc7c618b0d5a1ba8ac654295454cfc2fa81fbae5a6de49bf0a91a305ca707e9864fc&scene=21#wechat_redirect" target="_blank" rel="noopener">什么是Zero-Copy？ (qq.com)</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;【转】零拷贝技术详解&quot;&gt;&lt;a href=&quot;#【转】零拷贝技术详解&quot; class=&quot;headerlink&quot; title=&quot;【转】零拷贝技术详解&quot;&gt;&lt;/a&gt;【转】&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU0MzQ5MDA0Mw==&amp;mid=2247483913&amp;idx=1&amp;sn=2da53737b8e8908cf3efdae9621c9698&amp;chksm=fb0be89dcc7c618b0d5a1ba8ac654295454cfc2fa81fbae5a6de49bf0a91a305ca707e9864fc&amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;零拷贝技术详解&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;考虑这样一种常用的情形：你需要将静态内容（类似图片、文件）展示给用户。那么这个情形就意味着你需要先将静态内容从磁盘中拷贝出来放到一个内存buf中，然后将这个buf通过socket传输给用户，进而用户或者静态内容的展示。这看起来再正常不过了，但是实际上这是很低效的流程，我们把上面的这种情形抽象成下面的过程：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;read(file, tmp_buf, len);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;write(socket, tmp_buf, len);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="javaio" scheme="http://blog.onebug.tech/categories/javaio/"/>
    
    
      <category term="java" scheme="http://blog.onebug.tech/tags/java/"/>
    
      <category term="IO" scheme="http://blog.onebug.tech/tags/IO/"/>
    
      <category term="socket" scheme="http://blog.onebug.tech/tags/socket/"/>
    
      <category term="零拷贝技术" scheme="http://blog.onebug.tech/tags/%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Java Socket 编程</title>
    <link href="http://blog.onebug.tech/2021/05/07/java/javaIO/socket%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>http://blog.onebug.tech/2021/05/07/java/javaIO/socket%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</id>
    <published>2021-05-06T16:00:00.000Z</published>
    <updated>2021-05-08T09:56:58.274Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-Socket-编程"><a href="#Java-Socket-编程" class="headerlink" title="Java Socket 编程"></a>Java Socket 编程</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>首先需要了解两个类：Socket和SocketServer。</p><h3 id="SocketServer"><a href="#SocketServer" class="headerlink" title="SocketServer"></a>SocketServer</h3><p>SocketServer实现了服务器套接字。 服务器套接字会等待通过网络进入的请求。 用户可以根据该请求执行某些操作，然后将结果返回给请求者（也可以选择不返回）。</p><a id="more"></a><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ServerSocket</span> <span class="params">(<span class="keyword">int</span> port, <span class="keyword">int</span> backlog,InetAddress bindAddr)</span></span></span><br></pre></td></tr></table></figure><p>创建具有<strong>指定端口</strong>的服务器，监听backlog和要<strong>绑定</strong>的本地IP地址。</p><p><strong>参数</strong></p><ul><li><code>port</code> - 绑定的本地端口号。 端口号<code>0</code>表示从临时端口范围自动分配端口号，可以通过调用<code>getLocalPort</code>来查看此端口号。</li><li><code>backlog</code> - 传入连接指示（连接请求）的最大队列长度，如果队列已满时连接指示到达，则拒绝连接。</li><li><code>bindAddr</code> - 服务器将绑定到的本地<code>InetAddress</code>， 如果<code>bindAddr</code>为null，它将默认接受任何/所有本地地址上的连接。</li></ul><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ul><li><p><code>accept()</code>侦听对此套接字的连接并接受它。 该方法将阻塞，直到建立连接，成功建立连接后会返回一个<strong>新的Socket</strong>。</p></li><li><p><code>close()</code>关闭此套接字</p></li></ul><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>该类实现客户端套接字（一般简称为“套接字”）。 套接字是两台机器之间通信的端点。</p><h4 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Socket</span><span class="params">(String host,<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> UnknownHostException,IOException</span></span><br></pre></td></tr></table></figure><p>创建流套接字并将其<strong>连接</strong>到指定主机上的指定端口号。</p><h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h4><ul><li><p><code>getInputStream()</code>返回此套接字的输入流，注意关闭返回的<code>InputStream</code>将关闭关联的套接字。</p></li><li><p><code>getOutputStream()</code>返回此套接字的输出流，关闭返回的<code>OutputStream</code>将关闭关联的套接字。</p></li><li><p><code>close()</code>关闭此套接字，关闭此套接字也将关闭套接字<code>InputStream</code>和<code>OutputStream</code> 。一旦套接字关闭，进一步的网络连接就需要创建一个新的套接字。</p></li><li><p><code>shutdownInput()</code>将此套接字的输入流设置为“流结束”。 发送到套接字输入流端的任何数据都会被确认，然后以静默方式丢弃。套接字输入流<code>read</code>方法将返回<code>-1</code> （流结束）。</p></li><li><p><code>shutdownOutput()</code>禁用此套接字的输出流。 对于TCP套接字，将发送任何先前写入的数据，然后发送TCP的正常<strong>连接终止序列</strong>。 </p></li><li><p><code>isConnected()</code>返回套接字的连接状态。</p></li><li><p><code>setOption(SocketOption&lt;T&gt; name, T value)</code>设置套接字选项的值。</p></li></ul><h3 id="通信基本示例"><a href="#通信基本示例" class="headerlink" title="通信基本示例"></a>通信基本示例</h3><p><strong>服务端</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建具有指定端口的服务器套接字</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">8081</span>;</span><br><span class="line">        <span class="comment">//注意指定编码格式，发送方和接收方一定要统一，建议使用UTF-8</span></span><br><span class="line">        <span class="keyword">final</span> String CHARSET=<span class="string">"UTF-8"</span>;</span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(PORT);</span><br><span class="line">        SocketAddress serverAddress=server.getLocalSocketAddress();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// accept() 会阻塞进程，直到建立新连接，成功建立连接后会返回一个新的Socket。</span></span><br><span class="line">        log.info(<span class="string">"Waiting for new connection(Listening on : &#123;&#125;)"</span>,serverAddress);</span><br><span class="line">        Socket socket = server.accept();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 建立好连接后，从socket中获取输入、输出流、客户端信息</span></span><br><span class="line">        InputStream inputStream = socket.getInputStream();</span><br><span class="line">        OutputStream outputStream=socket.getOutputStream();</span><br><span class="line">        SocketAddress clientAddress=socket.getRemoteSocketAddress();</span><br><span class="line">        log.info(<span class="string">"There is a new  connection &#123;&#125;"</span>,socket);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//建立缓冲区用于读取或写入</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        log.info(<span class="string">"Waiting for message from client &#123;&#125; "</span>,clientAddress);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//read()会阻塞进程，直到有输入，返回-1代表流结束</span></span><br><span class="line">        <span class="keyword">while</span> ((len = inputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//注意指定编码格式，发送方和接收方一定要统一，建议使用UTF-8</span></span><br><span class="line">            sb.append(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, len,CHARSET));</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">"Get a message '&#123;&#125;' from client &#123;&#125;"</span> ,sb,socket.getRemoteSocketAddress());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭连接和服务器</span></span><br><span class="line">        inputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">13</span>:<span class="number">49</span>:<span class="number">01.451</span> [main] INFO cn.lbs.socket.base.SocketServer - <span class="function">Waiting <span class="keyword">for</span> new <span class="title">connection</span><span class="params">(Listening on : <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">8081</span>)</span></span></span><br><span class="line"><span class="function">13:49:06.413 [main] INFO cn.lbs.socket.base.SocketServer - There is a new  connection Socket[addr</span>=/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>,port=<span class="number">4463</span>,localport=<span class="number">8081</span>]</span><br><span class="line"><span class="number">13</span>:<span class="number">49</span>:<span class="number">06.413</span> [main] INFO cn.lbs.socket.base.SocketServer - Waiting <span class="keyword">for</span> message from client /<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">4463</span> </span><br><span class="line"><span class="number">13</span>:<span class="number">49</span>:<span class="number">06.427</span> [main] INFO cn.lbs.socket.base.SocketServer - Get a message <span class="string">'Hello World'</span> from client /<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">4463</span></span><br></pre></td></tr></table></figure><p><strong>客户端</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 设置连接的服务端IP地址和端口</span></span><br><span class="line">        <span class="keyword">final</span> String HOST = <span class="string">"127.0.0.1"</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">8081</span>;</span><br><span class="line">        <span class="comment">//注意指定编码格式，发送方和接收方一定要统一，建议使用UTF-8</span></span><br><span class="line">        <span class="keyword">final</span> String CHARSET=<span class="string">"UTF-8"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 与服务端建立连接</span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(HOST, PORT);</span><br><span class="line">        <span class="comment">// 建立连接后获得输出、输出流、连接信息</span></span><br><span class="line">        OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">        InputStream inputStream=socket.getInputStream();</span><br><span class="line">        SocketAddress   localAddress=socket.getLocalSocketAddress();</span><br><span class="line">        SocketAddress remoteAddress=socket.getRemoteSocketAddress();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"The client &#123;&#125; successfully connects to the server &#123;&#125;"</span>,localAddress,remoteAddress);</span><br><span class="line"></span><br><span class="line">        String message=<span class="string">"Hello World"</span>;</span><br><span class="line">        log.info(<span class="string">"The client &#123;&#125; sends a message '&#123;&#125;' to the server "</span>,localAddress,message);</span><br><span class="line">        socket.getOutputStream().write(message.getBytes(CHARSET));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭连接</span></span><br><span class="line">        outputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">13</span>:<span class="number">49</span>:<span class="number">06.416</span> [main] INFO cn.lbs.socket.base.SocketClient - The client /<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">4463</span> successfully connects to the server /<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8081</span></span><br><span class="line"><span class="number">13</span>:<span class="number">49</span>:<span class="number">06.426</span> [main] INFO cn.lbs.socket.base.SocketClient - The client /<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">4463</span> sends a message <span class="string">'Hello World'</span> to the server</span><br></pre></td></tr></table></figure><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><h3 id="双向通信基础"><a href="#双向通信基础" class="headerlink" title="双向通信基础"></a>双向通信基础</h3><p><strong>服务端</strong></p><p>当读取完客户端的消息后，打开输出流，将指定消息发送回客户端。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建具有指定端口的服务器套接字</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">8081</span>;</span><br><span class="line">        <span class="comment">//注意指定编码格式，发送方和接收方一定要统一，建议使用UTF-8</span></span><br><span class="line">        <span class="keyword">final</span> String CHARSET=<span class="string">"UTF-8"</span>;</span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(PORT);</span><br><span class="line">        SocketAddress serverAddress=server.getLocalSocketAddress();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// accept() 会阻塞进程，直到建立新连接，成功建立连接后会返回一个新的Socket。</span></span><br><span class="line">        log.info(<span class="string">"Waiting for new connection(Listening on : &#123;&#125;)"</span>,serverAddress);</span><br><span class="line">        Socket socket = server.accept();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 建立好连接后，从socket中获取输入、输出流、客户端信息</span></span><br><span class="line">        InputStream inputStream = socket.getInputStream();</span><br><span class="line">        OutputStream outputStream=socket.getOutputStream();</span><br><span class="line">        SocketAddress clientAddress=socket.getRemoteSocketAddress();</span><br><span class="line">        log.info(<span class="string">"There is a new  connection &#123;&#125;"</span>,socket);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//建立缓冲区用于读取或写入</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        log.info(<span class="string">"Waiting for message from client &#123;&#125; "</span>,clientAddress);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//read()会阻塞进程，直到有输入，返回-1代表流结束</span></span><br><span class="line">        <span class="keyword">while</span> ((len = inputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//注意指定编码格式，发送方和接收方一定要统一，建议使用UTF-8</span></span><br><span class="line">            sb.append(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, len,CHARSET));</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">"Get a message '&#123;&#125;' from client &#123;&#125;"</span> ,sb,socket.getRemoteSocketAddress());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        String respStr= <span class="string">"Hello,I get the message"</span>;</span><br><span class="line">        log.info(<span class="string">"Response message '&#123;&#125;' to Client &#123;&#125; "</span>,respStr,clientAddress);</span><br><span class="line">        outputStream.write(respStr.getBytes(CHARSET));</span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭连接和服务器</span></span><br><span class="line">        inputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">13:58:51.050 [main] INFO cn.lbs.socket.base.SocketServer - Waiting <span class="keyword">for</span> new connection(Listening on : 0.0.0.0/0.0.0.0:8081)</span><br><span class="line">13:58:58.706 [main] INFO cn.lbs.socket.base.SocketServer - There is a new  connection Socket[addr=/127.0.0.1,port=4554,localport=8081]</span><br><span class="line">13:58:58.706 [main] INFO cn.lbs.socket.base.SocketServer - Waiting <span class="keyword">for</span> message from client /127.0.0.1:4554 </span><br><span class="line">13:58:58.719 [main] INFO cn.lbs.socket.base.SocketServer - Get a message <span class="string">'Hello World'</span> from client /127.0.0.1:4554</span><br><span class="line">13:58:58.719 [main] INFO cn.lbs.socket.base.SocketServer - Response message <span class="string">'Hello,I get the message'</span> to Client /127.0.0.1:4554</span><br></pre></td></tr></table></figure><p><strong>客户端</strong></p><p>客户端也有相应的变化，在发送完消息时，调用关闭输出流方法，然后打开输出流，等候服务端的消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 设置连接的服务端IP地址和端口</span></span><br><span class="line">        <span class="keyword">final</span> String HOST = <span class="string">"127.0.0.1"</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">8081</span>;</span><br><span class="line">        <span class="comment">//注意指定编码格式，发送方和接收方一定要统一，建议使用UTF-8</span></span><br><span class="line">        <span class="keyword">final</span> String CHARSET=<span class="string">"UTF-8"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 与服务端建立连接</span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(HOST, PORT);</span><br><span class="line">        <span class="comment">// 建立连接后获得输出、输出流、连接信息</span></span><br><span class="line">        OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">        InputStream inputStream=socket.getInputStream();</span><br><span class="line">        SocketAddress   localAddress=socket.getLocalSocketAddress();</span><br><span class="line">        SocketAddress remoteAddress=socket.getRemoteSocketAddress();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"The client &#123;&#125; successfully connects to the server &#123;&#125;"</span>,localAddress,remoteAddress);</span><br><span class="line"></span><br><span class="line">        String message=<span class="string">"Hello World"</span>;</span><br><span class="line">        log.info(<span class="string">"The client &#123;&#125; sends a message '&#123;&#125;' to the server "</span>,localAddress,message);</span><br><span class="line">        outputStream.write(message.getBytes(CHARSET));</span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//建立缓冲区用于读取或写入</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//获取响应</span></span><br><span class="line">        log.info(<span class="string">"Client &#123;&#125; is  waiting for Response"</span>,localAddress);</span><br><span class="line">        <span class="comment">//read()会阻塞进程，直到有输入，返回-1代表流结束</span></span><br><span class="line">        <span class="keyword">while</span> ((len = inputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//注意指定编码格式，发送方和接收方一定要统一，建议使用UTF-8</span></span><br><span class="line">            sb.append(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, len,CHARSET));</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">"Get response message '&#123;&#125;' from Server"</span> , sb);</span><br><span class="line">        <span class="comment">//关闭连接</span></span><br><span class="line">        outputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">13:58:58.708 [main] INFO cn.lbs.socket.base.SocketClient - The client /127.0.0.1:4554 successfully connects to the server /127.0.0.1:8081</span><br><span class="line">13:58:58.719 [main] INFO cn.lbs.socket.base.SocketClient - The client /127.0.0.1:4554 sends a message <span class="string">'Hello World'</span> to the server </span><br><span class="line">13:58:58.719 [main] INFO cn.lbs.socket.base.SocketClient - Client /127.0.0.1:4554 is  waiting <span class="keyword">for</span> Response</span><br><span class="line">13:58:58.720 [main] INFO cn.lbs.socket.base.SocketClient - Get response message <span class="string">'Hello,I get the message'</span> from Server</span><br></pre></td></tr></table></figure><h3 id="发送完成告知机制"><a href="#发送完成告知机制" class="headerlink" title="发送完成告知机制"></a>发送完成告知机制</h3><h4 id="关闭Socket连接"><a href="#关闭Socket连接" class="headerlink" title="关闭Socket连接"></a>关闭Socket连接</h4><p>当Socket关闭的时候，服务端就会收到响应的关闭信号，那么服务端也就知道流已经关闭了，这个时候读取操作完成，就可以继续后续工作。但是客户端Socket关闭后，将不能接受服务端发送的消息，也不能再次发送消息。如果客户端想再次发送消息，需要重现创建Socket连接</p><h4 id="关闭输出流"><a href="#关闭输出流" class="headerlink" title="关闭输出流"></a>关闭输出流</h4><p>调用Socket的<code>shutdownOutput()</code>方法（不是关闭输出流<code>close()</code>，因为关闭输出流会直接关闭Socket连接），底层会告知服务端我这边已经写完了，那么服务端收到消息后，就能知道已经读取完消息，如果服务端有要返回给客户的消息那么就可以通过服务端的输出流发送给客户端。这种方式通过关闭客户端的输出流，告知服务端已经写完了，虽然可以读到服务端发送的消息，但是是不能再次发送消息给服务端，如果再次发送，需要重新建立Socket连接。</p><h4 id="约定符号"><a href="#约定符号" class="headerlink" title="约定符号"></a>约定符号</h4><p>就是双方约定一个字符或者一个短语，来当做消息发送完成的标识，通常这么做就需要改造读取方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Socket socket = server.accept();</span><br><span class="line"><span class="comment">// 建立好连接后，从socket中获取输入流，并建立缓冲区进行读取</span></span><br><span class="line">BufferedReader read=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream(),<span class="string">"UTF-8"</span>));</span><br><span class="line">String line;</span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">while</span> ((line = read.readLine()) != <span class="keyword">null</span> &amp;&amp; <span class="string">"end"</span>.equals(line)) &#123;</span><br><span class="line">  <span class="comment">//注意指定编码格式，发送方和接收方一定要统一，建议使用UTF-8</span></span><br><span class="line">  sb.append(line);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>优点：不需要关闭流，当发送完一条消息后可以再次发送新的命令消息</p></li><li><p>缺点：需要额外的约定结束标志，太简单的容易出现在要发送的消息中，误被结束，太复杂的不好处理，还占带宽</p></li></ul><h4 id="指定长度"><a href="#指定长度" class="headerlink" title="指定长度"></a>指定长度</h4><p><strong>先指定后续命令的长度</strong>，然后读取指定长度的内容做为客户端发送的消息。一般，如果用作命令发送，两个字节就够了，4个字节基本就能满足所有要求。</p><p><strong>服务端</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 监听指定的端口</span></span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">8081</span>;</span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// server将一直等待连接的到来</span></span><br><span class="line">        System.out.println(<span class="string">"Waiting for new connection(Listening Port:"</span>+server.getLocalPort()+<span class="string">")"</span>);</span><br><span class="line">        Socket socket = server.accept();</span><br><span class="line">        System.out.println(<span class="string">"There is a new connection "</span>+socket);</span><br><span class="line">        <span class="comment">// 建立好连接后，从socket中获取输入流，并建立缓冲区进行读取</span></span><br><span class="line">        InputStream inputStream = socket.getInputStream();</span><br><span class="line">        OutputStream outputStream = socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] receivebytes,sendBytes;</span><br><span class="line">        <span class="comment">// 因为可以复用Socket且能判断长度，所以可以一个Socket用到底</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println();</span><br><span class="line">            System.out.println(<span class="string">"Waiting for Message"</span>);</span><br><span class="line">            <span class="comment">// 首先读取两个字节表示的长度,read()方法会阻塞进程</span></span><br><span class="line">            <span class="keyword">int</span> first = inputStream.read();</span><br><span class="line">            <span class="comment">//如果读取的值为-1 说明到了流的末尾，Socket已经被关闭了，此时将不能再去读取</span></span><br><span class="line">            <span class="keyword">if</span>(first==-<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"Close connection"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> second = inputStream.read();</span><br><span class="line">            <span class="keyword">int</span> length = (first &lt;&lt; <span class="number">8</span>) + second;</span><br><span class="line">            <span class="comment">// 然后构造一个指定长的byte数组</span></span><br><span class="line">            receivebytes = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">            <span class="comment">// 然后读取指定长度的消息即可</span></span><br><span class="line">            inputStream.read(receivebytes);</span><br><span class="line">            String recStr=<span class="keyword">new</span> String(receivebytes, <span class="string">"UTF-8"</span>);</span><br><span class="line">            System.out.println(<span class="string">"Get message from client: "</span> + recStr);</span><br><span class="line"></span><br><span class="line">            String respStr=<span class="string">"Hello Client,I get the message:"</span>+recStr;</span><br><span class="line">            System.out.println(<span class="string">"Response message &#123;"</span>+respStr+<span class="string">"&#125; to Client"</span>);</span><br><span class="line">            <span class="comment">//首先需要计算得知消息的长度</span></span><br><span class="line">            sendBytes = respStr.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line">            <span class="comment">//然后将消息的长度优先发送出去</span></span><br><span class="line">            outputStream.write(sendBytes.length &gt;&gt;<span class="number">8</span>);</span><br><span class="line">            outputStream.write(sendBytes.length);</span><br><span class="line">            <span class="comment">//然后将消息再次发送出去</span></span><br><span class="line">            outputStream.write(sendBytes);</span><br><span class="line">            outputStream.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        inputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">14:03:20.550 [main] INFO cn.lbs.socket.communication.SocketServer - Waiting <span class="keyword">for</span> new connection(Listening on : 0.0.0.0/0.0.0.0:8081)</span><br><span class="line">14:03:23.534 [main] INFO cn.lbs.socket.communication.SocketServer - There is a new  connection Socket[addr=/127.0.0.1,port=4602,localport=8081]</span><br><span class="line">14:03:23.535 [main] INFO cn.lbs.socket.communication.SocketServer - Waiting <span class="keyword">for</span> message from client /127.0.0.1:4602 </span><br><span class="line">14:03:23.546 [main] INFO cn.lbs.socket.communication.SocketServer - Get  message <span class="string">'Hello World'</span> from client /127.0.0.1:4602</span><br><span class="line">14:03:23.546 [main] INFO cn.lbs.socket.communication.SocketServer - Response message <span class="string">'Hello,I get the message'</span> to Client /127.0.0.1:4602 </span><br><span class="line">14:03:23.547 [main] INFO cn.lbs.socket.communication.SocketServer - Waiting <span class="keyword">for</span> message from client /127.0.0.1:4602 </span><br><span class="line">14:03:23.547 [main] INFO cn.lbs.socket.communication.SocketServer - Get  message <span class="string">'你好，世界'</span> from client /127.0.0.1:4602</span><br><span class="line">14:03:23.547 [main] INFO cn.lbs.socket.communication.SocketServer - Response message <span class="string">'Hello,I get the message'</span> to Client /127.0.0.1:4602 </span><br><span class="line">14:03:23.547 [main] INFO cn.lbs.socket.communication.SocketServer - Waiting <span class="keyword">for</span> message from client /127.0.0.1:4602 </span><br><span class="line">14:03:23.547 [main] INFO cn.lbs.socket.communication.SocketServer - Get  message <span class="string">'YOLO'</span> from client /127.0.0.1:4602</span><br><span class="line">14:03:23.547 [main] INFO cn.lbs.socket.communication.SocketServer - Response message <span class="string">'Hello,I get the message'</span> to Client /127.0.0.1:4602 </span><br><span class="line">14:03:23.547 [main] INFO cn.lbs.socket.communication.SocketServer - Waiting <span class="keyword">for</span> message from client /127.0.0.1:4602</span><br></pre></td></tr></table></figure><p><strong>客户端</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 要连接的服务端IP地址和端口</span></span><br><span class="line">        String host = <span class="string">"127.0.0.1"</span>;</span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">8081</span>;</span><br><span class="line">        <span class="comment">// 与服务端建立连接</span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(host, port);</span><br><span class="line">        System.out.println(<span class="string">"Connect to "</span>+socket.getRemoteSocketAddress()+<span class="string">" Success"</span>);</span><br><span class="line">        <span class="comment">// 建立连接后获得输出流</span></span><br><span class="line">        OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">        InputStream inputStream = socket.getInputStream();</span><br><span class="line">        String[] messages = &#123;<span class="string">"Hello World"</span>,<span class="string">"你好，世界"</span>,<span class="string">"YOLO"</span>&#125;;</span><br><span class="line">        <span class="keyword">byte</span>[] receivebytes,sendBytes;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(String message:messages)&#123;</span><br><span class="line">            System.out.println();</span><br><span class="line">            System.out.println(<span class="string">"Send &#123;"</span>+message+<span class="string">"&#125;to Server"</span>);</span><br><span class="line">            <span class="comment">//首先需要计算得知消息的长度</span></span><br><span class="line">            sendBytes = message.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line">            <span class="comment">//然后将消息的长度优先发送出去</span></span><br><span class="line">            outputStream.write(sendBytes.length &gt;&gt;<span class="number">8</span>);</span><br><span class="line">            outputStream.write(sendBytes.length);</span><br><span class="line">            <span class="comment">//然后将消息再次发送出去</span></span><br><span class="line">            outputStream.write(sendBytes);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"Waiting for Response"</span>);</span><br><span class="line">            <span class="comment">// 首先读取两个字节表示的长度,read()方法会阻塞进程</span></span><br><span class="line">            <span class="keyword">int</span> first = inputStream.read();</span><br><span class="line">            <span class="comment">//如果读取的值为-1 说明到了流的末尾，Socket已经被关闭了，此时将不能再去读取</span></span><br><span class="line">            <span class="keyword">if</span>(first==-<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"Close connection"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> second = inputStream.read();</span><br><span class="line">            <span class="keyword">int</span> length = (first &lt;&lt; <span class="number">8</span>) + second;</span><br><span class="line">            <span class="comment">// 然后构造一个指定长的byte数组</span></span><br><span class="line">            receivebytes = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">            <span class="comment">// 然后读取指定长度的消息即可</span></span><br><span class="line">            inputStream.read(receivebytes);</span><br><span class="line">            System.out.println(<span class="string">"Get Response from Server: "</span> + <span class="keyword">new</span> String(receivebytes, <span class="string">"UTF-8"</span>));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">13:41:06.058 [main] INFO cn.lbs.socket.communication.SocketClient - The client /127.0.0.1:4364 successfully connects to the server /127.0.0.1:8081</span><br><span class="line">13:41:06.065 [main] INFO cn.lbs.socket.communication.SocketClient - The client /127.0.0.1:4364 sends a message <span class="string">'Hello World'</span> to the server </span><br><span class="line">13:41:06.065 [main] INFO cn.lbs.socket.communication.SocketClient - Client /127.0.0.1:4364 is  waiting <span class="keyword">for</span> Response</span><br><span class="line">13:41:06.068 [main] INFO cn.lbs.socket.communication.SocketClient - Get response message <span class="string">'Hello (/127.0.0.1:4364),I get the message'</span> from Server</span><br><span class="line">13:41:06.068 [main] INFO cn.lbs.socket.communication.SocketClient - The client /127.0.0.1:4364 sends a message <span class="string">'你好，世界'</span> to the server </span><br><span class="line">13:41:06.069 [main] INFO cn.lbs.socket.communication.SocketClient - Client /127.0.0.1:4364 is  waiting <span class="keyword">for</span> Response</span><br><span class="line">13:41:06.069 [main] INFO cn.lbs.socket.communication.SocketClient - Get response message <span class="string">'Hello (/127.0.0.1:4364),I get the message'</span> from Server</span><br><span class="line">13:41:06.069 [main] INFO cn.lbs.socket.communication.SocketClient - The client /127.0.0.1:4364 sends a message <span class="string">'YOLO'</span> to the server </span><br><span class="line">13:41:06.069 [main] INFO cn.lbs.socket.communication.SocketClient - Client /127.0.0.1:4364 is  waiting <span class="keyword">for</span> Response</span><br><span class="line">13:41:06.069 [main] INFO cn.lbs.socket.communication.SocketClient - Get response message <span class="string">'Hello (/127.0.0.1:4364),I get the message'</span> from Server</span><br></pre></td></tr></table></figure><h2 id="服务端并发"><a href="#服务端并发" class="headerlink" title="服务端并发"></a>服务端并发</h2><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><p>在实际生产中，创建的线程会交给线程池来处理，这样可以达到线程复用的效果，也可以防止短时间内高并发，<code>new Thread</code>短时间创建大量线程，导致资源耗尽，服务挂掉</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="comment">//注意指定编码格式，发送方和接收方一定要统一，建议使用UTF-8</span></span><br><span class="line">    <span class="keyword">final</span> String CHARSET=<span class="string">"UTF-8"</span>;</span><br><span class="line">    ExecutorService threadPool;</span><br><span class="line">    ServerSocket serverSocket;</span><br><span class="line">    SocketAddress serverAddress;</span><br><span class="line"></span><br><span class="line">    Server(<span class="keyword">int</span> port) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">         threadPool = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">// 创建具有指定端口的服务器套接字</span></span><br><span class="line">        serverSocket = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">        serverAddress= serverSocket.getLocalSocketAddress();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// accept() 会阻塞进程，直到建立新连接，成功建立连接后会返回一个新的Socket。</span></span><br><span class="line">            log.info(<span class="string">"Waiting for new connection(Listening on : &#123;&#125;)"</span>, serverAddress);</span><br><span class="line">            Socket socket = serverSocket.accept();</span><br><span class="line">            log.info(<span class="string">"There is a new  connection &#123;&#125;"</span>, socket);</span><br><span class="line">            threadPool.submit(<span class="keyword">new</span> SocketTask(socket));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Server(<span class="number">8081</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SocketTask</span>  <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">//注意指定编码格式，发送方和接收方一定要统一，建议使用UTF-8</span></span><br><span class="line">    <span class="keyword">final</span> String CHARSET=<span class="string">"UTF-8"</span>;</span><br><span class="line">    Socket socket;</span><br><span class="line">    SocketTask(Socket socket)&#123;</span><br><span class="line">        <span class="keyword">this</span>.socket=socket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 建立好连接后，从socket中获取输入、输出流、客户端信息</span></span><br><span class="line">            InputStream inputStream = socket.getInputStream();</span><br><span class="line">            OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">            SocketAddress clientAddress = socket.getRemoteSocketAddress();</span><br><span class="line">            <span class="comment">//建立缓冲区用于读取或写入</span></span><br><span class="line">            <span class="keyword">byte</span>[] receiveBytes, sendBytes;</span><br><span class="line">            <span class="comment">// 因为可以复用Socket且能判断长度，所以可以一个Socket用到底</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                log.info(<span class="string">"Waiting for message from client &#123;&#125; "</span>, clientAddress);</span><br><span class="line">                <span class="comment">// 首先读取两个字节表示的长度,read()方法会阻塞进程</span></span><br><span class="line">                <span class="keyword">int</span> firstByte = inputStream.read();</span><br><span class="line">                <span class="comment">//如果读取的值为-1 说明到了流的末尾，Socket已经被关闭了，此时将不能再去读取</span></span><br><span class="line">                <span class="keyword">if</span> (firstByte == -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> secondByte = inputStream.read();</span><br><span class="line">                <span class="keyword">int</span> messageLen = (firstByte &lt;&lt; <span class="number">8</span>) + secondByte;</span><br><span class="line">                <span class="comment">// 然后构造一个指定长的byte数组</span></span><br><span class="line">                receiveBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[messageLen];</span><br><span class="line">                <span class="comment">// 然后读取指定长度的消息即可</span></span><br><span class="line">                inputStream.read(receiveBytes);</span><br><span class="line">                log.info(<span class="string">"Get  message '&#123;&#125;' from client &#123;&#125;"</span>, <span class="keyword">new</span> String(receiveBytes, CHARSET), clientAddress);</span><br><span class="line">                String respStr = <span class="string">"Hello,I get the message"</span>;</span><br><span class="line">                log.info(<span class="string">"Response message '&#123;&#125;' to Client &#123;&#125; "</span>, respStr, clientAddress);</span><br><span class="line">                <span class="comment">//首先需要计算得知消息的长度</span></span><br><span class="line">                sendBytes = respStr.getBytes(CHARSET);</span><br><span class="line">                <span class="comment">//然后将消息的长度优先发送出去</span></span><br><span class="line">                outputStream.write(sendBytes.length &gt;&gt; <span class="number">8</span>);</span><br><span class="line">                outputStream.write(sendBytes.length);</span><br><span class="line">                <span class="comment">//然后将消息再次发送出去</span></span><br><span class="line">                outputStream.write(sendBytes);</span><br><span class="line">                outputStream.flush();</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(<span class="string">"关闭连接&#123;&#125;"</span>,socket);</span><br><span class="line">            socket.shutdownOutput();</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>并发模拟</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiClient</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置连接的服务端IP地址和端口</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String HOST = <span class="string">"127.0.0.1"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">8081</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CLIENTSNUM=<span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService threadPool= Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;CLIENTSNUM;i++)&#123;</span><br><span class="line">            threadPool.submit(<span class="keyword">new</span> ClientTask(HOST,PORT));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClientTask</span> <span class="keyword">implements</span>  <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">//注意指定编码格式，发送方和接收方一定要统一，建议使用UTF-8</span></span><br><span class="line">    <span class="keyword">final</span> String CHARSET=<span class="string">"UTF-8"</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> MESSAGENUM=<span class="number">100</span>;</span><br><span class="line">    Socket socket ;</span><br><span class="line"></span><br><span class="line">    OutputStream outputStream;</span><br><span class="line">    InputStream inputStream;</span><br><span class="line">    SocketAddress   localAddress;</span><br><span class="line">    SocketAddress remoteAddress;</span><br><span class="line"></span><br><span class="line">    ClientTask(String host,<span class="keyword">int</span> port) <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 与服务端建立连接</span></span><br><span class="line">        <span class="comment">// 建立连接后获得输出、输出流、连接信息</span></span><br><span class="line">        socket=<span class="keyword">new</span> Socket(host,port);</span><br><span class="line">        outputStream = socket.getOutputStream();</span><br><span class="line">        inputStream=socket.getInputStream();</span><br><span class="line">        localAddress=socket.getLocalSocketAddress();</span><br><span class="line">        remoteAddress=socket.getRemoteSocketAddress();</span><br><span class="line">        log.info(<span class="string">"The client &#123;&#125; successfully connects to the server &#123;&#125;"</span>,localAddress,remoteAddress);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String[] messages = &#123;<span class="string">"Hello World"</span>,<span class="string">"你好，世界"</span>,<span class="string">"YOLO"</span>&#125;;</span><br><span class="line">            <span class="keyword">byte</span>[] receiveBytes,sendBytes;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;MESSAGENUM;i++) &#123;</span><br><span class="line">                String message=RandomStringUtils.random(<span class="number">10</span>, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">                inputStream = socket.getInputStream();</span><br><span class="line">                outputStream = socket.getOutputStream();</span><br><span class="line">                log.info(<span class="string">"The client &#123;&#125; sends a message '&#123;&#125;' to the server "</span>, localAddress, message);</span><br><span class="line">                <span class="comment">//首先需要计算得知消息的长度</span></span><br><span class="line">                sendBytes = message.getBytes(CHARSET);</span><br><span class="line">                <span class="comment">//然后将消息的长度优先发送出去</span></span><br><span class="line">                outputStream.write(sendBytes.length &gt;&gt; <span class="number">8</span>);</span><br><span class="line">                outputStream.write(sendBytes.length);</span><br><span class="line">                <span class="comment">//然后将消息再次发送出去</span></span><br><span class="line">                outputStream.write(sendBytes);</span><br><span class="line">                outputStream.flush();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">//获取响应</span></span><br><span class="line">                log.info(<span class="string">"Client &#123;&#125; is  waiting for Response"</span>, localAddress);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 首先读取两个字节表示的长度,read()方法会阻塞进程</span></span><br><span class="line">                <span class="keyword">int</span> firstByte = inputStream.read();</span><br><span class="line">                <span class="comment">//如果读取的值为-1 说明到了流的末尾，Socket已经被关闭了，此时将不能再去读取</span></span><br><span class="line">                <span class="keyword">if</span> (firstByte == -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> secondByte = inputStream.read();</span><br><span class="line">                <span class="keyword">int</span> messageLen = (firstByte &lt;&lt; <span class="number">8</span>) + secondByte;</span><br><span class="line">                <span class="comment">// 然后构造一个指定长的byte数组</span></span><br><span class="line">                receiveBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[messageLen];</span><br><span class="line">                <span class="comment">// 然后读取指定长度的消息即可</span></span><br><span class="line">                inputStream.read(receiveBytes);</span><br><span class="line">                log.info(<span class="string">"Get response message '&#123;&#125;' from Server"</span>, <span class="keyword">new</span> String(receiveBytes, CHARSET));</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(<span class="string">"关闭连接&#123;&#125;"</span>,socket);</span><br><span class="line">            socket.shutdownOutput();</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="SocketOptions"><a href="#SocketOptions" class="headerlink" title="SocketOptions"></a>SocketOptions</h3><ul><li>int TCP_NODELAY = 0x0001：对此连接禁用 Nagle 算法。</li><li>int SO_BINDADDR = 0x000F：此选项为 TCP 或 UDP 套接字在 IP 地址头中设置服务类型或流量类字段。</li><li>int SO_REUSEADDR = 0x04：设置套接字的 SO_REUSEADDR。</li><li>int SO_BROADCAST = 0x0020：此选项启用和禁用发送广播消息的处理能力。</li><li>int IP_MULTICAST_IF = 0x10：设置用于发送多播包的传出接口。</li><li>int IP_MULTICAST_IF2 = 0x1f：设置用于发送多播包的传出接口。</li><li>int IP_MULTICAST_LOOP = 0x12：此选项启用或禁用多播数据报的本地回送。</li><li>int IP_TOS = 0x3：此选项为 TCP 或 UDP 套接字在 IP 地址头中设置服务类型或流量类字段。</li><li>int SO_LINGER = 0x0080：指定关闭时逗留的超时值。</li><li>int <strong>SO_TIMEOUT</strong> = 0x1006：设置阻塞 Socket 操作的超时值： ServerSocket.accept(); SocketInputStream.read(); DatagramSocket.receive(); 选项必须在进入阻塞操作前设置才能生效。</li><li>int SO_SNDBUF = 0x1001：设置传出网络 I/O 的平台所使用的基础缓冲区大小的提示。</li><li>int SO_RCVBUF = 0x1002：设置传入网络 I/O 的平台所使用基础缓冲区的大小的提示。</li><li>int <strong>SO_KEEPALIVE</strong> = 0x0008：为 TCP 套接字设置 keepalive 选项时，对于构建长时间连接的Socket还是配置上SO_KEEPALIVE比较好</li><li>int SO_OOBINLINE = 0x1003：置 OOBINLINE 选项时，在套接字上接收的所有 TCP 紧急数据都将通过套接字输入流接收。</li></ul><h3 id="Socket与操作系统"><a href="#Socket与操作系统" class="headerlink" title="Socket与操作系统"></a>Socket与操作系统</h3><p>Socket实际上是归属于应用层，使用的是运输层的TCP。在三次握手操作后，系统才会将Socket连接交给应用层，ServerSocket 才知道有一个连接过来了。那么系统当接收到一个TCP连接请求后，如果上层还没有接受它（假如SocketServer循环处理Socket，一次一个），那么系统将缓存这个连接请求，缓存是有限制的，当超过指定数量后，系统将会拒绝连接。</p><p>换句话说，<strong>系统接收TCP连接请求放入缓存队列，而SocketServer从缓存队列获取Socket。</strong></p><p>客户端为了让服务端知道自己已经发送完消息，可以选择关闭输出流<strong><code>socket.shutdownOutput()</code>，这个操作对应着四次挥手的第一次</strong>，这些都由操作系统去执行，只是Socket隐藏底层逻辑的种种细节。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://www.apiref.com/java11-zh/java.base/java/net/ServerSocket.html" target="_blank" rel="noopener">ServerSocket - Java 11中文版 - API参考文档 (apiref.com)</a></p><p><a href="https://www.apiref.com/java11-zh/java.base/java/net/Socket.html" target="_blank" rel="noopener">Socket - Java 11中文版 - API参考文档 (apiref.com)</a></p><p><a href="https://www.apiref.com/java11-zh/java.base/java/net/InetAddress.html" target="_blank" rel="noopener">InetAddress - Java 11中文版 - API参考文档 (apiref.com)</a></p><p><a href="https://www.cnblogs.com/yiwangzhibujian/p/7107785.html" target="_blank" rel="noopener">【Socket】Java Socket编程基础及深入讲解 - 已往之不谏 - 博客园 (cnblogs.com)</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java-Socket-编程&quot;&gt;&lt;a href=&quot;#Java-Socket-编程&quot; class=&quot;headerlink&quot; title=&quot;Java Socket 编程&quot;&gt;&lt;/a&gt;Java Socket 编程&lt;/h1&gt;&lt;h2 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h2&gt;&lt;p&gt;首先需要了解两个类：Socket和SocketServer。&lt;/p&gt;
&lt;h3 id=&quot;SocketServer&quot;&gt;&lt;a href=&quot;#SocketServer&quot; class=&quot;headerlink&quot; title=&quot;SocketServer&quot;&gt;&lt;/a&gt;SocketServer&lt;/h3&gt;&lt;p&gt;SocketServer实现了服务器套接字。 服务器套接字会等待通过网络进入的请求。 用户可以根据该请求执行某些操作，然后将结果返回给请求者（也可以选择不返回）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="javaio" scheme="http://blog.onebug.tech/categories/javaio/"/>
    
    
      <category term="java" scheme="http://blog.onebug.tech/tags/java/"/>
    
      <category term="笔记" scheme="http://blog.onebug.tech/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="IO" scheme="http://blog.onebug.tech/tags/IO/"/>
    
      <category term="socket" scheme="http://blog.onebug.tech/tags/socket/"/>
    
      <category term="网络编程" scheme="http://blog.onebug.tech/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
      <category term="tcp" scheme="http://blog.onebug.tech/tags/tcp/"/>
    
  </entry>
  
</feed>
