<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>冰冻橘子的自留地</title>
  
  
  <link href="http://blog.onebug.tech/atom.xml" rel="self"/>
  
  <link href="http://blog.onebug.tech/"/>
  <updated>2023-03-23T15:29:43.014Z</updated>
  <id>http://blog.onebug.tech/</id>
  
  <author>
    <name>冰冻橘子</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker使用大全</title>
    <link href="http://blog.onebug.tech/2022/02/23/%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/docker/"/>
    <id>http://blog.onebug.tech/2022/02/23/%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/docker/</id>
    <published>2022-02-22T16:00:00.000Z</published>
    <updated>2023-03-23T15:29:43.014Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>以Ubuntu为例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove docker docker-engine docker.io containerd runc</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg \</span><br><span class="line">    lsb-release</span><br><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</span><br><span class="line"><span class="built_in">echo</span> \</span><br><span class="line">  <span class="string">&quot;deb [arch=<span class="subst">$(dpkg --print-architecture)</span> signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \</span></span><br><span class="line"><span class="string">  <span class="subst">$(lsb_release -cs)</span> stable&quot;</span> | sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install docker-ce docker-ce-cli containerd.io</span><br><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="image"><a href="#image" class="headerlink" title="image"></a>image</h3><p>Docker的镜像可以理解是一个只读的静态模板，类似于我们在装系统的时候用到的.iso文件。</p><p>列出所有的镜像：<code>docker images</code>。</p><h3 id="container"><a href="#container" class="headerlink" title="container"></a>container</h3><p><strong>container</strong>则相对而言是一个动态的instance，可以理解为我们装好了系统之后的某一台计算机，<strong>可以开机，关机，重启等等，也可以被格式化（删除）</strong>。</p><p>列出所有的容器：<code>docker ps -a</code>。</p><h3 id="Repository"><a href="#Repository" class="headerlink" title="Repository"></a>Repository</h3><p>我们可以把构建后的镜像上传到服务器，从而可以在任何地方使用到这个镜像。一个Docker Registry中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。我们可以通过<code>&lt;仓库名&gt;:&lt;标签&gt;</code>的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以<code>latest</code>作为默认标签。<br>最常使用的Registry公开服务是官方的<a href="http://hub.docker.com/">Docker Hub</a> ，这也是默认的Registry，并拥有大量的高质量的官方镜像。</p><p>登录Registry：<code>docker login xxx</code></p><h2 id="基本的使用"><a href="#基本的使用" class="headerlink" title="基本的使用"></a>基本的使用</h2><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><ul><li>拉取镜像：<code>docker pull ubuntu</code></li><li>推送镜像：<code>docker push username/repository:tag</code></li></ul><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><ul><li><p>运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run  -d --name <span class="string">&quot;test&quot;</span> -it ubuntu bash</span><br><span class="line"><span class="comment">#-d 后台运行</span></span><br><span class="line">docker <span class="built_in">exec</span> -it <span class="built_in">test</span> bash</span><br><span class="line"><span class="comment">#-i 以交互模式运行容器</span></span><br><span class="line"><span class="comment">#-t 为容器重新分配一个伪输入终端</span></span><br><span class="line"><span class="comment">#在容器内执行/bin/bash命令</span></span><br></pre></td></tr></table></figure></li><li><p>停止：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker stop <span class="built_in">test</span></span><br><span class="line"><span class="comment">#删除</span></span><br><span class="line"><span class="comment">#docker rm test</span></span><br></pre></td></tr></table></figure></li><li><p>恢复（物理机关机重启）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start <span class="built_in">test</span>  </span><br></pre></td></tr></table></figure></li><li><p>提交当前container为新镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit <span class="built_in">test</span>  dev:cpp </span><br></pre></td></tr></table></figure></li></ul><h1 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h1><h2 id="定制镜像"><a href="#定制镜像" class="headerlink" title="定制镜像"></a>定制镜像</h2><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p>镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，这个脚本就是 Dockerfile。Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> debian:stretch</span><br><span class="line"><span class="comment">#FROM 就是指定 基础镜像，因此一个 Dockerfile 中 FROM 是必备的指令，并且必须是第一条指令。</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -x; buildDeps=<span class="string">&#x27;gcc libc6-dev make wget&#x27;</span> \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt-get update \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt-get install -y <span class="variable">$buildDeps</span> \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; wget -O redis.tar.gz <span class="string">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">mkdir</span> -p /usr/src/redis \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; make -C /usr/src/redis \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; make -C /usr/src/redis install \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/* \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">rm</span> redis.tar.gz \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">rm</span> -r /usr/src/redis \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt-get purge -y --auto-remove <span class="variable">$buildDeps</span></span></span><br><span class="line"><span class="comment">#同一目的的所有命令应该归到同一层</span></span><br><span class="line"><span class="comment">#镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</span></span><br></pre></td></tr></table></figure><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>在 <code>Dockerfile</code> 文件所在目录执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build -t redes:v3 . </span><br><span class="line"># . 是在指定上下文的目录，COPY需要用到该设置</span><br></pre></td></tr></table></figure><h3 id="Dockerfile指令"><a href="#Dockerfile指令" class="headerlink" title="Dockerfile指令"></a>Dockerfile指令</h3><p><code>Dockerfile</code> 功能很强大，它提供了十多个指令：</p><ul><li><code>COPY  &lt;源路径&gt;... &lt;目标路径&gt;</code>：指令将从构建上下文目录中 <code>&lt;源路径&gt;</code> 的文件复制到新的一层的镜像内的 <code>&lt;目标路径&gt;</code> 位置</li><li><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code>：设置环境变量</li><li><code>CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]</code>：<code>CMD</code> 指令就是用于指定默认的容器主进程的启动命令的。容器内没有后台服务的概念，我们应该直接执行可执行文件，并且要求以前台形式运行。</li></ul><p>其他命令详见<a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile">Dockerfile 指令详解 - Docker —— 从入门到实践 (gitbook.io)</a></p><h2 id="VSCode"><a href="#VSCode" class="headerlink" title="VSCode"></a>VSCode</h2><h3 id="noroot运行"><a href="#noroot运行" class="headerlink" title="noroot运行"></a>noroot运行</h3><p>vscode 使用docker必须设置rootless运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dockerd-rootless-setuptool.sh install</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li><p>安装Remote - Containers拓展</p></li><li><p>在远程服务器上启动Container</p></li><li><p>VSCode连接远程服务器</p></li><li><p>选择对应Container-&gt;Attach</p></li><li><p>打开文件夹</p></li></ul><h2 id="高级配置"><a href="#高级配置" class="headerlink" title="高级配置"></a>高级配置</h2><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><h4 id="网络模式"><a href="#网络模式" class="headerlink" title="网络模式"></a>网络模式</h4><p>Docker使用Linux桥接，在宿主机虚拟一个Docker容器网桥(docker0)，Docker启动一个容器时会根据Docker网桥的网段分配给容器一个IP地址，称为Container-IP，同时Docker网桥是每个容器的默认网关。因为在<strong>同一宿主机内的容器都接入同一个网桥</strong>，这样容器之间就能够通过容器的Container-IP直接通信。</p><p>除了默认的bridge模式，docker还提供三种网络模式</p><table><thead><tr><th>网络模式</th><th>配置</th><th>说明</th></tr></thead><tbody><tr><td>bridge模式</td><td>–net&#x3D;bridge</td><td>（<strong>默认</strong>为该模式）此模式会为每一个容器分配、设置IP等，并将容器连接到一个docker0虚拟网桥。<img src="https://image.onebug.tech/202203062318773.png" alt="docker网络模式-bridge"></td></tr><tr><td>host模式</td><td>–net&#x3D;host</td><td>容器和宿主机共享网络空间。<img src="https://image.onebug.tech/202203062318271.png" alt="docker网络模式-host"></td></tr><tr><td>container模式</td><td>–net&#x3D;container:NAME_or_ID</td><td>容器和另外一个容器共享网络空间。<img src="https://image.onebug.tech/202203062317644.png" alt="docker网络模式container"></td></tr><tr><td>none模式</td><td>–net&#x3D;none</td><td>该模式关闭了容器的网络功能。</td></tr></tbody></table><h4 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h4><p>默认的Docker网桥是宿主机虚拟出来的，并不是真实存在的网络设备，外部网络是无法寻址到的，这也意味着外部网络无法通过访问到容器。如果容器希望外部访问能够访问到，可以通过映射容器端口到宿主主机（端口映射），即<code>docker run</code>创建容器时候通过 <code>-p</code> 或 <code>-P</code> 参数来启用，访问容器的时候就通过 [宿主机IP]:[容器端口] 访问容器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8000:80 -it ubuntu /bin/bash</span><br><span class="line"><span class="comment">#将容器的80端口映射到宿主机的8000端口上</span></span><br></pre></td></tr></table></figure><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>Docker容器启动的时候，如果要挂载宿主机的一个目录，可以用<code>-v</code>参数指定，冒号<code>:</code>前面的目录是宿主机目录，后面的目录是容器内目录。这样在容器启动后，容器内会自动创建<code>/project</code>的目录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-v /src/myproject:/project</span><br></pre></td></tr></table></figure><h3 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h3><ul><li>设置工作目录：<code>-w /project</code></li><li>退出时清除自动清理容器内部的文件系统：<code>-rm</code></li></ul><h2 id="在Docker中使用GPU"><a href="#在Docker中使用GPU" class="headerlink" title="在Docker中使用GPU"></a>在Docker中使用GPU</h2><h3 id="安装nvidia-docker2"><a href="#安装nvidia-docker2" class="headerlink" title="安装nvidia-docker2"></a>安装nvidia-docker2</h3><blockquote><p>需要提前在宿主机上安装显卡<a href="https://www.nvidia.com/Download/index.aspx?lang=en-us">驱动</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#设置NVIDIA Container Toolkit</span><br><span class="line">distribution=$(. /etc/os-release;echo $ID$VERSION_ID) \</span><br><span class="line">   &amp;&amp; curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | sudo apt-key add - \</span><br><span class="line">   &amp;&amp; curl -s -L https://nvidia.github.io/nvidia-docker/$distribution/nvidia-docker.list | sudo tee /etc/apt/sources.list.d/nvidia-docker.list</span><br><span class="line">#安装nvidia-docker2</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y nvidia-docker2</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>添加<code>--gpus &lt;device id&gt; </code>参数，<code>--gpus all</code>使用所有的GPU。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run --rm --gpus all nvidia/cuda:11.0-base nvidia-smi</span><br></pre></td></tr></table></figure><h2 id="GUI程序的运行"><a href="#GUI程序的运行" class="headerlink" title="GUI程序的运行"></a>GUI程序的运行</h2><h3 id="X11"><a href="#X11" class="headerlink" title="X11"></a>X11</h3><p>最简单的方法是暴露宿主机的xhost，这样容器就可以通过对X11的unix套接字的读写间接渲染程序界面。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#调整Xserver权限</span></span><br><span class="line">xhost +<span class="built_in">local</span>:root</span><br><span class="line"><span class="comment">#docker 设置</span></span><br><span class="line">docker run -it \</span><br><span class="line">    --<span class="built_in">env</span>=<span class="string">&quot;DISPLAY&quot;</span> \</span><br><span class="line">    --<span class="built_in">env</span>=<span class="string">&quot;QT_X11_NO_MITSHM=1&quot;</span> \</span><br><span class="line">    --volume=<span class="string">&quot;/tmp/.X11-unix:/tmp/.X11-unix:rw&quot;</span> \</span><br><span class="line">    osrf/ros:indigo-desktop-full \</span><br><span class="line">    rqt</span><br></pre></td></tr></table></figure><h3 id="x11docker"><a href="#x11docker" class="headerlink" title="x11docker"></a>x11docker</h3><p>x11docker允许在Linux容器中运行图形化桌面应用程序。</p><ul><li><p>安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://raw.githubusercontent.com/mviereck/x11docker/master/x11docker | sudo bash -s -- --update</span><br><span class="line">docker pull x11docker/xserver</span><br></pre></td></tr></table></figure></li><li><p>使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x11docker IMAGENAME [COMMAND] </span><br></pre></td></tr></table></figure><p>可选参数：</p><ul><li><code>--desktop</code>提供桌面环境。</li><li><code>--gpu</code>用于硬件加速</li></ul></li></ul><blockquote><p><a href="https://docs.docker.com/engine/install/">Install Docker Engine | Docker Documentation</a></p><p><a href="https://yeasy.gitbook.io/docker_practice/">前言 - Docker —— 从入门到实践 (gitbook.io)</a></p><p><a href="https://segmentfault.com/a/1190000040335988">docker四种网络模式 - SegmentFault 思否</a></p><p><a href="https://github.com/NVIDIA/nvidia-docker">NVIDIA&#x2F;nvidia-docker: Build and run Docker containers leveraging NVIDIA GPUs (github.com)</a></p><p><a href="http://wiki.ros.org/docker/Tutorials/GUI">docker&#x2F;Tutorials&#x2F;GUI - ROS Wiki</a></p><p><a href="https://github.com/mviereck/x11docker">mviereck&#x2F;x11docker: Run GUI applications and desktops in docker and podman containers. Focus on security. (github.com)</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;基本&quot;&gt;&lt;a href=&quot;#基本&quot; class=&quot;headerlink&quot; title=&quot;基本&quot;&gt;&lt;/a&gt;基本&lt;/h1&gt;&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;以Ubuntu为例：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get remove docker docker-engine docker.io containerd runc&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get update&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get install \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ca-certificates \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    curl \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    gnupg \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    lsb-release&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;&amp;quot;deb [arch=&lt;span class=&quot;subst&quot;&gt;$(dpkg --print-architecture)&lt;/span&gt; signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;  &lt;span class=&quot;subst&quot;&gt;$(lsb_release -cs)&lt;/span&gt; stable&amp;quot;&lt;/span&gt; | sudo &lt;span class=&quot;built_in&quot;&gt;tee&lt;/span&gt; /etc/apt/sources.list.d/docker.list &amp;gt; /dev/null&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get update&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get install docker-ce docker-ce-cli containerd.io&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo docker run hello-world&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="工具" scheme="http://blog.onebug.tech/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="docker" scheme="http://blog.onebug.tech/tags/docker/"/>
    
    <category term="gpu" scheme="http://blog.onebug.tech/tags/gpu/"/>
    
    <category term="gui" scheme="http://blog.onebug.tech/tags/gui/"/>
    
  </entry>
  
  <entry>
    <title>多类型设备时间同步方案</title>
    <link href="http://blog.onebug.tech/2022/02/21/%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/%E5%A4%9A%E8%AE%BE%E5%A4%87%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5/"/>
    <id>http://blog.onebug.tech/2022/02/21/%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/%E5%A4%9A%E8%AE%BE%E5%A4%87%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5/</id>
    <published>2022-02-20T16:00:00.000Z</published>
    <updated>2023-03-23T15:29:43.016Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PTP"><a href="#PTP" class="headerlink" title="PTP"></a>PTP</h1><h2 id="安装linuxptp"><a href="#安装linuxptp" class="headerlink" title="安装linuxptp"></a>安装linuxptp</h2><h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> http://git.code.sf.net/p/linuxptp/code linuxptp</span><br><span class="line"><span class="built_in">cd</span> linuxptp</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="deb-安装"><a href="#deb-安装" class="headerlink" title="deb 安装"></a>deb 安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install linuxptp</span><br></pre></td></tr></table></figure><h2 id="检查网卡状态"><a href="#检查网卡状态" class="headerlink" title="检查网卡状态"></a>检查网卡状态</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ethtool -T enp0s31f6</span><br></pre></td></tr></table></figure><p><img src="https://image.onebug.tech/202203062307735.png" alt="image-20220216102002147"></p><h2 id="配置PTP时钟"><a href="#配置PTP时钟" class="headerlink" title="配置PTP时钟"></a>配置PTP时钟</h2><h3 id="设备端"><a href="#设备端" class="headerlink" title="设备端"></a>设备端</h3><h4 id="禾赛雷达"><a href="#禾赛雷达" class="headerlink" title="禾赛雷达"></a>禾赛雷达</h4><p><img src="https://image.onebug.tech/image-20220216102230988.png" alt="image-20220216102230988"></p><h4 id="Livox"><a href="#Livox" class="headerlink" title="Livox"></a>Livox</h4><p>不需要配置</p><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ptp4l -i enp0s31f6 -m</span><br></pre></td></tr></table></figure><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>如果网络中出现 <code>Sync Message</code> 数据，说明服务端ptp4l程序的master时钟功能正常运行，如果网络中出现 <code>Delay_Req Message</code> 数据，说明设备端slave时钟功能正常运行。</p><p><img src="https://image.onebug.tech/image-20220216103826706.png" alt="image-20220216103826706"></p><h1 id="接入NTP"><a href="#接入NTP" class="headerlink" title="接入NTP"></a>接入NTP</h1><h2 id="配置PTP硬件时间"><a href="#配置PTP硬件时间" class="headerlink" title="配置PTP硬件时间"></a>配置PTP硬件时间</h2><p>让PTP硬件时钟和系统时间同步</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo phc2sys -c enp0s31f6 -s CLOCK_REALTIME -O 0 </span><br></pre></td></tr></table></figure><h2 id="搭建NTP服务"><a href="#搭建NTP服务" class="headerlink" title="搭建NTP服务"></a>搭建NTP服务</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ntp</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/ntp.conf</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># For more information about this file, see the man pages</span></span><br><span class="line"><span class="comment"># ntp.conf(5), ntp_acc(5), ntp_auth(5), ntp_clock(5), ntp_misc(5), ntp_mon(5).</span></span><br><span class="line"> </span><br><span class="line"><span class="attribute">driftfile</span> /var/lib/ntp/drift  <span class="comment">#默认即可。driftfile用来指定记录本机与上层NTP server之间的频率误差。单位是百万分之一秒。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Permit time synchronization with our time source, but do not</span></span><br><span class="line"><span class="comment"># permit the source to query or modify the service on this system.</span></span><br><span class="line">restrict default nomodify notrap nopeer noquery 　　　　</span><br><span class="line"><span class="comment">#restrict用来管理权限控制。</span></span><br><span class="line"><span class="comment">#格式为 restrict [单个ip|网络|default] parameter　　　　　　</span></span><br><span class="line"><span class="comment">#parameter：　　　　　　　　</span></span><br><span class="line"><span class="comment">#ignore：拒绝所有的ntp连接　　　　　　　　</span></span><br><span class="line"><span class="comment">#nomodify：客户端不能使用ntpc和ntpq这两个程序来更改服务器的时间参数，但客户端可以通过此主机来进行网络校时。　　　　　　　　</span></span><br><span class="line"><span class="comment">#noquery：客户端不能使用ntpc和ntpq等命令来查询时间服务器，等于不提供网络校时服务。　　　　　　　　</span></span><br><span class="line"><span class="comment">#notrap：不提供trap这个网络时间登陆的功能　　　　　　　　</span></span><br><span class="line"><span class="comment">#notrust：拒绝没有认证的客户端　　</span></span><br><span class="line"><span class="comment">#示例：restrict 156.0.26.7  nomodify 9 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Permit all access over the loopback interface.  This could</span></span><br><span class="line"><span class="comment"># be tightened as well, but to do so would effect some of</span></span><br><span class="line"><span class="comment"># the administrative functions.</span></span><br><span class="line">restrict <span class="number">127.0.0.1</span>  <span class="comment">#以下两条默认，放行本机来源</span></span><br><span class="line">restrict ::<span class="number">1</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># Hosts on local network are less restricted.</span></span><br><span class="line">restrict <span class="number">10.0.0.0</span> mask <span class="number">255.0.0.0</span> nomodify notrap</span><br><span class="line">restrict <span class="number">192.168.1.0</span> mask <span class="number">255.255.255.0</span> nomodify notrap</span><br><span class="line"></span><br><span class="line"><span class="comment"># Use public servers from the pool.ntp.org project.</span></span><br><span class="line"><span class="comment"># Please consider joining the pool (http://www.pool.ntp.org/join.html).</span></span><br><span class="line"><span class="comment">#server 0.centos.pool.ntp.org iburst #以下四条为默认，注释掉即可</span></span><br><span class="line"><span class="comment">#server 1.centos.pool.ntp.org iburst</span></span><br><span class="line"><span class="comment">#server 2.centos.pool.ntp.org iburst</span></span><br><span class="line"><span class="comment">#server 3.centos.pool.ntp.org iburst</span></span><br><span class="line"><span class="comment">#server：用来设置上层NTP服务器，说白了就是client向谁请求NTP时间同步。　　　　</span></span><br><span class="line"><span class="comment">#特别注意，在内网环境中由于无法连接到内网，所以没有办法向例如国家授时服务中心210.72.145.44同步时间　　　　</span></span><br><span class="line"><span class="comment">#只能将内网中的某台主机设置为server,用以向其他内网服务器提供NTP服务。</span></span><br><span class="line"></span><br><span class="line">server <span class="number">127.127.1.0</span> prefer </span><br><span class="line"><span class="comment">#以本机时间作为时间服务。内网中这个配置一定要加上，否则会导致NTP服务不可用　#prefer代表这台主机优先级最高。</span></span><br><span class="line"><span class="comment">#broadcast 192.168.1.255 autokey    # broadcast server</span></span><br><span class="line"><span class="comment">#broadcastclient            # broadcast client</span></span><br><span class="line"><span class="comment">#broadcast 224.0.1.1 autokey        # multicast server</span></span><br><span class="line"><span class="comment">#multicastclient 224.0.1.1        # multicast client</span></span><br><span class="line"><span class="comment">#manycastserver 239.255.254.254        # manycast server</span></span><br><span class="line"><span class="comment">#manycastclient 239.255.254.254 autokey # manycast client</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Enable public key cryptography.</span></span><br><span class="line"><span class="comment">#crypto</span></span><br><span class="line"></span><br><span class="line">includefile /etc/ntp/crypto/pw</span><br><span class="line"></span><br><span class="line"><span class="comment"># Key file containing the keys and key identifiers used when operating</span></span><br><span class="line"><span class="comment"># with symmetric key cryptography. </span></span><br><span class="line">keys /etc/ntp/keys <span class="comment">##除了restrict来限制客户端连接外，还可以通过秘钥方式来给客户端认证。</span></span><br><span class="line"><span class="comment"># Specify the key identifiers which are trusted.</span></span><br><span class="line"><span class="comment">#trustedkey 4 8 42</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Specify the key identifier to use with the ntpdc utility.</span></span><br><span class="line"><span class="comment">#requestkey 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Specify the key identifier to use with the ntpq utility.</span></span><br><span class="line"><span class="comment">#controlkey 8</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># Enable writing of statistics records.</span></span><br><span class="line"><span class="comment">#statistics clockstats cryptostats loopstats peerstats</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Disable the monitoring facility to prevent amplification attacks using ntpdc</span></span><br><span class="line"><span class="comment"># monlist command when default restrict does not include the noquery flag. See</span></span><br><span class="line"><span class="comment"># CVE-2013-5211 for more details.</span></span><br><span class="line"><span class="comment"># Note: Monitoring will not be disabled with the limited restriction flag.</span></span><br><span class="line">disable monitor</span><br></pre></td></tr></table></figure><h3 id="启动NTP服务"><a href="#启动NTP服务" class="headerlink" title="启动NTP服务"></a>启动NTP服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start ntp</span><br></pre></td></tr></table></figure><h2 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h2><h3 id="海康威视"><a href="#海康威视" class="headerlink" title="海康威视"></a>海康威视</h3><p><img src="https://image.onebug.tech/image-20220216114540564.png" alt="image-20220216114540564"></p><h2 id="验证-1"><a href="#验证-1" class="headerlink" title="验证"></a>验证</h2><p><img src="https://image.onebug.tech/image-20220216120052949.png" alt="image-20220216120052949"></p><blockquote><p><a href="http://yang.observer/2020/07/11/time-ntp/">计算机的时钟（一）：NTP协议 - Yang Blog</a></p><p><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/deployment_guide/ch-configuring_ptp_using_ptp4l">Chapter 23. Configuring PTP Using ptp4l Red Hat Enterprise Linux 6 | Red Hat Customer Portal</a></p><p><a href="https://livox-wiki-cn.readthedocs.io/zh_CN/latest/tutorials/timestamp_sychronization.html#id14">5. Livox设备时间同步 — Livox wiki 0.1 文档 (livox-wiki-cn.readthedocs.io)</a></p><p><a href="https://www.cnblogs.com/wxxjianchi/p/10531582.html">内网环境搭建NTP服务器 - HowOldAreYou - 博客园 (cnblogs.com)</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;PTP&quot;&gt;&lt;a href=&quot;#PTP&quot; class=&quot;headerlink&quot; title=&quot;PTP&quot;&gt;&lt;/a&gt;PTP&lt;/h1&gt;&lt;h2 id=&quot;安装linuxptp&quot;&gt;&lt;a href=&quot;#安装linuxptp&quot; class=&quot;headerlink&quot; title=&quot;安装linuxptp&quot;&gt;&lt;/a&gt;安装linuxptp&lt;/h2&gt;&lt;h3 id=&quot;编译安装&quot;&gt;&lt;a href=&quot;#编译安装&quot; class=&quot;headerlink&quot; title=&quot;编译安装&quot;&gt;&lt;/a&gt;编译安装&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git &lt;span class=&quot;built_in&quot;&gt;clone&lt;/span&gt; http://git.code.sf.net/p/linuxptp/code linuxptp&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; linuxptp&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;make&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo make install&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="ROS" scheme="http://blog.onebug.tech/categories/ROS/"/>
    
    
    <category term="docker" scheme="http://blog.onebug.tech/tags/docker/"/>
    
    <category term="gpu" scheme="http://blog.onebug.tech/tags/gpu/"/>
    
    <category term="gui" scheme="http://blog.onebug.tech/tags/gui/"/>
    
  </entry>
  
  <entry>
    <title>git备忘录</title>
    <link href="http://blog.onebug.tech/2022/02/19/%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/git/"/>
    <id>http://blog.onebug.tech/2022/02/19/%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/git/</id>
    <published>2022-02-18T16:00:00.000Z</published>
    <updated>2023-03-23T15:29:43.015Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git-LFS"><a href="#Git-LFS" class="headerlink" title="Git LFS"></a>Git LFS</h1><p>Git LFS（Large File Storage，大文件存储）协议，可以把音乐、图片、视频等指定的任意大文件资源存储在Git仓库之外，对于使用者而言，类似在操作一个完整的Git仓库，非常方便。通过将大文件存储在Git原有的数据结构之中，可以减小Git仓库本身的体积，使克隆Git仓库的速度加快，也使得Git不会因为仓库中充满大文件而损失性能。</p><span id="more"></span><p><img src="https://image.onebug.tech/202202241351274.gif" alt="a diagram showing how Git LFS works"></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -s https://packagecloud.io/install/repositories/github/git-lfs/script.deb.sh | sudo bash</span><br><span class="line">sudo apt-get install git-lfs</span><br><span class="line">git lfs install</span><br></pre></td></tr></table></figure><h2 id="配置追踪文件"><a href="#配置追踪文件" class="headerlink" title="配置追踪文件"></a>配置追踪文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#追踪所有后缀名为“.mp4”的文件：</span></span><br><span class="line">git lfs track <span class="string">&quot;*.MP4&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看已追踪的文件，已经追踪的文件保存在“.gitattributes”中</span></span><br><span class="line">git lfs track</span><br></pre></td></tr></table></figure><h2 id="提交大文件"><a href="#提交大文件" class="headerlink" title="提交大文件"></a>提交大文件</h2><p>提交代码时需要将“.gitattributes”文件也提交到仓库，提交完成后，就可以和原有操作一样使用git的提交功能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#提交</span></span><br><span class="line">git push origin master</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看 LFS 跟踪的文件列表</span></span><br><span class="line">git lfs ls-files</span><br></pre></td></tr></table></figure><h1 id="Gitlab-CI-x2F-CD"><a href="#Gitlab-CI-x2F-CD" class="headerlink" title="Gitlab CI&#x2F;CD"></a>Gitlab CI&#x2F;CD</h1><p>GitLab CI&#x2F;CD 是一个内置在GitLab中的工具，用于通过持续方法进行软件开发：</p><ul><li>Continuous Integration (CI) 持续集成</li><li>Continuous Delivery (CD)   持续交付</li><li>Continuous Deployment (CD)  持续部署</li></ul><p>持续集成的工作原理是将小的代码块推送到Git仓库中托管的应用程序代码库中，并且每次推送时，都要运行一系列脚本来构建、测试和验证代码更改，然后再将其合并到主分支中。</p><p>持续交付和部署相当于更进一步的CI，可以在每次推送到仓库默认分支的同时将应用程序部署到生产环境。</p><p><img src="https://image.onebug.tech/202202241351844.png" alt="img"></p><h2 id="gitlab-ci-yml"><a href="#gitlab-ci-yml" class="headerlink" title=".gitlab-ci.yml"></a>.gitlab-ci.yml</h2><p>了使用GitLab CI&#x2F;CD，你需要一个托管在GitLab上的应用程序代码库，并且在根目录中的.gitlab-ci.yml文件中指定构建、测试和部署的脚本。一旦你已经添加了.gitlab-ci.yml到仓库中，GitLab将检测到该文件，并使用名为GitLab Runner的工具运行你的脚本。该工具的操作与终端类似。这些脚本被分组到jobs，它们共同组成一个pipeline。一个最简单的.gitlab-ci.yml文件可能是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">before_script: </span><br><span class="line">  - apt-get install rubygems ruby-dev -y </span><br><span class="line"></span><br><span class="line">run-test: </span><br><span class="line">  script: </span><br><span class="line">    - ruby --version 6</span><br></pre></td></tr></table></figure><p>before_script属性将在运行任何内容之前为你的应用安装依赖，一个名为run-test的job（作业）将打印当前系统的Ruby版本。二者共同构成了在每次推送到仓库的任何分支时都会被触发的Pipeline（管道）。</p><h2 id="Runner"><a href="#Runner" class="headerlink" title="Runner"></a>Runner</h2><p>在GitLab中，Runner运行你定义在.gitlab-ci.yml中的作业（job）。一个Runner可以是一个虚拟机、物理机、docker容器，或者一个容器集群。GitLab与Runner之间通过API进行通信，因此只需要Runner所在的机器有网络并且可以访问GitLab服务器即可。在成功配置Runner以后，你应该可以看到你最近的提交的状态 。</p><blockquote><p><a href="https://support.huaweicloud.com/usermanual-codehub/devcloud_hlp_0960.html">Git LFS使用_代码托管 CodeHub_用户指南_更多Git知识_华为云 (huaweicloud.com)</a></p><p><a href="https://www.cnblogs.com/cjsblog/p/12256843.html">GitLab CI&#x2F;CD - 废物大师兄 - 博客园 (cnblogs.com)</a></p></blockquote><h1 id="Git初始化"><a href="#Git初始化" class="headerlink" title="Git初始化"></a>Git初始化</h1><h2 id="设置用户名"><a href="#设置用户名" class="headerlink" title="设置用户名"></a>设置用户名</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;username&quot;</span></span><br><span class="line">git config --global user.email useremail@xxx.com </span><br></pre></td></tr></table></figure><h2 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global https.proxy http://127.0.0.1:1080</span><br><span class="line">git config --global https.proxy https://127.0.0.1:1080</span><br></pre></td></tr></table></figure><h2 id="记住github-x2F-gitlab账号密码"><a href="#记住github-x2F-gitlab账号密码" class="headerlink" title="记住github&#x2F;gitlab账号密码"></a>记住github&#x2F;gitlab账号密码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Git-LFS&quot;&gt;&lt;a href=&quot;#Git-LFS&quot; class=&quot;headerlink&quot; title=&quot;Git LFS&quot;&gt;&lt;/a&gt;Git LFS&lt;/h1&gt;&lt;p&gt;Git LFS（Large File Storage，大文件存储）协议，可以把音乐、图片、视频等指定的任意大文件资源存储在Git仓库之外，对于使用者而言，类似在操作一个完整的Git仓库，非常方便。通过将大文件存储在Git原有的数据结构之中，可以减小Git仓库本身的体积，使克隆Git仓库的速度加快，也使得Git不会因为仓库中充满大文件而损失性能。&lt;/p&gt;</summary>
    
    
    
    <category term="工具" scheme="http://blog.onebug.tech/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="git" scheme="http://blog.onebug.tech/tags/git/"/>
    
    <category term="git lfs" scheme="http://blog.onebug.tech/tags/git-lfs/"/>
    
    <category term="ci/cd" scheme="http://blog.onebug.tech/tags/ci-cd/"/>
    
  </entry>
  
  <entry>
    <title>GTEST</title>
    <link href="http://blog.onebug.tech/2022/02/18/%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/GTEST/"/>
    <id>http://blog.onebug.tech/2022/02/18/%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/GTEST/</id>
    <published>2022-02-17T16:00:00.000Z</published>
    <updated>2022-03-07T01:55:27.503Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p><strong>TODO</strong></p><span id="more"></span><h1 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h1><p>gtest中，断言的宏根据作用效果可以理解为分为两类：</p><ul><li><code>ASSERT_*</code> 系列的断言，当检查点失败时，退出当前函数（注意：并非退出当前案例）。</li><li><code>_EXPECT_*</code> 系列的断言，当检查点失败时，继续往下执行。</li></ul><p>根据作用区分，可以分为几大类</p><ul><li><p>数值类型数据检查：<code>ASSERT_EQ(expected, actual)</code></p></li><li><p>布尔值检查：<code>ASSERT_TRUE(condition)</code></p></li><li><p>字符串检查：<code>ASSERT_STREQ（str1,str2）</code></p></li><li><p>异常检查：<code>ASSERT_THROW(</code><em>statement</em>, <em>exception_type</em><code>)</code></p></li><li><p>浮点型检查：<code>ASSERT_NEAR(val1, val2, abs_error)</code></p></li><li><p>类型检查</p></li><li><p>…….</p></li></ul><p>GTEST中包含非常丰富的断言，这里不赘述，详细内容请参考<a href="https://google.github.io/googletest/reference/assertions.html">Assertions Reference | GoogleTest</a>。</p><blockquote><p>如果你对自动输出的出错信息不满意的话，你还可以通过操作符<code>&lt;&lt;</code>将一些自定义的信息输出，通常，这对于调试或是对一些检查点的补充说明来说，非常有用！</p><p>EXPECT_EQ(x[i], y[i]) &lt;&lt; “Vectors x and y differ at index “ &lt;&lt; i;</p></blockquote><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p>gtest提供了多种事件机制，非常方便我们在案例之前或之后做一些操作。</p><h2 id="全局事件"><a href="#全局事件" class="headerlink" title="全局事件"></a>全局事件</h2><p>全局的时间在所有案例前后执行。要实现全局事件，必须写一个类，继承<code>testing::Environment</code>类，实现里面的<code>SetUp</code>和<code>TearDown</code>方法。</p><ol><li><p><code>SetUp()</code>方法在所有案例执行前执行</p></li><li><p><code>TearDown()</code>方法在所有案例执行后执行</p></li></ol><p>我们还需要告诉gtest添加这个全局事件，我们需要在main函数中通过<code>testing::AddGlobalTestEnvironment</code>方法将事件挂进来，也就是说，我们可以写很多个这样的类，然后将他们的事件都挂上去。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FooEnvironment</span> : <span class="keyword">public</span> testing::Environment</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetUp</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Foo FooEnvironment SetUP&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">TearDown</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Foo FooEnvironment TearDown&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, _TCHAR* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    testing::<span class="built_in">AddGlobalTestEnvironment</span>(<span class="keyword">new</span> FooEnvironment);</span><br><span class="line">    testing::<span class="built_in">InitGoogleTest</span>(&amp;argc, argv);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">RUN_ALL_TESTS</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TestSuite事件"><a href="#TestSuite事件" class="headerlink" title="TestSuite事件"></a>TestSuite事件</h2><p>我们需要写一个类，继承<code>testing::Test</code>，然后实现<code>SetUpTestCase()</code>和<code>TearDownTestCase()</code>两个静态方法。在编写测试案例时，我们需要使用<code>TEST_F</code>这个宏，第一个参数必须是我们上面<strong>类的名字</strong>，代表一个TestSuite。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FooTest</span> : <span class="keyword">public</span> testing::Test &#123;</span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">SetUpTestCase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    shared_resource_ = <span class="keyword">new</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">TearDownTestCase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> shared_resource_;</span><br><span class="line">    shared_resource_ = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Some expensive resource shared by all tests.</span></span><br><span class="line">  <span class="type">static</span> T* shared_resource_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">TEST_F</span>(FooTest, Test1)</span><br><span class="line"> &#123;</span><br><span class="line">    <span class="comment">// you can refer to shared_resource here </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">TEST_F</span>(FooTest, Test2)</span><br><span class="line"> &#123;</span><br><span class="line">    <span class="comment">// you can refer to shared_resource here </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TestCase事件"><a href="#TestCase事件" class="headerlink" title="TestCase事件"></a>TestCase事件</h2><p>TestCase事件是挂在每个案例执行前后的，实现方式和上面的几乎一样，不过需要实现的是<code>SetUp</code>方法和<code>TearDown</code>方法。</p><h1 id="参数化"><a href="#参数化" class="headerlink" title="参数化"></a>参数化</h1><p>在设计测试案例时，经常需要考虑给被测函数传入不同的值的情况，GTEST提供了一个灵活的参数化测试的方案。如果我们测试一个素数检查函数<code>bool isPrime(int )</code>，我们需要进行以下的步骤：</p><ol><li>添加一个类，继承<code>testing::TestWithParam&lt;T&gt;</code>，其中T就是你需要参数化的参数类型，比如上面的例子，需要参数化一个<code>int</code>型的参数。</li><li>告诉gtest拿到参数的值后，具体做些什么样的测试。我们需要引入一个新的宏<code>TEST_P</code>，关于这个”P”的含义，可以理解为”parameterized” 或者 “pattern”。</li><li>告诉gtest你想要测试的参数范围是什么，然后使用<code>INSTANTIATE_TEST_CASE_P</code>宏来告诉gtest你要测试的参数范围。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSTANTIATE_TEST_CASE_P(TrueReturn, IsPrimeParamTest, testing::Values(3, 5, 11, 23, 17));</span><br></pre></td></tr></table></figure><ul><li><p>第一个参数是测试案例的前缀，可以任意取。</p></li><li><p>第二个参数是测试案例的名称，需要和之前定义的参数化的类的名称相同，</p></li><li><p>第三个参数是可以理解为参数生成器，上面的例子使用test::Values表示使用括号内的参数。Google提供了一系列的参数生成的函数：</p><table><thead><tr><th>函数</th><th>解释</th></tr></thead><tbody><tr><td>Range(begin, end[, step])</td><td>范围在begin~end之间，步长为step，不包括end</td></tr><tr><td>Values(v1, v2, …, vN)</td><td>v1,v2到vN的值</td></tr><tr><td>ValuesIn(container) and ValuesIn(begin,end)</td><td>从一个C类型的数组或是STL容器，或是迭代器中取值</td></tr><tr><td>Bool()</td><td>取false 和 true 两个值</td></tr><tr><td>Combine(g1, g2, …, gN)</td><td>它将g1,g2,…gN进行排列组合，g1,g2,…gN本身是一个参数生成器，每次分别从g1,g2,..gN中各取出一个值，组合成一个元组(Tuple)作为一个参数</td></tr></tbody></table></li></ul><p> 综上所述，我们可以完成对素数检查函数的测试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IsPrimeParamTest</span> : <span class="keyword">public</span>::testing::TestWithParam&lt;<span class="type">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">TEST_P</span>(IsPrimeParamTest, HandleTrueReturn)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n =  <span class="built_in">GetParam</span>();</span><br><span class="line">    <span class="built_in">EXPECT_TRUE</span>(<span class="built_in">IsPrime</span>(n));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">INSTANTIATE_TEST_CASE_P</span>(TrueReturn, IsPrimeParamTest, testing::<span class="built_in">Values</span>(<span class="number">3</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">23</span>, <span class="number">17</span>));</span><br></pre></td></tr></table></figure><p>gtest还提供了应付各种不同类型的数据时的方案，以及参数化类型的方案。这里不详细展开。</p><h1 id="参数列表"><a href="#参数列表" class="headerlink" title="参数列表"></a>参数列表</h1><table><thead><tr><th><strong>命令行参数</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>–gtest_list_tests</td><td>使用这个参数时，将不会执行里面的测试案例，而是输出一个案例的列表。</td></tr><tr><td>–gtest_filter</td><td>对执行的测试案例进行过滤，支持通配符</td></tr><tr><td>–gtest_also_run_disabled_tests</td><td>执行案例时，同时也执行被置为无效的测试案例。</td></tr><tr><td>–gtest_repeat&#x3D;[COUNT]</td><td>设置案例重复运行次数</td></tr></tbody></table><blockquote><p>执行案例时，同时也执行被置为无效的测试案例。关于设置测试案例无效的方法为：</p><p>在测试案例名称或测试名称中添加DISABLED前缀，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">TEST</span>(FooTest, DISABLED_DoesAbc) &#123;  &#125;</span><br><span class="line">  </span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">DISABLED_BarTest</span> : <span class="keyword">public</span> testing::Test &#123;  &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;<span class="built_in">TEST_F</span>(DISABLED_BarTest, DoesXyz) &#123;  &#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>[玩转Google开源C++单元测试框架Google Test系列(gtest)之一 - 初识gtest - CoderZh - 博客园 (cnblogs.com)](<a href="https://www.cnblogs.com/coderzh/archive/2009/04/06/1426758.html">https://www.cnblogs.com/coderzh/archive/2009/04/06/1426758.html</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;基本使用&quot;&gt;&lt;a href=&quot;#基本使用&quot; class=&quot;headerlink&quot; title=&quot;基本使用&quot;&gt;&lt;/a&gt;基本使用&lt;/h1&gt;&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;h2 id=&quot;Hello-World&quot;&gt;&lt;a href=&quot;#Hello-World&quot; class=&quot;headerlink&quot; title=&quot;Hello World&quot;&gt;&lt;/a&gt;Hello World&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;TODO&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="工具" scheme="http://blog.onebug.tech/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="gtest" scheme="http://blog.onebug.tech/tags/gtest/"/>
    
    <category term="测试" scheme="http://blog.onebug.tech/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>ROS2备忘录</title>
    <link href="http://blog.onebug.tech/2022/02/13/ROS/ROS2/"/>
    <id>http://blog.onebug.tech/2022/02/13/ROS/ROS2/</id>
    <published>2022-02-12T16:00:00.000Z</published>
    <updated>2023-03-23T15:29:43.007Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>ubuntu 20.04</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ros-rolling-desktop</span><br></pre></td></tr></table></figure><blockquote><p><a href="http://docs.ros.org/en/rolling/Installation/Ubuntu-Install-Debians.html#">http://docs.ros.org/en/rolling/Installation/Ubuntu-Install-Debians.html#</a></p></blockquote><span id="more"></span><h1 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h1><ul><li>“workspace”是一个ROS术语，表示在系统上使用ROS2进行开发的位置。</li><li>核心ROS工作区被称为”underlay“，本地ROS工作区称为 ”overlays“</li></ul><p>环境设置脚本自启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;source /opt/ros/rolling/setup.bash&quot; &gt;&gt; ~/.bashrc</span><br><span class="line">printenv | grep -i ROS</span><br></pre></td></tr></table></figure><h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><p>ROS图（ROS graph）是一个由ROS 2元素组成的网络，在同一时间一起处理数据。图中包括所有的可执行文件和它们之间的联系。</p><p>ROS中的每个节点（ROS Node）应该只负责单一模块化的用途（例如，一个节点负责控制车轮马达，一个节点负责控制激光测距仪等等）。每个节点可以通过主题（topics）、服务（services）、行动（actions）或参数（parameters）向其他节点发送和接收数据。</p><p><img src="https://image.onebug.tech/202203062319650.gif" alt="../_images/Nodes-TopicandService.gif"></p><p>一个完整的机器人系统由许多协同工作的节点组成。在ROS2中，单个可执行文件（C++程序、Python程序等）可以包含一个或多个节点。</p><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><ul><li><p><code>ros2 run &lt;package_name&gt; &lt;executable_name&gt;</code>：从包启动可执行文件。</p></li><li><p><code>ros2 node list</code>：显示所有运行节点的名称，当您想要与一个节点交互时，或者当您的系统运行许多节点并且需要跟踪它们时，这尤其有用。</p></li><li><p>使用<code>Remapping</code>可以指定节点属性（如节点名称、主题名称、服务名称等）</p><p>例：<code>ros2 run turtlesim turtlesim_node --ros-args --remap __node:=my_turtle</code></p></li><li><p><code>ros2 node info &lt;node_name&gt;</code>  ：知道了节点的名称，可以通过该命令访问有关节点的更多信息</p></li></ul><h2 id="Topics"><a href="#Topics" class="headerlink" title="Topics"></a>Topics</h2><p>ROS2将复杂系统分解为许多模块化节点。主题（Topics）是ROS图的一个重要元素，充当节点交换消息的总线。</p><p><img src="https://image.onebug.tech/202203062319555.gif" alt="../../_images/Topic-SinglePublisherandSingleSubscriber.gif"></p><p>节点可以将数据发布到任意数量的主题，同时可以订阅任意数量的主题。主题是在节点之间以及系统不同部分之间移动数据的主要方式之一。也就是说，主题可以不只是点对点的交流，它可以是一对多、多对一或多对多。</p><p><img src="https://image.onebug.tech/202203062319254.gif" alt="../../_images/Topic-MultiplePublisherandMultipleSubscriber.gif"></p><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>我们可以使用<code>rqt_graph</code>来可视化不断变化的节点和主题，以及它们之间的连接。</p><p><img src="https://image.onebug.tech/202203062319960.png" alt="../../_images/rqt_graph.png"></p><p>上图描述了<code>/turtlesim</code>节点和<code>/teleop_turtle</code>节点如何通过主题相互通信。<code>/teleop_turtle</code>节点将数据发布到<code>/turtle1/cmd_vel</code>主题中（输入用于移动海龟的按键），并且<code>/turtlesim</code>节点订阅该主题以接收数据。</p><h3 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h3><ul><li><p><code>ros2 topic list</code>：返回系统中当前活动的所有主题的列表</p></li><li><p><code>ros2 topic list -t</code>：将返回相同的主题列表，返回结果括号中的是主题类型。</p></li><li><p><code>ros2 topic echo &lt;topic_name&gt; </code>：查看主题上正在发布的数据</p></li><li><p><code>ros2 topic info &lt;topic_name&gt;</code>：返回主题信息（有多少个订阅者，有多少个发布者）</p></li><li><p><code>ros2 interface show &lt;type&gt;</code>：节点使用消息通过主题发送数据。发布者和订阅者必须发送和接收相同类型的消息才能进行通信。如果主题<code>/turtle1/cmd_vel</code>的类型是<code>geometry_msgs/msg/Twist</code>，这意味着在<code>geometry_msgs</code>包中有一个名为<code>Twist</code>的消息。<code>ros2 interface show &lt;msg type&gt;</code>可以查看该类型的细节，假设得到的类型细节为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Vector3  linear</span><br><span class="line">        float64 x</span><br><span class="line">        float64 y</span><br><span class="line">        float64 z</span><br><span class="line">Vector3  angular</span><br><span class="line">        float64 x</span><br><span class="line">        float64 y</span><br><span class="line">        float64 z</span><br></pre></td></tr></table></figure><p>这说明<code>/turtlesim</code>节点需要一条消息，该消息包含两个向量，即<code>linear</code>向量和<code>angular</code>向量，每个向量包含三个元素。</p></li><li><p><code>ros2 topic pub &lt;topic_name&gt; &lt;msg_type&gt; &#39;&lt;args&gt;&#39;</code>：使用该命令直接将数据发布到主题，前提是数据的具体结构。需要注意的是，<code>args</code>需要符合YAML语法规范，例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 topic pub --once  /turtle1/cmd_vel geometry_msgs/msg/Twist &quot;&#123;linear: &#123;x: 2.0, y: 0.0, z: 0.0&#125;, angular: &#123;x: 0.0, y: 0.0, z: 1.8&#125;&#125;&quot;</span><br></pre></td></tr></table></figure></li><li><p><code>ros2 topic hz </code>：查看数据发布的速率</p></li></ul><h2 id="Services"><a href="#Services" class="headerlink" title="Services"></a>Services</h2><p>服务（services）是ROS图中节点的另一种通信方法。服务基于呼叫和响应（call-and-response）模型，而不是发布者-订阅者（publisher-subscriber）模型。虽然主题允许节点订阅数据流并获得持续更新，但服务仅在客户端专门调用时提供数据。</p><p><img src="https://image.onebug.tech/202203062319118.gif" alt="../../_images/Service-SingleServiceClient.gif"></p><p><img src="https://image.onebug.tech/202203062319686.gif" alt="../../_images/Service-MultipleServiceClient.gif"></p><h3 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h3><ul><li><code>ros2 service list</code>：返回系统中当前活动的所有服务的列表</li><li><code>ros2 service type &lt;service_name&gt; </code>：服务类型的定义与主题类型类似，只是服务类型有两部分：一部分用于请求，另一部分用于响应。假如一个服务的类型是<code>std_srvs/srv/Empty</code>，这表示服务调用在发出请求时不发送数据，在接收响应时不接收数据。</li><li><code>ros2 service find &lt;service_type&gt;</code>：查找特定类型的所有服务</li><li><code>ros2 interface show &lt;service_type_name&gt;</code> ：返回类型的具体结构，返回结果的<code>---</code>将请求结构（上面）与响应结构（下面）分开。</li><li><code>ros2 service call &lt;service_name&gt; &lt;service_type&gt; &lt;arguments&gt;</code>：调用服务</li></ul><h2 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a>Parameters</h2><p>参数（parameters）是节点的配置值。节点可以将参数存储为整数、浮点、布尔、字符串和列表。在ROS2中，每个节点维护自己的参数。所有参数都可动态重新配置，并基于ROS 2服务构建。</p><h3 id="命令-3"><a href="#命令-3" class="headerlink" title="命令"></a>命令</h3><ul><li><p><code>ros2 param list </code>：查看参数列表</p></li><li><p><code>ros2 param get &lt;node_name&gt; &lt;parameter_name&gt;</code>：查看参数类型和当前值</p></li><li><p><code>ros2 param set &lt;node_name&gt; &lt;parameter_name&gt; &lt;value&gt;</code>：设置参数值</p></li><li><p><code>ros2 param dump &gt; dumpfile</code>：查看节点的所有当前参数值</p></li><li><p><code>ros2 param load &lt;node_name&gt; &lt;parameter_file&gt;</code>：将参数从文件加载到当前运行的节点</p><blockquote><p>只读参数只能在启动前修改，启动后修改有可能会出现问题（比如一些QOS参数）</p></blockquote></li><li><p><code>ros2 run &lt;package_name&gt; &lt;executable_name&gt; --ros-args --params-file &lt;file_name&gt;</code>：在启动时加载参数</p></li></ul><h2 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h2><p>Actions是ROS 2中的通信类型之一，用于长时间运行的任务。它们由三部分组成：目标（goal）、反馈（feedback）和结果（result）</p><p><img src="https://image.onebug.tech/202203062319195.gif" alt="../_images/Action-SingleActionClient.gif"></p><p>行动建立在主题和服务之上，功能与服务类似，只是可以取消操作。它们还提供稳定的反馈，而不是像服务一样只返回单一响应。</p><p>Actions使用client-server模型，类似于pubsub模型（在主题教程中介绍）。“action client”节点向“action server”节点发送目标，后者确认目标并返回反馈流和结果。</p><h3 id="命令-4"><a href="#命令-4" class="headerlink" title="命令"></a>命令</h3><ul><li><p><code>ros2 action list -t</code></p></li><li><p><code>ros2 action info</code></p></li><li><p><code>ros2 interface show</code>：返回结果被<code>---</code>分为三个部分，分别是目标请求的结构、结果的结构、反馈的结构。</p></li><li><p><code>ros2 action send_goal &lt;action_name&gt; &lt;action_type&gt; &lt;values&gt; --feedback</code> ：发生Action中的目标</p></li></ul><h1 id="工作区"><a href="#工作区" class="headerlink" title="工作区"></a>工作区</h1><p>工作区（workspace）是包含ROS2包的目录。</p><ul><li><p>source ROS2环境：<code>source /opt/ros/rolling/setup.bash</code></p></li><li><p>创建目录：最好是为每个新的工作区创建新目录，并将所有的包都放置在<code>src</code>文件夹</p><blockquote><p>在<code>src</code>文件夹执行：<code>git clone https://github.com/ros/ros_tutorials.git -b rolling-devel</code></p></blockquote></li><li><p>在构建工作区之前，您需要解析包依赖关系：<code>rosdep install -i --from-path src --rosdistro rolling -y</code>，</p><blockquote><p>找不到<code>rosdep</code>命令 的解决方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;apt install python3-rosdep2</span><br></pre></td></tr></table></figure><p><code>rosdep update</code> 失败的解决方法：</p><ol><li>使用rosdepc：<a href="https://www.guyuehome.com/35408">本文之后，世上再无rosdep更新失败问题！如果有….小鱼就… - 古月居 (guyuehome.com)</a></li><li>使用github proxy：<a href="https://zhuanlan.zhihu.com/p/392082731">ROS安装过程中如何解决 rosdep update 命令出现错误 - 知乎 (zhihu.com)</a></li></ol></blockquote></li><li><p>使用<code>colcon</code>构建工作空间：<code>colcon build</code>。<code>build</code>完成后会生成三个文件夹，<code>build</code>、<code>install</code>、<code>log</code>，其中<code>install</code>目录是您的工作区的安装文件所在的位置，您可以使用它来source overlay。</p><blockquote><ul><li>找不到<code>colcon</code>：</li></ul> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt install -y \</span><br><span class="line">build-essential \</span><br><span class="line">cmake \</span><br><span class="line">git \</span><br><span class="line">python3-colcon-common-extensions \</span><br><span class="line">python3-flake8 \</span><br><span class="line">python3-pip \</span><br><span class="line">python3-pytest-cov \</span><br><span class="line">python3-rosdep \</span><br><span class="line">python3-setuptools \</span><br><span class="line">python3-vcstool \</span><br><span class="line">wget</span><br><span class="line"><span class="comment"># install some pip packages needed for testing</span></span><br><span class="line">python3 -m pip install -U \</span><br><span class="line">flake8-blind-except \</span><br><span class="line">flake8-builtins \</span><br><span class="line">flake8-class-newline \</span><br><span class="line">flake8-comprehensions \</span><br><span class="line">flake8-deprecated \</span><br><span class="line">flake8-docstrings \</span><br><span class="line">flake8-import-order \</span><br><span class="line">flake8-quotes \</span><br><span class="line">pytest-repeat \</span><br><span class="line">pytest-rerunfailures \</span><br><span class="line">pytest</span><br></pre></td></tr></table></figure><ul><li>build 失败的解决办法：</li></ul><p> python版本的问题，将<code>/usr/bin</code>中的python3.5执行文件改成其他文件名，只留下python3.8执行文件</p></blockquote></li><li><p>source overlay（本地工作区）：<code>. install/local_setup.bash</code></p><blockquote><p>在source本地工作区之前，需要打开一个新的终端，与构建工作区的终端分开，这一点非常重要，不然有可能会产生复杂的问题</p></blockquote></li><li><p>修改本地工作区的代码：</p><ol><li>将<code>~/dev_ws/src/ros_tutorials/turtlesim/src/turtle_frame.cpp</code>中52行的<code>setWindowTitle(&quot;TurtleSim&quot;);</code>修改为<code>setWindowTitle(&quot;MyTurtleSim&quot;);</code></li><li><code>colcon build</code></li><li><code>. install/local_setup.bash</code>、<code>ros2 run turtlesim turtlesim_node</code></li></ol></li></ul><h1 id="ROS包"><a href="#ROS包" class="headerlink" title="ROS包"></a>ROS包</h1><p>包（package）可以被认为是你的ROS 2代码的容器。如果你希望能够安装你的代码或与他人分享，那么你就需要把它组织在一个包里。通过包，你可以发布你的ROS 2工作，并允许其他人轻松构建和使用它。</p><p>ROS 2的软件包创建使用<code>ament</code>作为其构建系统，<code>colcon</code>作为其构建工具，你可以使用官方支持的CMake或Python来创建一个软件包。除了这些，也存在其他的构建方式。</p><blockquote><p>Ament是catkin编译工具的优化迭代版本。 </p><p>colcon是一个构建软件包集合的命令行工具，是ros构建工具catkin_make, catkin_make_isolated, catkin_tools 和ament_tools的迭代版本。</p></blockquote><p>Python构建软件包需要：</p><ul><li><code>package.xml</code>文件，包含关于包的元信息。</li><li><code>setup.py</code>，包含如何安装软件包的说明</li><li><code>setup.cfg</code> 在软件包有可执行文件时是必需的，这样 ros2 run 可以找到它们。</li><li><code>/&lt;package_name&gt;</code> 一个与你的软件包同名的目录，被ROS 2工具用来寻找你的软件包，包含<code>__init__.py</code></li></ul><p>最简单的Python包文件结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my_package/</span><br><span class="line">      setup.py</span><br><span class="line">      package.xml</span><br><span class="line">      resource/my_package</span><br></pre></td></tr></table></figure><p>CMake构建软件包需要：</p><ul><li><p><code>package.xml</code>文件，包含关于包的元信息。</p></li><li><p><code>CMakeLists.txt</code>文件，描述了如何构建包内的代码</p></li></ul><p>最简单的的C&#x2F;C++包文件结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my_package/</span><br><span class="line">      setup.py</span><br><span class="line">      package.xml</span><br><span class="line">      resource/my_package</span><br></pre></td></tr></table></figure><p>一个工作区可以包含你想要的任何数量的包，每个包都在自己的文件夹里。你也可以在一个工作区中拥有不同构建类型的包（CMake、Python等），但是不能有嵌套的包。最好的做法是在你的工作区里有一个src文件夹，并在那里创建你的包。这样可以保持工作区顶层的干净。</p><p>一个典型的工作空间可能看起来是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">workspace_folder/</span><br><span class="line">    src/</span><br><span class="line">      package_1/</span><br><span class="line">          CMakeLists.txt</span><br><span class="line">          package.xml</span><br><span class="line"></span><br><span class="line">      package_2/</span><br><span class="line">          setup.py</span><br><span class="line">          package.xml</span><br><span class="line">          resource/package_2</span><br><span class="line">      ...</span><br><span class="line">      package_n/</span><br><span class="line">          CMakeLists.txt</span><br><span class="line">          package.xml</span><br></pre></td></tr></table></figure><p>在ROS 2中创建一个新包的命令语法是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 pkg create --build-type ament_cmake &lt;package_name&gt;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 pkg create --build-type ament_python &lt;package_name&gt;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 pkg create --build-type ament_cmake --node-name my_node my_package</span><br></pre></td></tr></table></figure><p>把软件包放在工作区是一件有意义的事，因为你可以通过在工作区根目录下运行<code>colcon build</code>来一次性构建所有软件包，而不用单独构建每个包。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">colcon build --packages-select my_package</span><br></pre></td></tr></table></figure><blockquote><p>build失败，原因是email和maintainer包含反斜杆，去掉就行</p></blockquote><p>尝试运行，<code>ros2 run my_package my_node</code>会看到输出。修改<code>my_node.cpp</code>，重新编译运行，可以看到不同的输出。</p><h1 id="pubsub模型"><a href="#pubsub模型" class="headerlink" title="pubsub模型"></a>pubsub模型</h1><h2 id="C-版本"><a href="#C-版本" class="headerlink" title="C++版本"></a>C++版本</h2><h2 id="Python版本"><a href="#Python版本" class="headerlink" title="Python版本"></a>Python版本</h2><h3 id="创建包"><a href="#创建包" class="headerlink" title="创建包"></a>创建包</h3><p>在<code>src</code>文件下执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 pkg create --build-type ament_python py_pubsub</span><br></pre></td></tr></table></figure><h3 id="发布Node"><a href="#发布Node" class="headerlink" title="发布Node"></a>发布Node</h3><p>在<code>src/py_pubsub/py_pubsub</code>目录下添加文件<code>publisher_member_function.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> rclpy</span><br><span class="line"><span class="keyword">from</span> rclpy.node <span class="keyword">import</span> Node</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># import内置的字符串消息类型，Node使用可以该类型来结构化它在Topic上传递的数据。</span></span><br><span class="line"><span class="keyword">from</span> std_msgs.msg <span class="keyword">import</span> String</span><br><span class="line"></span><br><span class="line"><span class="comment"># MinimalPublisher继承自Node类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MinimalPublisher</span>(<span class="title class_ inherited__">Node</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 指定node名称是minimal_publisher</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(<span class="string">&#x27;minimal_publisher&#x27;</span>)</span><br><span class="line">        <span class="comment"># 声明该节点在一个名为topic的主题上发布String类型的消息,并且 &quot;队列大小 &quot;为10。</span></span><br><span class="line">        self.publisher_ = self.create_publisher(String, <span class="string">&#x27;topic&#x27;</span>, <span class="number">10</span>)</span><br><span class="line">        timer_period = <span class="number">0.5</span>  <span class="comment"># seconds</span></span><br><span class="line">        <span class="comment"># 创建了一个定时器，它的回调每0.5秒执行一次</span></span><br><span class="line">        self.timer = self.create_timer(timer_period, self.timer_callback)</span><br><span class="line">        self.i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># timer_callback函数创建一个附加有计数器值的消息，并在控制台打印该值。</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">timer_callback</span>(<span class="params">self</span>):</span><br><span class="line">        msg = String()</span><br><span class="line">        msg.data = <span class="string">&#x27;Hello World: %d&#x27;</span> % self.i</span><br><span class="line">        self.publisher_.publish(msg)</span><br><span class="line">        self.get_logger().info(<span class="string">&#x27;: &quot;%s&quot;&#x27;</span> % msg.data)</span><br><span class="line">        self.i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">args=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="comment"># 初始化 rclpy 库</span></span><br><span class="line">    rclpy.init(args=args)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建节点</span></span><br><span class="line">    minimal_publisher = MinimalPublisher()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># &quot;spin&quot;节点，使其回调被调用。</span></span><br><span class="line">    <span class="comment"># </span></span><br><span class="line">    rclpy.spin(minimal_publisher)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Destroy the node explicitly</span></span><br><span class="line">    <span class="comment"># (optional - otherwise it will be done automatically</span></span><br><span class="line">    <span class="comment"># when the garbage collector destroys the node object)</span></span><br><span class="line">    minimal_publisher.destroy_node()</span><br><span class="line">    rclpy.shutdown()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><blockquote><p>spin与ROS线程调度：<a href="https://levelup.gitconnected.com/ros-spinning-threading-queuing-aac9c0a793f">ROS publisher queue, subscriber queue, callback queue and spinner threads tutorial | Level Up Coding (gitconnected.com)</a></p></blockquote><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><p>在<code>package.xml</code>中添加依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;exec_depend&gt;rclpy&lt;/exec_depend&gt;</span><br><span class="line">&lt;exec_depend&gt;std_msgs&lt;/exec_depend&gt;</span><br></pre></td></tr></table></figure><h3 id="添加入口点（entry-point）"><a href="#添加入口点（entry-point）" class="headerlink" title="添加入口点（entry point）"></a>添加入口点（entry point）</h3><p>打开<code>setup.py</code>，将信息修改为<code>package.xml</code>中的信息。并修改以下字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">entry_points=&#123;</span><br><span class="line">        &#x27;console_scripts&#x27;: [</span><br><span class="line">                &#x27;talker = py_pubsub.publisher_member_function:main&#x27;,</span><br><span class="line">        ],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="检查setup-cfg"><a href="#检查setup-cfg" class="headerlink" title="检查setup.cfg"></a>检查setup.cfg</h3><p>一般来说，<code>setup.cfg</code>的文件内容是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[develop]</span><br><span class="line">script_dir=<span class="variable">$base</span>/lib/py_pubsub</span><br><span class="line">[install]</span><br><span class="line">install_scripts=<span class="variable">$base</span>/lib/py_pubsub</span><br></pre></td></tr></table></figure><p>含义是告诉 <code>setuptools</code> 要把你的可执行文件放在 <code>lib</code> 中，因为 ros2 run 会在那里寻找可执行文件。</p><h3 id="订阅Node"><a href="#订阅Node" class="headerlink" title="订阅Node"></a>订阅Node</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> rclpy</span><br><span class="line"><span class="keyword">from</span> rclpy.node <span class="keyword">import</span> Node</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> std_msgs.msg <span class="keyword">import</span> String</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MinimalSubscriber</span>(<span class="title class_ inherited__">Node</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(<span class="string">&#x27;minimal_subscriber&#x27;</span>)</span><br><span class="line">        <span class="comment"># 订阅者的代码不需要定时器,因为一旦收到消息，它的回调就会被调用。</span></span><br><span class="line">        self.subscription = self.create_subscription(</span><br><span class="line">            String,</span><br><span class="line">            <span class="string">&#x27;topic&#x27;</span>,</span><br><span class="line">            self.listener_callback,</span><br><span class="line">            <span class="number">10</span>)</span><br><span class="line">        self.subscription  <span class="comment"># prevent unused variable warning</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 回调函数简单地将消息的数据打印到控制台。</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">listener_callback</span>(<span class="params">self, msg</span>):</span><br><span class="line">        self.get_logger().info(<span class="string">&#x27;I heard: &quot;%s&quot;&#x27;</span> % msg.data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">args=<span class="literal">None</span></span>):</span><br><span class="line">    rclpy.init(args=args)</span><br><span class="line"></span><br><span class="line">    minimal_subscriber = MinimalSubscriber()</span><br><span class="line"></span><br><span class="line">    rclpy.spin(minimal_subscriber)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Destroy the node explicitly</span></span><br><span class="line">    <span class="comment"># (optional - otherwise it will be done automatically</span></span><br><span class="line">    <span class="comment"># when the garbage collector destroys the node object)</span></span><br><span class="line">    minimal_subscriber.destroy_node()</span><br><span class="line">    rclpy.shutdown()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>在<code>setup.py</code>添加入口点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;listener = py_pubsub.subscriber_member_function:main&#x27;</span>,</span><br></pre></td></tr></table></figure><h3 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#检查依赖</span></span><br><span class="line">rosdep install -i --from-path src --rosdistro rolling -y</span><br><span class="line"><span class="comment">#编译安装</span></span><br><span class="line">colcon build --packages-select py_pubsub</span><br><span class="line"></span><br><span class="line"><span class="comment">#运行</span></span><br><span class="line"><span class="comment">#terminal1</span></span><br><span class="line">. install/setup.bash</span><br><span class="line">ros2 run py_pubsub talker</span><br><span class="line"></span><br><span class="line"><span class="comment">#terminal2</span></span><br><span class="line">. install/setup.bash</span><br><span class="line">ros2 run py_pubsub listener</span><br></pre></td></tr></table></figure><h1 id="CS模型"><a href="#CS模型" class="headerlink" title="CS模型"></a>CS模型</h1><h2 id="C-版本-1"><a href="#C-版本-1" class="headerlink" title="C++版本"></a>C++版本</h2><p>请求和响应的结构由一个<code>.srv</code>文件决定。</p><h3 id="创建包-1"><a href="#创建包-1" class="headerlink" title="创建包"></a>创建包</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 pkg create --build-type ament_cmake cpp_srvcli --dependencies rclcpp example_interfaces</span><br></pre></td></tr></table></figure><p>参数<code>--dependencies</code>将自动在<code>package.xml</code>和<code>CMakeLists.txt</code>中添加必要的依赖关系行。</p><p><code>example_interfaces</code>包中有我们将需要的<code>.srv</code>文件的包。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int64 a</span><br><span class="line">int64 b</span><br><span class="line">---</span><br><span class="line">int64 sum</span><br></pre></td></tr></table></figure><h3 id="服务端Node"><a href="#服务端Node" class="headerlink" title="服务端Node"></a>服务端Node</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;example_interfaces/srv/add_two_ints.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// add函数将请求中的两个整数相加，并将sum交给响应，同时在控制台打印信息。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;example_interfaces::srv::AddTwoInts::Request&gt; request,</span></span></span><br><span class="line"><span class="params"><span class="function">          std::shared_ptr&lt;example_interfaces::srv::AddTwoInts::Response&gt;      response)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  response-&gt;sum = request-&gt;a + request-&gt;b;</span><br><span class="line">  <span class="built_in">RCLCPP_INFO</span>(rclcpp::<span class="built_in">get_logger</span>(<span class="string">&quot;rclcpp&quot;</span>), <span class="string">&quot;Incoming request\na: %ld&quot;</span> <span class="string">&quot; b: %ld&quot;</span>,</span><br><span class="line">                request-&gt;a, request-&gt;b);</span><br><span class="line">  <span class="built_in">RCLCPP_INFO</span>(rclcpp::<span class="built_in">get_logger</span>(<span class="string">&quot;rclcpp&quot;</span>), <span class="string">&quot;sending back response: [%ld]&quot;</span>, (<span class="type">long</span> <span class="type">int</span>)response-&gt;sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化ROS 2 C++客户端库</span></span><br><span class="line">  rclcpp::<span class="built_in">init</span>(argc, argv);</span><br><span class="line">    <span class="comment">// 创建一个名为add_two_ints_server的节点</span></span><br><span class="line">  std::shared_ptr&lt;rclcpp::Node&gt; node = rclcpp::Node::<span class="built_in">make_shared</span>(<span class="string">&quot;add_two_ints_server&quot;</span>);</span><br><span class="line">    <span class="comment">// 为该节点创建一个名为add_two_ints的服务,并与 add 方法绑定</span></span><br><span class="line">  rclcpp::Service&lt;example_interfaces::srv::AddTwoInts&gt;::SharedPtr service =</span><br><span class="line">    node-&gt;<span class="built_in">create_service</span>&lt;example_interfaces::srv::AddTwoInts&gt;(<span class="string">&quot;add_two_ints&quot;</span>, &amp;add);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">RCLCPP_INFO</span>(rclcpp::<span class="built_in">get_logger</span>(<span class="string">&quot;rclcpp&quot;</span>), <span class="string">&quot;Ready to add two ints.&quot;</span>);</span><br><span class="line">    <span class="comment">// spin节点，使服务可用。</span></span><br><span class="line"></span><br><span class="line">  rclcpp::<span class="built_in">spin</span>(node);</span><br><span class="line">  rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加入口"><a href="#添加入口" class="headerlink" title="添加入口"></a>添加入口</h3><p><code>add_executable</code>宏会生成一个可以用ros2 run来运行的执行文件，在<code>CMakeLists.txt</code>中添加以下代码块，以创建一个名为server的可执行文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add_executable(server src/add_two_ints_server.cpp)</span><br><span class="line">ament_target_dependencies(server</span><br><span class="line">rclcpp example_interfaces)</span><br></pre></td></tr></table></figure><p>为了让ros2运行能够找到可执行文件，需要在文件末尾添加以下几行，就在<code>ament_package()</code>之前。</p><h3 id="客户端Node"><a href="#客户端Node" class="headerlink" title="客户端Node"></a>客户端Node</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;rclcpp/rclcpp.hpp&quot;</span><br><span class="line">#include &quot;example_interfaces/srv/add_two_ints.hpp&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;chrono&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line"></span><br><span class="line">using namespace std::chrono_literals;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">  rclcpp::init(argc, argv);</span><br><span class="line"></span><br><span class="line">  if (argc != 3) &#123;</span><br><span class="line">      RCLCPP_INFO(rclcpp::get_logger(&quot;rclcpp&quot;), &quot;usage: add_two_ints_client X Y&quot;);</span><br><span class="line">      return 1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::shared_ptr&lt;rclcpp::Node&gt; node = rclcpp::Node::make_shared(&quot;add_two_ints_client&quot;);</span><br><span class="line">  rclcpp::Client&lt;example_interfaces::srv::AddTwoInts&gt;::SharedPtr client =</span><br><span class="line">    node-&gt;create_client&lt;example_interfaces::srv::AddTwoInts&gt;(&quot;add_two_ints&quot;);</span><br><span class="line"></span><br><span class="line">  auto request = std::make_shared&lt;example_interfaces::srv::AddTwoInts::Request&gt;();</span><br><span class="line">  request-&gt;a = atoll(argv[1]);</span><br><span class="line">  request-&gt;b = atoll(argv[2]);</span><br><span class="line"></span><br><span class="line">  while (!client-&gt;wait_for_service(1s)) &#123;</span><br><span class="line">    if (!rclcpp::ok()) &#123;</span><br><span class="line">      RCLCPP_ERROR(rclcpp::get_logger(&quot;rclcpp&quot;), &quot;Interrupted while waiting for the service. Exiting.&quot;);</span><br><span class="line">      return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    RCLCPP_INFO(rclcpp::get_logger(&quot;rclcpp&quot;), &quot;service not available, waiting again...&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  auto result = client-&gt;async_send_request(request);</span><br><span class="line">  // Wait for the result.</span><br><span class="line">  if (rclcpp::spin_until_future_complete(node, result) ==</span><br><span class="line">    rclcpp::FutureReturnCode::SUCCESS)</span><br><span class="line">  &#123;</span><br><span class="line">    RCLCPP_INFO(rclcpp::get_logger(&quot;rclcpp&quot;), &quot;Sum: %ld&quot;, result.get()-&gt;sum);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    RCLCPP_ERROR(rclcpp::get_logger(&quot;rclcpp&quot;), &quot;Failed to call service add_two_ints&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  rclcpp::shutdown();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一样需要添加入口</p><h3 id="编译运行-1"><a href="#编译运行-1" class="headerlink" title="编译运行"></a>编译运行</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">colcon build --packages-select cpp_srvcli</span><br><span class="line"></span><br><span class="line">. install/setup.bash</span><br><span class="line">ros2 run cpp_srvcli server</span><br><span class="line"></span><br><span class="line">. install/setup.bash</span><br><span class="line">ros2 run cpp_srvcli client 2 3</span><br></pre></td></tr></table></figure><h2 id="Python版本-1"><a href="#Python版本-1" class="headerlink" title="Python版本"></a>Python版本</h2><h1 id="自定义的msg和srv"><a href="#自定义的msg和srv" class="headerlink" title="自定义的msg和srv"></a>自定义的msg和srv</h1><h2 id="创建包-2"><a href="#创建包-2" class="headerlink" title="创建包"></a>创建包</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 pkg create --build-type ament_cmake tutorial_interfaces</span><br></pre></td></tr></table></figure><p>注意必须是一个CMake包。</p><p>好的做法是将<code>.msg</code>和<code>.srv</code>文件放在软件包内各自的目录中。</p><h2 id="创建自定义的definitions"><a href="#创建自定义的definitions" class="headerlink" title="创建自定义的definitions"></a>创建自定义的definitions</h2><p>注意<code>msg</code>、<code>srv</code>、<code>src</code>文件夹在同一层级</p><ul><li><p><code>Num.msg</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int64 num</span><br></pre></td></tr></table></figure></li><li><p><code>AddThreeInts.srv</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int64 a</span><br><span class="line">int64 b</span><br><span class="line">int64 c</span><br><span class="line">---</span><br><span class="line">int64 sum</span><br></pre></td></tr></table></figure></li><li><p><code>CMakeLists.txt</code>：将定义的接口转换为特定语言的代码（如C++和Python），以便它们可以在这些语言中使用，需要添加以下代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">find_package(rosidl_default_generators REQUIRED)</span><br><span class="line"></span><br><span class="line">rosidl_generate_interfaces($&#123;PROJECT_NAME&#125;</span><br><span class="line">  &quot;msg/Num.msg&quot;</span><br><span class="line">  &quot;srv/AddThreeInts.srv&quot;</span><br><span class="line"> )</span><br></pre></td></tr></table></figure></li><li><p><code>package.xml</code>：接口依赖<code>rosidl_default_generators</code>来生成特定语言的代码，你需要声明对它的依赖性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;build_depend&gt;rosidl_default_generators&lt;/build_depend&gt;</span><br><span class="line"></span><br><span class="line">&lt;exec_depend&gt;rosidl_default_runtime&lt;/exec_depend&gt;</span><br><span class="line"></span><br><span class="line">&lt;member_of_group&gt;rosidl_interface_packages&lt;/member_of_group&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="编译查看"><a href="#编译查看" class="headerlink" title="编译查看"></a>编译查看</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">colcon build --packages-select tutorial_interfaces</span><br><span class="line"></span><br><span class="line">. install/setup.bash</span><br><span class="line">ros2 interface show tutorial_interfaces/msg/Num</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><ul><li><p>源码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;tutorial_interfaces/msg/num.hpp&quot;                      # CHANGE</span><br></pre></td></tr></table></figure></li><li><p>CMakeLists.txt</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find_package(tutorial_interfaces REQUIRED)                      # CHANGE</span><br><span class="line">ament_target_dependencies(talker rclcpp tutorial_interfaces)    # CHANGE</span><br><span class="line">ament_target_dependencies(listener rclcpp tutorial_interfaces)  # CHANGE</span><br></pre></td></tr></table></figure></li><li><p>package.xml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;depend&gt;tutorial_interfaces&lt;/depend&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><ul><li><p>源码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from tutorial_interfaces.msg import Num                        # CHANGE</span><br></pre></td></tr></table></figure></li><li><p>package.xml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;exec_depend&gt;tutorial_interfaces&lt;/exec_depend&gt;</span><br></pre></td></tr></table></figure></li></ul><h1 id="拓展ROS-2的接口-interface"><a href="#拓展ROS-2的接口-interface" class="headerlink" title="拓展ROS 2的接口(interface)"></a>拓展ROS 2的接口(interface)</h1><p>你可以在一个新的接口定义中使用一个现有的接口定义。</p><h1 id="ROS-Launch"><a href="#ROS-Launch" class="headerlink" title="ROS Launch"></a>ROS Launch</h1><h2 id="ROS2-启动系统"><a href="#ROS2-启动系统" class="headerlink" title="ROS2 启动系统"></a>ROS2 启动系统</h2><p>ROS 2中的启动系统负责帮助用户描述其系统的配置，然后按照描述执行。系统的配置包括运行什么程序，在哪里运行，向它们传递什么参数，以及ROS特定的约定，通过给它们各自不同的配置，使整个系统中的组件易于重复使用。它还负责监控启动的进程的状态，并报告和&#x2F;或对这些进程的状态变化做出反应。</p><p>用Python编写的启动文件可以启动和停止不同的节点，也可以触发各种事件并对其采取行动。提供这个框架的包是 launch_ros，它在下面使用非ROS专用的启动框架。</p><h2 id="编写ROS-2启动文件"><a href="#编写ROS-2启动文件" class="headerlink" title="编写ROS 2启动文件"></a>编写ROS 2启动文件</h2><p>如果你还没有，请确保你浏览了关于如何创建ROS 2软件包的快速入门教程。在ROS 2中创建启动文件的一种方法是使用Python文件，这些文件由ROS 2 CLI工具ros2 launch来执行。我们首先使用<code>ros2 pkg create &lt;pkg-name&gt; --dependencies [deps]</code> 在我们的工作区创建一个ROS 2软件包，并创建一个新的启动目录。</p><h3 id="C-包"><a href="#C-包" class="headerlink" title="C++ 包"></a>C++ 包</h3><p>如果你正在创建一个C++包，我们将只调整CMakeLists.txt文件，添加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Install launch files.</span><br><span class="line">install(DIRECTORY</span><br><span class="line">  launch</span><br><span class="line">  DESTINATION share/$&#123;PROJECT_NAME&#125;/</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>到文件的末尾（但在<code>ament_package()</code>之前）。</p><h3 id="编写启动文件"><a href="#编写启动文件" class="headerlink" title="编写启动文件"></a>编写启动文件</h3><p>在你的启动目录中，创建一个后缀为<code>.launch.py</code>的新启动文件。例如：<code>my_script.launch.py</code>。</p><p>你的启动文件应该定义<code>generate_launch_description()</code>，它返回一个 launch.LaunchDescription()，供 <code>ros2 launch</code>使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> launch</span><br><span class="line"><span class="keyword">import</span> launch.actions</span><br><span class="line"><span class="keyword">import</span> launch.substitutions</span><br><span class="line"><span class="keyword">import</span> launch_ros.actions</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_launch_description</span>():</span><br><span class="line">    <span class="keyword">return</span> launch.LaunchDescription([</span><br><span class="line">        launch.actions.DeclareLaunchArgument(</span><br><span class="line">            <span class="string">&#x27;node_prefix&#x27;</span>,</span><br><span class="line">            default_value=[launch.substitutions.EnvironmentVariable(<span class="string">&#x27;USER&#x27;</span>), <span class="string">&#x27;_&#x27;</span>],</span><br><span class="line">            description=<span class="string">&#x27;Prefix for node names&#x27;</span>),</span><br><span class="line">        launch_ros.actions.Node(</span><br><span class="line">            package=<span class="string">&#x27;demo_nodes_cpp&#x27;</span>, node_executable=<span class="string">&#x27;talker&#x27;</span>, output=<span class="string">&#x27;screen&#x27;</span>,</span><br><span class="line">            node_name=[launch.substitutions.LaunchConfiguration(<span class="string">&#x27;node_prefix&#x27;</span>), <span class="string">&#x27;talker&#x27;</span>]),</span><br><span class="line">    ])</span><br></pre></td></tr></table></figure><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 launch my_package script.launch.py</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h1&gt;&lt;p&gt;ubuntu 20.04&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo apt install ros-rolling-desktop&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://docs.ros.org/en/rolling/Installation/Ubuntu-Install-Debians.html#&quot;&gt;http://docs.ros.org/en/rolling/Installation/Ubuntu-Install-Debians.html#&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="ROS2" scheme="http://blog.onebug.tech/categories/ROS2/"/>
    
    
    <category term="ros" scheme="http://blog.onebug.tech/tags/ros/"/>
    
  </entry>
  
  <entry>
    <title>ros2与dds</title>
    <link href="http://blog.onebug.tech/2022/02/13/ROS/ros2dds/"/>
    <id>http://blog.onebug.tech/2022/02/13/ROS/ros2dds/</id>
    <published>2022-02-12T16:00:00.000Z</published>
    <updated>2023-03-23T15:29:43.008Z</updated>
    
    <content type="html"><![CDATA[<p>在探索ROS下一代通信系统的选项时，最初的选择是改进ROS 1的传输，或者使用ZeroMQ、Protocol Buffers和zeroconf（Bonjour&#x2F;Avahi）等组件库构建一个新的中间件。然而，除了这些选项（这两个选项都涉及到我们从头开始构建一个中间件），ROS项目组还考虑了其他端到端的中间件。在研究中，一个中间件脱颖而出，那就是DDS。</p><p>使用端到端中间件（如DDS）的好处是，需要维护的代码要少得多，而且中间件的行为和确切规格已经被提炼成文档。有了这种具体的规范，第三方可以审查、审计和实施具有不同程度的互操作性的中间件。此外，如果要从现有的库中构建一个新的中间件，无论如何都需要创建这种类型的规范。</p><span id="more"></span><h1 id="什么是DDS"><a href="#什么是DDS" class="headerlink" title="什么是DDS"></a>什么是DDS</h1><p><strong>DDS提供了一个发布-订阅的传输（publish-subscribe transport ）</strong>，这与ROS1的发布-订阅的传输非常相似。<strong>DDS使用OMG定义的接口描述语言进行消息定义和序列化。</strong></p><p>类似于ROS的服务系统，DDS有一个请求-响应式的传输（request-response style transport）。</p><p><strong>DDS提供的发现系统是一个分布式发现系统，这允许任何两个DDS程序进行通信，而不需要像ROS1 master那样的工具。</strong>这使得系统的容错性和灵活性更高。同时，DDS不需要使用动态发现机制，多个DDS供应商提供了静态发现的选项。</p><h2 id="技术上的可行性"><a href="#技术上的可行性" class="headerlink" title="技术上的可行性"></a>技术上的可行性</h2><p>DDSI-RTPS非常灵活，允许它用于可靠的、高水平的系统集成以及嵌入式设备上的实时应用。<strong>由于DDS默认是在UDP上实现的，它不依赖于可靠的传输或硬件进行通信。这意味着DDS必须重新发明可靠性轮子（基本上是TCP加上或减去一些功能），但作为交换，DDS获得了便携性和对行为的控制。通过对几个可靠性参数的控制，即DDS所说的服务质量（QoS），为控制通信行为提供了最大的灵活性。</strong></p><blockquote><p>尽管DDS的默认实现是通过UDP，并且只要求传输的功能水平，但有供应商支持通过TCP实现的DDS。</p></blockquote><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p><strong>eProsima的FastRTPS实现可在GitHub上获得</strong>，并获得LGPL许可。</p><p><a href="https://github.com/eProsima/Fast-RTPS">https://github.com/eProsima/Fast-RTPS</a></p><h1 id="构建在DDS上的ROS"><a href="#构建在DDS上的ROS" class="headerlink" title="构建在DDS上的ROS"></a>构建在DDS上的ROS</h1><p>ROS 2将在DDS之上提供一个类似于ROS 1的接口，为大多数ROS用户隐藏了DDS的复杂性，但又为那些有极端用例或需要与其他现有DDS系统集成的用户单独提供对底层DDS实现的访问。</p><p><img src="https://image.onebug.tech/202203062322524.png" alt="DDS and ROS API Layout"></p><h2 id="发现"><a href="#发现" class="headerlink" title="发现"></a>发现</h2><p>DDS将完全取代ROS1基于主控的发现系统。ROS需要利用DDS的API来获取信息，如所有节点的列表，所有主题的列表，以及它们是如何连接的。对这些信息的访问将被隐藏在ROS定义的API后面，防止用户直接调用DDS。</p><p><strong>DDS发现系统的优点是，在默认情况下，它是完全分布式的，不会出现中央故障点</strong>。DDS还允许用户在其发现系统中定义元数据，这将使ROS能够在发布-订阅上附加更高级别的概念。</p><h2 id="发布-订阅传输"><a href="#发布-订阅传输" class="headerlink" title="发布-订阅传输"></a>发布-订阅传输</h2><p>DDSI-RTPS协议取代ROS的TCPROS和UDPROS线协议，用于发布&#x2F;订阅。DDS API为ROS的典型发布&#x2F;订阅模式提供了更多的参与者。 </p><p>DDS的主题（Topic）与ROS中的主题概念相似。</p><p><strong>DDS中的参与者（Participant）ROS的节点（Node）概念相似</strong>。但在DDS中，节点会被表示为独立的代码对象，既不是订阅者也不是发布者。</p><p><img src="https://image.onebug.tech/202202241356558.svg+xml" alt="../../_images/dds_domain.svg"></p><h2 id="高效的传输方式"><a href="#高效的传输方式" class="headerlink" title="高效的传输方式"></a>高效的传输方式</h2><p>在ROS 1中，没有一个标准的共享内存传输，如果有任务需要比本地主机TCP更快的速度时，可以使用Nodelets。Nodelets允许发布者和订阅者通过传递<code>boost::shared_ptrs</code>到消息中来共享数据。这种进程内的通信几乎比任何进程间的通信选项更快，而且与网络发布-订阅实现向兼容。</p><p><strong>大多数DDS供应商会以透明的方式使用共享内存来优化消息流量（甚至在进程之间），只在离开Localhost时使用有线协议和UDP套接字</strong>，这为DDS提供了相当大的性能提升。</p><h2 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h2><p>目前的ROS消息定义有很大的价值。格式很简单，而且消息本身已经在机器人社区的多年使用中得到了发展。当前ROS代码的大部分语义内容都是由这些消息的结构和内容驱动的，因此保留消息的格式和内存表示法具有很大的价值。为了达到这个目标，<strong>ROS 2保留ROS 1那样的消息定义和内存表示</strong>。</p><p>因此，<strong>ROS 1的<code>.msg</code>文件将继续使用，.msg文件会被转换为<code>.idl</code>文件，以便它们可以被DDS使用。</strong>ROS 2 API将专门处理内存中的<code>.msg</code>风格的消息对象，并在发布前将其转换为.idl对象。</p><p><img src="https://image.onebug.tech/202203062320088.png" alt="Message Generation Diagram"></p><blockquote><p>在每次调用发布时将消息逐字段转换为另一种对象类型的似乎是一个巨大的性能问题，但实验表明，与序列化的成本相比，这种转换的成本是微不足道的。</p></blockquote><h2 id="语言支持"><a href="#语言支持" class="headerlink" title="语言支持"></a>语言支持</h2><p>DDS供应商通常至少提供C、C++和Java的实现，因为这些语言的API是由DDS规范明确定义的。ROS 2系统的其中一个目标是提供功能完整的C语言API，开发人员可以将C语言的API包装成一个像Python、Ruby和Lisp这样的语言。</p><h2 id="DDS实现的依赖"><a href="#DDS实现的依赖" class="headerlink" title="DDS实现的依赖"></a>DDS实现的依赖</h2><p>ROS 2的目标之一是要尽量减少依赖的数量，以提高可移植性并保持精简的依赖列表。</p><p>DDS的一个亮点，就是依赖的精简。DDS的C语言实现只依赖于系统库，C++实现只依赖于C++03编译器，而Java实现只需要JVM和Java标准库。在Ubuntu和OS X上，OpenSplice（其中一种实现）的C、C++、Java和C#实现加在一起，其大小不到3兆字节，并且没有其他依赖性。就依赖的精简性而言，DDS非常有吸引力。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在探索ROS下一代通信系统的选项时，最初的选择是改进ROS 1的传输，或者使用ZeroMQ、Protocol Buffers和zeroconf（Bonjour&amp;#x2F;Avahi）等组件库构建一个新的中间件。然而，除了这些选项（这两个选项都涉及到我们从头开始构建一个中间件），ROS项目组还考虑了其他端到端的中间件。在研究中，一个中间件脱颖而出，那就是DDS。&lt;/p&gt;
&lt;p&gt;使用端到端中间件（如DDS）的好处是，需要维护的代码要少得多，而且中间件的行为和确切规格已经被提炼成文档。有了这种具体的规范，第三方可以审查、审计和实施具有不同程度的互操作性的中间件。此外，如果要从现有的库中构建一个新的中间件，无论如何都需要创建这种类型的规范。&lt;/p&gt;</summary>
    
    
    
    <category term="ROS2" scheme="http://blog.onebug.tech/categories/ROS2/"/>
    
    
    <category term="ros" scheme="http://blog.onebug.tech/tags/ros/"/>
    
  </entry>
  
  <entry>
    <title>ROS的基础——DDS</title>
    <link href="http://blog.onebug.tech/2022/02/01/ROS/DDS/"/>
    <id>http://blog.onebug.tech/2022/02/01/ROS/DDS/</id>
    <published>2022-01-31T16:00:00.000Z</published>
    <updated>2023-03-23T15:29:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>DDS（数据分发服务）是一套通信协议和API标准，以数据为中心是他的特点，它基于发布-订阅模型进行设计。而FastRTPS是<em>eProsima</em>公司对DDS的一个开源实现。DDS是一套中间件，提供介于操作系统和应用程序之间的功能，提供了低延迟、高可靠的通信以及可扩展的架构。DDS其实分为两部分，一部分是DDS规范，一部份则是DDSI-RTPS协议，是一个互操作性协议，也就是真正实现通讯机制的部分，在ROS2中，也正是这部分，取代了ROS1的TCPROS和UDPROS。</p><span id="more"></span><blockquote><p>所谓互操作性协议，就是为了满足互操作性而产生的一个协议，互操作性就是指两个实体的通信能力，如果两个实体之间能够在任何情况下都无误解的进行通信，那么我们就说这两个实体可以正确的互操作。</p></blockquote><p>DDS的架构是这个样子的：</p><p><img src="https://image.onebug.tech/202202241359562.svg+xml" alt="../../_images/library_overview.svg"></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><strong>DDS实现的数据共享可以理解成一个抽象的全局数据空间，任何应用程序，不论开发语言，或者运行的操作系统类型，都可以通过相同的方式访问这个全局数据空间，就好像访问本地的存储空间一样。</strong>当然全局数据空间仅仅是一个抽象的概念，在实现时仍然是分别存储在每个应用程序的本地空间当中。在系统运行时，数据是按需传输或存储的，数据的发布者仅仅发送对方需要的数据，而订阅者仅接收并存储本地应用程序当前需要的数据。</p><p><strong>DDS还提供了非常灵活的QoS策略</strong>，以满足用户对数据共享方式的不同需求，比如可靠性，故障处理等等。针对数据安全性要求比较高的系统，<strong>DDS还提供了细颗粒度的数据安全控制</strong>，包括应用程序身份认证，权限控制，数据加密等等。</p><p><strong>DDS提供了对数据发布者和订阅者的动态发现机制</strong>，这意味着用户不必去配置通信节点的地址或其他属性信息，因为他们在运行的过程中会自动发现对方，并自动完成相关配置，即实现了即插即用。</p><h1 id="专业名词"><a href="#专业名词" class="headerlink" title="专业名词"></a>专业名词</h1><ul><li><strong>Domain：</strong>代表一个通信平面，由Domain ID唯一标识，只有在同一个域内的通信实体才可以通信；如果考虑车内通信，可以只划分1个Domain，也可以按照交互规则或其他规则，定义多个Domain；</li><li><strong>Domain Participant：</strong>代表域内通信的应用程序的本地成员身份，简单来说，就是说明同一数据域内的通信成员；</li><li><strong>Topic：</strong>是数据的抽象概念，由TopicName标识，关联相应数据的数据类型(DataType)，如果把车内所涉及的所有Topic集合在一起，这样就形成一个虚拟的全局数据空间“Global Data Space”，进一步弱化了节点的概念，所以域参与者已经不是节点的概念了；</li><li><strong>DataWriter：</strong>数据写入者，类似缓存，把需要发布的主题数据从应用层写入到DataWriter中；</li><li><strong>DataReader：</strong>数据读取者，同样可以理解为一种缓存，从订阅者得到主题数据，随之传给应用层；</li><li><strong>Publisher：</strong>发布者，发布主题数据，至少与1个DataWriter关联，通过调用DataWriter的相关函数将数据发出去；</li><li><strong>Subscriber：</strong>订阅者，订阅主题数据，至少与1个DataReader关联。当数据到达时，应用程序可能忙于执行其他操作或应用程序只是等待该消息时，这样就会存在两种情况，同步访问和异步通知。</li></ul><h1 id="DPSC模型"><a href="#DPSC模型" class="headerlink" title="DPSC模型"></a>DPSC模型</h1><p><strong>DCPS（Data-Centric Publish-Subscribe）是DDS标准中定义的以数据为中心的订阅-发布模型。在这个模型中，向全局数据空间写入数据的一方称为Publishers和DataWriter，同样地，在全局数据空间中读取数据的一方称为Subscriber和DataReader</strong>。下图中展示了它们之间的逻辑关系。除了DCPS模型，DDS标准中还定义了一套完整的应用程序接口（API），该接口标准是与平台无关的，这意味着不论应用程序使用什么开发语言，或运行在什么平台之上，只要DDS中间件的实现符合DDS标准，那么相关的应用程序即可实现不同平台间的移植。</p><p><img src="https://image.onebug.tech/20220225121143.svg+xml" alt="../../_images/rtps_domain.svg"></p><p>数据的发送过程，简单来说就是应用程序调用DataWriter对象提供的write方法，把数据传递给Publisher对象，而Publisher负责将数据在网络上发送出去。</p><blockquote><p>一个DataWriter只能从属一个Publisher，而Publisher可以拥有多个DataWriter，每一个DataWriter都绑定一个Topic。</p></blockquote><p>数据的接收过程，简单来说就是Subscriber负责从网络上接收数据，并把它存储在对应的DataReader中。</p><blockquote><p>一个DataReader只能从属一个Subscriber，而Subscriber可以拥有多个DataReader，每一个DataReader都绑定一个Topic。</p></blockquote><h1 id="Qos策略"><a href="#Qos策略" class="headerlink" title="Qos策略"></a>Qos策略</h1><p><strong>用户可以通过设置QoS策略来控制数据在应用程序之间共享的方式</strong>，每个DCPS实体，包括Topic，DataWriter，Publisher，DataReader，Subscriber等，都能够独立配置相应的QoS策略。</p><p>下面是几种常用的QoS策略（略）：</p><ul><li>DEADLINE(Topic周期更新)</li><li>LIFESPAN（DataWriter写入的数据样本具有到期时间）</li><li>HISTORY（DataWriter保存并发送旧的采样数据）</li><li>RELIABILITY（”可靠传输”）</li></ul><p><img src="https://image.onebug.tech/202203062318832.jpeg" alt="img"></p><h1 id="RTSP协议"><a href="#RTSP协议" class="headerlink" title="RTSP协议"></a>RTSP协议</h1><p>DDS的标准中并不包含传输层协议，RTPS（Real-Time Publish Subscribe）能够很好的契合DDS协议特点。<strong>RTPS基于多播、无连接的传输模型，这个模型可以映射到不同的传输协议上，如UDP&#x2F;IP（这也是目前RTPS标准中唯一被标准化的传输协议）。</strong></p><p><img src="https://image.onebug.tech/202203062318265.svg+xml" alt="../../_images/transport_comparison.svg"></p><blockquote><p>组播的原理：组播IP地址到底是谁的IP？？ - 车小胖的回答 - 知乎 <a href="https://www.zhihu.com/question/27233903/answer/108374395">https://www.zhihu.com/question/27233903/answer/108374395</a></p></blockquote><p><img src="https://image.onebug.tech/202203062318554.svg+xml" alt="../_images/DDS_concept.svg"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;DDS（数据分发服务）是一套通信协议和API标准，以数据为中心是他的特点，它基于发布-订阅模型进行设计。而FastRTPS是&lt;em&gt;eProsima&lt;/em&gt;公司对DDS的一个开源实现。DDS是一套中间件，提供介于操作系统和应用程序之间的功能，提供了低延迟、高可靠的通信以及可扩展的架构。DDS其实分为两部分，一部分是DDS规范，一部份则是DDSI-RTPS协议，是一个互操作性协议，也就是真正实现通讯机制的部分，在ROS2中，也正是这部分，取代了ROS1的TCPROS和UDPROS。&lt;/p&gt;</summary>
    
    
    
    <category term="ROS" scheme="http://blog.onebug.tech/categories/ROS/"/>
    
    
    <category term="dds" scheme="http://blog.onebug.tech/tags/dds/"/>
    
    <category term="ros" scheme="http://blog.onebug.tech/tags/ros/"/>
    
  </entry>
  
  <entry>
    <title>Java并发队列简介</title>
    <link href="http://blog.onebug.tech/2021/12/01/java/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/%E5%B9%B6%E5%8F%91%E9%98%9F%E5%88%97/"/>
    <id>http://blog.onebug.tech/2021/12/01/java/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/%E5%B9%B6%E5%8F%91%E9%98%9F%E5%88%97/</id>
    <published>2021-11-30T16:00:00.000Z</published>
    <updated>2023-03-23T15:29:42.974Z</updated>
    
    <content type="html"><![CDATA[<p>JDK 中提供了一系列场景的并发安全队列。总的来说，按照实现方式的不同可分为阻塞队列和非阻塞队列，前者使用锁实现，而后者则使用CAS 非阻塞算法实现。</p><span id="more"></span><h1 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h1><p><code>ConcurrentLinkedQueue</code> 是线程安全的无界非阻塞队列，其底层数据结构使用单向链表实现，对于入队和出队操作<strong>使用CAS 来实现线程安全</strong>。</p><p><code>ConcurrentLinkedQueue</code> 的底层使用单向链表数据结构来保存队列元素，每个元素被包装成一个Node 节点。队列是靠头、尾节点来维护的，创建队列时头、尾节点指向一个item 为null 的哨兵节点。第一次执行<code>peek</code> 操作时会把head 指向第一个真正的队列元素。由于使用非阻塞CAS 算法，没有加锁，所以在计算size 时有可能进行了<code>offer</code>、 <code>poll</code> 或者<code>remove</code> 操作， 导致<strong>计算的元素个数不精确</strong>，所以在井发情况下<code>size</code> 函数不是很有用。</p><p>如图所示，入队、出队都是操作使用<code>volatile</code> 修饰的<code>tail</code> 、<code>head</code> 节点，要保证在多线程下出入队线程安全，<strong>只需要保证这两个Node 操作的可见性和原子性即可</strong>。由于<code>volatile</code> 本身可以保证可见性，所以只需要保证对两个变量操作的原子性即可。</p><p><img src="https://image.onebug.tech/image-20211201121242572.png" alt="image-20211201121242572"></p><h1 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h1><p><code>LinkedBlockingQueue</code>是使用独占锁实现的阻塞队列。<code>LinkedBlockingQueue</code> 的内部是通过单向链表实现的，使用头、尾节点来进行入队和出队操作，也就是入队操作都是对尾节点进行操作，出队操作都是对头节点进行操作。</p><p>如图所示，<strong>对头、尾节点的操作分别使用了单独的独占锁从而保证了原子性，所以出队和入队操作是可以同时进行的。</strong>另外对头、尾节点的独占锁都配备了一个条件队列，用来存放被阻塞的线程，并结合入队、出队操作实现了一个生产消费模型。</p><p><img src="https://image.onebug.tech/image-20211201121921403.png" alt="image-20211201121921403"></p><h1 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h1><p><code>ArrayBlockingQueue</code>是有界数组方式实现的阻塞队列。</p><p>如图所示， <code>ArrayBlockingQueue</code> 通过<strong>使用全局独占锁实现了同时只能有一个线程进行入队或者出队操作</strong>，这个锁的粒度比较大。</p><p>其中，<code>offer</code>和<code>poll</code> 操作通过简单的加锁进行入队、出队操作，而<code>put</code> 、<code>take</code> 操作则使用条件变量实现，如果队列满则等待，如果队列空则等待，然后分别在出队和入队操作中发送信号激活等待线程实现同步。</p><p>另外，<strong>相比<code>LinkedBlockingQueue</code>，<code>ArrayBlockingQueue</code> 的<code>size</code>操作的结果是精确的</strong>， 因为计算前加了全局锁。</p><p><img src="https://image.onebug.tech/image-20211201122330680.png" alt="image-20211201122330680"></p><h1 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h1><p><code>PriorityBlockingQueue</code> 是带优先级的无界阻塞队列，<strong>每次出队都返回优先级最高或者最低的元素</strong>。其内部是使用<strong>平衡二叉树堆</strong>实现的，所以直接遍历队列元素不保证有序。默认使用对象的<code>compareTo</code> 方法提供比较规则，如果你需要自定义比较规则则可以自定义<code>comparators</code> 。</p><p>PriorityBlockingQueue 队列在内部使用二叉树堆维护元素优先级，使用数组作为元素存储的数据结构，这个数组是可扩容的。当元素个数＞＝最大容量时会通过CAS 算法扩容。</p><p><code>PriorityBlockingQueue</code> 类似于<code>ArrayBlockingQueue</code> ，<strong>在内部使用一个独占锁来控制，同时只有一个线程可以进行入队和出队操作</strong>。另外，<code>PriorityBlockingQueue</code>只使用了一个<code>notEmpty</code> 条件变量而没有使用<code>notFull</code> ，这是因为前者是无界队列。</p><p><img src="https://image.onebug.tech/image-20211201122801247.png" alt="image-20211201122801247"></p><h1 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h1><p><code>DelayQueue</code> 并发队列是一个无界阻塞延迟队列，队列中的每个元素都有个过期时间，<strong>当从队列获取元素时，只有过期元素才会出队列</strong>。队列头元素是最快要过期的元素。</p><p><strong>DelayQueue 内部使用PriorityQueue存放数据</strong>，使用<code>ReentrantLock</code> 实现线程同步。另外，队列里面的<strong>元素要实现<code>Delayed</code> 接口</strong>，由于每个元素都有一个过期时间，所以要实现获知当前元素还剩下多少时间就过期了的接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Delayed</span> <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;Delayed&gt; &#123;</span><br><span class="line">    <span class="comment">//获知当前元素还剩下多少时间就过期</span></span><br><span class="line">    <span class="type">long</span> <span class="title function_">getDelay</span><span class="params">(TimeUnit unit)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.onebug.tech/image-20211201185757443.png" alt="image-20211201185757443"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;JDK 中提供了一系列场景的并发安全队列。总的来说，按照实现方式的不同可分为阻塞队列和非阻塞队列，前者使用锁实现，而后者则使用CAS 非阻塞算法实现。&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="http://blog.onebug.tech/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="java" scheme="http://blog.onebug.tech/tags/java/"/>
    
    <category term="笔记" scheme="http://blog.onebug.tech/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="并发" scheme="http://blog.onebug.tech/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="java并发编程之美" scheme="http://blog.onebug.tech/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>读多写少的性能考虑--ReentrantReadWriteLock的原理剖析</title>
    <link href="http://blog.onebug.tech/2021/11/27/java/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/%E8%AF%BB%E5%86%99%E9%94%81/"/>
    <id>http://blog.onebug.tech/2021/11/27/java/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/%E8%AF%BB%E5%86%99%E9%94%81/</id>
    <published>2021-11-26T16:00:00.000Z</published>
    <updated>2021-11-27T05:06:57.220Z</updated>
    
    <content type="html"><![CDATA[<p><code>ReentrantLock</code> 是独占锁， 某时只有一个线程可以获取该锁，而实际中会有写少读多的场景，<code>ReentrantReadWriteLock</code> 应运而生。<code>ReentrantReadWriteLock</code> 采用读写分离的策略，允许多个线程可以同时获取读锁。</p><p>读写锁的内部维护了一个<code>ReadLock</code> 和一个<code>WriteLock</code> ，它们依赖Sync 实现具体功能。</p><span id="more"></span><h1 id="state的含义"><a href="#state的含义" class="headerlink" title="state的含义"></a>state的含义</h1><p><code>ReentrantReadWriteLock</code> 需要维护读状态和写状态， 为了用一个state 表示写和读两种状态，<code>ReentrantReadWriteLock</code> 巧妙地使用<code>state</code> 的<strong>高16位表示读状态</strong>，也就是获取到读锁的次数；使用<strong>低16 位表示获取到写锁的线程的可重入次数</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHARED_SHIFT</span>   <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHARED_UNIT</span>    <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_COUNT</span>      <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">EXCLUSIVE_MASK</span> <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回以count表示的共享持有的数量[读线程数]</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sharedCount</span><span class="params">(<span class="type">int</span> c)</span>    &#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回count中所代表的排他性持有的数量[写锁可重入次数]</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">exclusiveCount</span><span class="params">(<span class="type">int</span> c)</span> &#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//用来每个线程的读锁可重入数的计数器</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">HoldCounter</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">tid</span> <span class="operator">=</span> getThreadId(Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h1><h2 id="写锁的获取"><a href="#写锁的获取" class="headerlink" title="写锁的获取"></a>写锁的获取</h2><p><strong>写锁是个独占锁</strong>， 某时只有一个线程可以获取该锁。如果当前没有线程获取到读锁和写锁， 则当前线程可以获取到写锁然后返回。如果当前己经有线程获取到读锁和写锁，则当前请求写锁的线程会被阻塞挂起。另外， 写锁是可重入锁，如果当前线程己经获取了该锁，再次获取只是简单地把可重入次数加1后直接返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">            sync.acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>其中重写的<code>tryAcquire</code>方法的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line"><span class="comment">//w是写锁线程的可重入次数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> exclusiveCount(c);</span><br><span class="line">            <span class="comment">//c!=0 说明已经有线程获获取了读锁或写锁</span></span><br><span class="line">            <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line">                <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">                <span class="comment">// Reentrant acquire</span></span><br><span class="line">                setState(c + acquires);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//第一个写线程获取先锁</span></span><br><span class="line"><span class="comment">//writerShouldBlock()用来实现公平锁和非公平锁的区分</span></span><br><span class="line">            <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">                !compareAndSetState(c, c + acquires))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><code>c</code>是AQS状态变量，<code>w</code>是<code>c</code>的低16位（写状态）。</p><p><code>c!=0&amp;&amp;w==0</code>时说明状态值的的高16位（读状态）不为0，这说明了已经有线程获取了读锁，返回<code>false</code>。</p><p><code>c!=0&amp;&amp;w!=0&amp;&amp;current!= getExclusiveOwnerThread()</code> 则说明当前已经有线程获取了写锁，但是当前线程不是写锁的持有者，返回<code>false</code> 。</p><h2 id="写锁的释放"><a href="#写锁的释放" class="headerlink" title="写锁的释放"></a>写锁的释放</h2><p>如果当前线程持有写锁，调用锁释放方法会让该线程对该线程持有的AQS状态值减1 ，如果减去1后当前状态值为0 则当前线程会释放该锁， 否则仅仅减1而己。其中重写的<code>tryRelease</code>方法如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="comment">//看是否是写锁拥有者调用的unlock</span></span><br><span class="line">            <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">   <span class="comment">//获取可重入值， 这里没有考虑高16位， 因为获取写锁时读锁状态值肯定为0</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">    <span class="comment">//如采写锁可重入值为0 则释放锁，否则只是简单地更新状态值</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (free)</span><br><span class="line">                setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> free;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h1 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h1><h2 id="读锁的获取"><a href="#读锁的获取" class="headerlink" title="读锁的获取"></a>读锁的获取</h2><p>写锁是共享锁。获取读锁，如果当前<strong>没有其他线程持有写锁</strong>，则当前线程可以获取读锁， AQS 的状态值state 的高16 位的值会增加1 ，然后方法返回。否则如果其他一个线程持有写锁， 则当前线程会被阻塞。共享锁的<code>tryAcquireShared</code>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> unused)</span> &#123;</span><br><span class="line">    <span class="comment">//获取当前状态值</span></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="comment">//判断是否写锁被占用</span></span><br><span class="line">            <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                getExclusiveOwnerThread() != current)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//获取读锁计数，sharedCount返回c的高16位</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> sharedCount(c);</span><br><span class="line">   <span class="comment">//更新AQS状态值， 多个读线程只有一个会成功，不成功的进入fullTryAcquireShared进行重试。</span></span><br><span class="line">            <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">                r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">                compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line"><span class="comment">//更新一些记录信息</span></span><br><span class="line">                <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">                    firstReader = current;</span><br><span class="line">                    firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">               </span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                    firstReaderHoldCount++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">HoldCounter</span> <span class="variable">rh</span> <span class="operator">=</span> cachedHoldCounter;</span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="literal">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                        cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                        readHolds.set(rh);</span><br><span class="line">                    rh.count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="comment">//fullTryAcquireShared类似tryAcquireShared ，但是是自旋获取</span></span><br><span class="line">            <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>如上代码首先查看是否有其他线程获取到了写锁，如果是则直接返回-1。</p><blockquote><p>如果当前要获取读锁的线程己经持有了写锁， 则也可以获取读锁。但是需要注意，当一个线程先获取了写锁，然后获取了读锁处理事情完毕后，要记得把读锁和写锁都释放掉，不能只释放写锁。</p></blockquote><p>在线程尝试获取读锁前，会进行<code>readerShouldBlock</code>检查，其中非公平锁的<code>readerShouldBlock</code> 实现代码如下，代码的作用是检查队列的第一个元素是否存在以及是不是正在尝试获取写锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">readerShouldBlock</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> apparentlyFirstQueuedIsExclusive();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">apparentlyFirstQueuedIsExclusive</span><span class="params">()</span> &#123;</span><br><span class="line">    Node h, s;</span><br><span class="line">    <span class="keyword">return</span> (h = head) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        (s = h.next)  != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        <span class="comment">//判断第一个元素是不是独占锁</span></span><br><span class="line">        !s.isShared()         &amp;&amp;</span><br><span class="line">        s.thread != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进行<code>readerShouldBlock</code>检查后，还要检查获取读锁的线程是否达到了最大值，然后才是执行CAS 操作将AQS 状态值的高16 位值增加1。</p><p>更新AQS状态值后，最后还要更新一些重要的变量：</p><ul><li><code>firstReader</code>：用来记录第一个获取到读锁的线程</li><li><code>firstReaderHoldCount</code>：记录第一个获取到读锁的线程获取读锁的可重入次数</li><li><code>cachedHoldCounter</code>：记录最后一个获取读锁的线程获取读锁的可重入次数</li><li><code>readHolds</code>：ThreadLocal 变量， 用来存放除去第一个获取读锁线程外的其他线程获取读锁的可重入次数</li></ul><p><code>fullTryAcquireShared</code>类似<code>tryAcquireShared</code> ，但是是自旋获取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">fullTryAcquireShared</span><span class="params">(Thread current)</span> &#123;</span><br><span class="line">            <span class="type">HoldCounter</span> <span class="variable">rh</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//for循环，自旋获取</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">//..code</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">                 <span class="comment">//..code</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">       </span><br></pre></td></tr></table></figure><h2 id="读锁的释放"><a href="#读锁的释放" class="headerlink" title="读锁的释放"></a>读锁的释放</h2><p><code>tryReleaseShared</code>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> unused)</span> &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="comment">//code</span></span><br><span class="line">    <span class="comment">//循环直到自己的读计数-1 , CAS 更新成功</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">                <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c - SHARED_UNIT;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                    <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>在无限循环里面，首先获取当前AQS 状态值并将其保存到变量c ，然后变量c被减去一个读计数单位后使用CAS 操作更新AQS 状态值，如果更新成功则<strong>查看当前AQS 状态值是否为0</strong> ，为0则说明当前己经没有读线程占用读锁，则<code>tryReleaseShared</code> 返回true 。然后会调用<code>doReleaseShared</code> 方法<strong>释放一个由于获取写锁而被阻塞的线程</strong>，如果当前AQS 状态值不为0 ，则说明当前还有其他线程持有了读锁，所以<code>trγReleaseShared</code> 返回false 。如果<code>tryReaseShared</code> 中的CAS 更新AQS 状态值失败，则自旋重试直到成功。</p><h1 id="读写锁使用案例"><a href="#读写锁使用案例" class="headerlink" title="读写锁使用案例"></a>读写锁使用案例</h1><p>改造List，使得在读多写少的情况下保持性能和线程安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读多写少</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecureList</span> &lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    线程不安全的List</span></span><br><span class="line">    List&lt;T&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">final</span> ReentrantReadWriteLock reentrantReadWriteLock=<span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">final</span> Lock writeLock=reentrantReadWriteLock.writeLock();</span><br><span class="line">    <span class="keyword">final</span> Lock readLock=reentrantReadWriteLock.readLock();</span><br><span class="line"></span><br><span class="line">    T <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> list.get(index);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> index,T ele)</span>&#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            list.set(index,ele);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            list.remove(index);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="读写锁的改进"><a href="#读写锁的改进" class="headerlink" title="读写锁的改进"></a>读写锁的改进</h1><p><code>StampedLock</code> 是并发包里面JDK8 版本新增的一个锁，该锁提供了三种模式的读写控制，当调用获取锁的系列函数时，会返回一个long 型的变量，我们称之为戳记（ stamp)，这个戳记代表了锁的状态。其中t可系列获取锁的函数，当获取锁失败后会返回为0的stamp 值。当调用释放锁和转换锁的方法时需要传入获取锁时返回的stamp 值。</p><p><code>StampedLock</code> 提供的三种读写模式的锁分别如下：</p><ul><li>写锁<code>writeLock</code> ：独占锁。</li><li>悲观读锁<code>readLock</code> ：悲观是指在具体操作数据前其会悲观地认为其他线程可能要对自己操作的数据进行修改，所以需要先对数据加锁，这是在读少写多的情况下的一种考虑。</li><li>乐观读锁<code>tryOptimisticRead</code>：它是相对于悲观锁来说的，该锁的一个特点是适用于读多写少的场景， 因为获取读锁只是使用位操作进行检验，不涉及CAS 操作，所以效率会高很多，但是同时由于没有使用真正的锁，所以返回的不是最新的数据，但是一致性还是得到保障的。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;ReentrantLock&lt;/code&gt; 是独占锁， 某时只有一个线程可以获取该锁，而实际中会有写少读多的场景，&lt;code&gt;ReentrantReadWriteLock&lt;/code&gt; 应运而生。&lt;code&gt;ReentrantReadWriteLock&lt;/code&gt; 采用读写分离的策略，允许多个线程可以同时获取读锁。&lt;/p&gt;
&lt;p&gt;读写锁的内部维护了一个&lt;code&gt;ReadLock&lt;/code&gt; 和一个&lt;code&gt;WriteLock&lt;/code&gt; ，它们依赖Sync 实现具体功能。&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="http://blog.onebug.tech/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="java" scheme="http://blog.onebug.tech/tags/java/"/>
    
    <category term="笔记" scheme="http://blog.onebug.tech/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="并发" scheme="http://blog.onebug.tech/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="java并发编程之美" scheme="http://blog.onebug.tech/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>AQS的经典应用--可重入独占锁的原理剖析</title>
    <link href="http://blog.onebug.tech/2021/11/22/java/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/%E7%8B%AC%E5%8D%A0%E9%94%81/"/>
    <id>http://blog.onebug.tech/2021/11/22/java/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/%E7%8B%AC%E5%8D%A0%E9%94%81/</id>
    <published>2021-11-21T16:00:00.000Z</published>
    <updated>2021-11-27T04:51:53.438Z</updated>
    
    <content type="html"><![CDATA[<p><code>ReentrantLock</code> 是可重入的独占锁， 同时只能有一个线程可以获取该锁，其他获取该锁的线程会被阻塞而被放入该锁的<code>AQS</code> 阻塞队列里面。</p><p><code>ReentrantLock</code> 根据参数来决定其内部是一个公平还是非公平锁，默认是非公平锁。其中Sync 类直接继承自AQS ， 它的子类<code>NonfairSync</code> 和<code>FairSync</code> 分别实现了获取锁的非公平与公平策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h1 id="state的含义"><a href="#state的含义" class="headerlink" title="state的含义"></a>state的含义</h1><p>在<code>ReentrantLock</code> 中， AQS 的<code>state</code> 状态值表示线程获取<strong>该锁的可重入次数</strong>， 在默认情况下， <code>state</code>的值为0 表示当前锁没有被任何线程持有。当一个线程第一次获取该锁时会尝试使用CAS设置<code>state</code> 的值为1，如果CAS 成功则当前线程获取了该锁，然后记录该锁的持有者为当前线程。在该线程没有释放锁的情况下第二次获取该锁后，状态值被设置为2 ， 这就是可重入次数。在该线程释放该锁时，会尝试使用CAS 让状态值减1 ， 如果减1后状态值为0,则当前线程释放该锁。</p><h1 id="锁的获取"><a href="#锁的获取" class="headerlink" title="锁的获取"></a>锁的获取</h1><p><code>ReentrantLock</code> 的l<code>ock()</code>委托给了<code>sync</code> 类，根据创建<code>ReentrantLock</code> 构造函数选择sync 的实现是<code>NonfairSync</code> 还是<code>FairSync</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="非公平锁的获取"><a href="#非公平锁的获取" class="headerlink" title="非公平锁的获取"></a>非公平锁的获取</h2><p>默认AQS 的状态值为0，所以第一个调用<code>lock</code> 的线程会通过CAS 设置状态值为1, CAS 成功则表示当前线程获取到了锁， 然后<code>setExclusiveOwnerThread</code>设置该锁持有者是当前线程。如果这时候有其他线程调用<code>lock</code>方法企图获取该锁， CAS 会失败，然后会调用AQS的<code>acquire</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//cas设置状态值</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//调用AQS的acquire方法</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AQS 并没有提供可用的<code>tryAcquire</code> 方法， <code>tryAcquire</code> 方法需要子类自己定制化，<code>ReentrantLock</code>需要重写<code>tryAcquire</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="comment">//如果当前AQS状态为0</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//锁的持有锁是当前线程</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow，可重入次数溢出</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>nonfairTryAcquire</code>方法首先会查看当前锁的状态值是否为0 ，为0则说明当前该锁空闲，那么就尝试CAS 获取该锁，将AQS 的状态值从0 设置为1 ，并设置当前锁的持有者为当前线程然后返回 true 。如果当前状态值不为0 则说明该锁已经被某个线程持有，如果当前线程是该锁的持有者，则状态值加1 ，然后返回true 。 如果当前线程不是锁的持有者或者CAS获取锁失败则返回false，然后其会被放入AQS 阻塞队列。</p><p>需要注意的是，线程在CAS 获取锁前，并不会查看当前AQS 队列里面是否有比自己更早请求该锁的线程， 而是使用了抢夺策略，这就是不公平的体现。</p><h2 id="公平锁的获取"><a href="#公平锁的获取" class="headerlink" title="公平锁的获取"></a>公平锁的获取</h2><p>公平锁和非公平锁的获取不同之处在于重写的<code>tryAcquire</code>函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//公平性策略</span></span><br><span class="line">                <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>公平锁和非公平锁的<code>tryAcquire</code> 代码的类似，不同之处在于，<strong>公平锁在设置CAS 获取锁前添加了<code>hasQueuedPredecessors</code> 方法检查当前线程是否有前驱节点</strong>，该方法是实现公平性的核心代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasQueuedPredecessors</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">    <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">    <span class="comment">// thread is first in queue.</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">//s为队列的第一个元素</span></span><br><span class="line">    Node s;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line"><span class="comment">// 队列里面的第一个元素不是当前线程的判断：</span></span><br><span class="line">        <span class="comment">// h!=t&amp;&amp;s!=null&amp;&amp;s.thread!= Thread.cunentThread():</span></span><br><span class="line">        ((s = h.next) == <span class="literal">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果当前线程节点有前驱节点则返回true，否则如果当前AQS 队列为空或者当前线程节点是AQS 的第一个节点则返回false。</p><h1 id="锁的释放"><a href="#锁的释放" class="headerlink" title="锁的释放"></a>锁的释放</h1><p>如果当前线程持有该锁， 则调用该方法会让该线程对该线程持有的AQS状态值减1， 如果减去1 后当前状态值为0 ，则当前线程会释放该锁， 否则仅仅减1而己。同样.<code>ReentrantLock</code> 需要重写<code>tryRelease</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line"><span class="comment">//更新后的可重入次数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">    <span class="comment">//如果当前线程不是锁的持有者，抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//可重入次数变为0，将线程持有者设置为null</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                free = <span class="literal">true</span>;</span><br><span class="line">                setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="comment">//更新可重入次数</span></span><br><span class="line">            setState(c);</span><br><span class="line">            <span class="keyword">return</span> free;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h1 id="可重入锁使用案例"><a href="#可重入锁使用案例" class="headerlink" title="可重入锁使用案例"></a>可重入锁使用案例</h1><p>下面使用<code>ReentrantLock</code> 来实现一个简单的线程安全的list。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLockList</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">//线程不安全的list</span></span><br><span class="line">    List&lt;T&gt; list  = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//独占锁</span></span><br><span class="line">    <span class="keyword">final</span>  ReentrantLock lock=<span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">//添加元素</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T e)</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            list.add(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">            exception.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除元素</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            list.remove(index);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">            exception.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取元素</span></span><br><span class="line">    T <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> list.get(index);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">            exception.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码通过在操作<code>list</code>前进行加锁保证同一时间只有一个线程可以对<code>list</code>数组进行修改，但是也只能有一个线程对<code>list</code>元素进行访问。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;ReentrantLock&lt;/code&gt; 是可重入的独占锁， 同时只能有一个线程可以获取该锁，其他获取该锁的线程会被阻塞而被放入该锁的&lt;code&gt;AQS&lt;/code&gt; 阻塞队列里面。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ReentrantLock&lt;/code&gt; 根据参数来决定其内部是一个公平还是非公平锁，默认是非公平锁。其中Sync 类直接继承自AQS ， 它的子类&lt;code&gt;NonfairSync&lt;/code&gt; 和&lt;code&gt;FairSync&lt;/code&gt; 分别实现了获取锁的非公平与公平策略。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;ReentrantLock&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sync = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;NonfairSync&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;ReentrantLock&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;type&quot;&gt;boolean&lt;/span&gt; fair)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sync = fair ? &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;FairSync&lt;/span&gt;() : &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;NonfairSync&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="http://blog.onebug.tech/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="java" scheme="http://blog.onebug.tech/tags/java/"/>
    
    <category term="笔记" scheme="http://blog.onebug.tech/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="并发" scheme="http://blog.onebug.tech/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="java并发编程之美" scheme="http://blog.onebug.tech/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>Java并发包的基石--抽象同步队列(AQS)</title>
    <link href="http://blog.onebug.tech/2021/10/27/java/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/AQS/"/>
    <id>http://blog.onebug.tech/2021/10/27/java/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/AQS/</id>
    <published>2021-10-26T16:00:00.000Z</published>
    <updated>2023-03-23T15:29:42.946Z</updated>
    
    <content type="html"><![CDATA[<p><code>AbstractQueuedSynchronizer</code> 抽象同步队列简称AQS ，它是实现同步器的基础组件，并发包中锁的底层就是使用AQS 实现的。另外，大多数开发者可能永远不会直接使用AQS ，但是知道其原理对于架构设计还是很有帮助的。</p><span id="more"></span><h1 id="LockSupport-工具类"><a href="#LockSupport-工具类" class="headerlink" title="LockSupport 工具类"></a>LockSupport 工具类</h1><p>在剖析AQS之前，我们先来介绍<code>LockSupport</code>工具类，<code>LockSupport</code> 是使用<code>Unsafe</code> 类实现的，它的主要作用是挂起和唤醒线程，该工具类是创建锁和其他同步类的基础。</p><p><code>LockSupport</code> 类与每个使用它的线程都会关联一个许可证，在默认情况下调用<code>LockSupport</code> 类的方法的线程是不持有许可证的。下面介绍<code>LockSupport</code> 中的几个主要函数：</p><ul><li><p><code>void park()</code>方法：<strong>用于挂起进程</strong>。如果调用<code>park</code> 方法的线程没有拿到了与<code>LockSupport</code> 关联的许可证，调用线程会被禁止参与线程的调度， 也就是会被阻塞挂起。</p></li><li><p><code>void unpark(Thread thread)</code>方法：<strong>用于唤醒进程</strong>。当一个线程调用<code>unpark</code> 时，如果参数thread 线程没有持有thread 与<code>LockSupport</code> 类关联的许可证， 则让thread 线程持有。如果thread 之前因调用<code>park()</code>而被挂起，则调用<code>unpark</code> 后，thread获得许可证，该线程会被唤醒。</p><blockquote><p>可以把许可证不恰当地比成一次性的“免死金牌”，<code>park()</code>的线程消耗”免死金牌”，如果没有”免死金牌“，那么只能”上法场”（线程阻塞挂起）了。<code>unpark(thread)</code>授予thread线程”免死金牌”</p></blockquote></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Thread thread=<span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;child thread start park&quot;</span>);</span><br><span class="line">    <span class="comment">//调用park ，由于当前线程不持有许可证，挂起自己</span></span><br><span class="line">    LockSupport.park();</span><br><span class="line">    System.out.println(<span class="string">&quot;child thread begin unpark&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">thread.start();</span><br><span class="line"></span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">System.out.println (<span class="string">&quot;main thread begin  unpark&quot;</span>);</span><br><span class="line"><span class="comment">//调用unpark 使得 thread 持有许可证，park方法返回</span></span><br><span class="line">LockSupport.unpark(thread);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用thread的interrupt()方法会得到同样的输出</span></span><br></pre></td></tr></table></figure><p><img src="https://image.onebug.tech/image-20211024211304771.png" alt="image-20211024211304771"></p><h1 id="抽象同步队列AQS"><a href="#抽象同步队列AQS" class="headerlink" title="抽象同步队列AQS"></a>抽象同步队列AQS</h1><p><img src="https://image.onebug.tech/20200603222156602.png" alt="简单理解AQS （ 抽象的队列同步器）_迟到的help的博客-CSDN博客_抽象同步队列器"></p><p>AQS 是一个FIFO 的双向队列，其内部通过节点<code>head</code> 和<code>tail</code> 记录队首和队尾元素。</p><h2 id="节点元素"><a href="#节点元素" class="headerlink" title="节点元素"></a>节点元素</h2><p>我们首先讨论的是队列元素<code>Node</code> 。线程就保存在<code>Node</code>的<code>thread</code> 变量中。<code>Node</code> 的类型分为两种：</p><ul><li><code>SHARED</code> ：线程是获取共享资源时被阻塞挂起后放入AQS 队列</li><li><code>EXCLUSIVE</code>： 线程是获取独占资源时被挂起后放入AQS 队列的。</li></ul><p><code>Node</code>还拥有<code>waitStatus</code>变量，用于记录当前线程等待状态，可以为<code>CANCELLED</code> （线程被取消了）、<code>SIGNAL</code> （ 线程需要被唤醒）、<code>CONDITION</code> （线程在条件队列里面等待〉和<code>PROPAGATE</code> （释放共享资源时需要通知其他节点）。</p><h2 id="状态信息的获取"><a href="#状态信息的获取" class="headerlink" title="状态信息的获取"></a>状态信息的获取</h2><p>AQS 中维持了一个单一的状态信息<code>state</code>，可以通过<code>getState</code> 、<code>setState</code> 、<br><code>compareAndSetState</code> 函数修改其值。对于不同的锁阻塞和同步器，<code>state</code>拥有不同的含义。</p><p>对于AQS 来说，线程同步的关键是对状态值<code>state</code> 进行操作。根据<code>state</code> 是否属于一个线程，操作<code>state</code> 的方式分为<strong>独占方式</strong>和<strong>共享方式</strong>。</p><h3 id="独占方式"><a href="#独占方式" class="headerlink" title="独占方式"></a>独占方式</h3><p>使用独占方式获取的资源是与具体线程绑定的，就是说如果一个线程获取到了资源，就会<strong>标记</strong>是这个线程获取到了，其他线程再尝试操作<code>state</code> 获取资源时会发现当前该资源不是自己持有的，就会在获取失败后被阻塞。</p><p>在独占方式下，获取与释放资源的流程如下：</p><ol><li><p>当一个线程调用<code>acquire(int arg）</code> 方法获取独占资源时，会首先使用<code>tryAcquire</code> 方法尝试获取资源， 具体是设置状态变量<code>state</code> 的值，成功则直接返回，失败则将当前线程封装为类型为<code>Node.EXCLUSIVE</code> 的<code>Node</code> 节点后插入到AQS 阻塞队列的尾部，并调用<code>LockSupport.park(this)</code> 方法挂起自己。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">//尝试获取state资源</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        <span class="comment">//获取资源失败则调用addWaiter方法创建节点，加入队列，阻塞挂起</span></span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        </span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当一个线程调用<code>release(int arg）</code>方法时会尝试使用<code>tryRelease</code> 操作释放资源，这里是设置状态变量<code>state</code> 的值，然后调用<code>LockSupport.unpark(thread)</code>方法激活AQS 队列里面被阻塞的一个线程 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">//设置state值</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//唤醒队列中的进程</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>需要注意的是， AQS 类并没有提供可用的<code>tryAcquire</code> 和<code>tryRelease</code> 方法，正如AQS是锁阻塞和同步器的基础框架一样， <code>tryAcquire</code> 和<code>tryRelease</code> 需要由具体的子类来实现。子类在实现<code>tryAcquire</code> 和<code>tryRelease</code> 时要根据具体场景使用CAS 算法尝试修改<code>state</code> 状态值，成功则返回<code>true</code>，否则返回<code>false</code>。子类还需要明确，在调用<code>acquire</code> 和<code>release</code> 方法时<code>state</code>状态值的增减代表什么含义。</p><h3 id="共享方式"><a href="#共享方式" class="headerlink" title="共享方式"></a>共享方式</h3><p>对应共享方式的资源与具体线程是不相关的，当多个线程去请求资源时通过CAS 方式竞争获取资源，当一个线程获取到了资源后，另外一个线程再次去获取时如果当前资源还能满足它的需要，则当前线程只需要使用CAS 方式进行获取即可。</p><p>在共享方式下，获取与释放资源的流程如下：</p><ol><li><p>当线程调用<code>acquireShared(int arg)</code> 获取共享资源时，会首先使用<code>tryAcquireShared</code>操作尝试获取资源，具体是设置状态变量state 的值，成功则直接返回，失败则将当前线程封装为类型为<code>Node.SHARED</code> 的Node 节点后插入到AQS阻塞队列的尾部，并使用<code>LockSupport.park(this)</code> 方法挂起自己。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当一个线程调用<code>releaseShared(int arg）</code>时会尝试使用<code>tryReleaseShared</code> 操作释放资源，这里是设置状态变量<code>state</code> 的值，然后使用<code>LockSupport.unpark(thread)</code>激活AQS 队列里面被阻塞的线程。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AQS 类也没有提供可用的<code>tryAcquireShared</code> 和<code>tryReleaseShared</code>方法， 需要由具体的子类实现。</p><h3 id="中断的忽略"><a href="#中断的忽略" class="headerlink" title="中断的忽略"></a>中断的忽略</h3><p>独占方式下获取资源有两种函数：<code>void acquire(int arg)</code>和<code>void acquireInterruptibly(int arg)</code>，共享方式也是如此。不带<code>Interruptibly</code> 关键字的方法的意思是<strong>不对中断进行响应</strong>，也就是线程在调用方法获取资源时或者获取资源失败被挂起时，其他线程中断了该线程， 那么该线程不会因为被中断而抛出异常，它还是继续获取资源或者被挂起，也就是说不对中断进行响应，忽略中断。</p><h2 id="队列的维护"><a href="#队列的维护" class="headerlink" title="队列的维护"></a>队列的维护</h2><p>队列的维护主要看入队操作，当一个线程获取锁失败后该线程会被转换为Node 节点，然后就会使用<code>enq(final Node node）</code> 方法将该节点插入到AQS 的阻塞队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="comment">//如果队列为空，创建结点，同时被head和tail引用</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="comment">//cas设置尾结点，不成功就一直重试</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.onebug.tech/image-20211025162355530.png" alt="image-20211025162355530"></p><h1 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h1><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>和<code>notify</code> 和<code>wait</code> 是配合<code>synchronized</code> 内置锁实现线程间同步的基础设施类似，条件变量的<code>signal</code> 和<code>await</code> 方法是用来配合锁（使用AQS 实现的锁〉实现线程间同步的基础设施。</p><p>它们的不同在于， <code>synchronized</code> 同时只能与一个共享变量的<code>notify</code> 或<code>wait</code> 方法实现同步，<br>而AQS 的一个锁可以对应<strong>多个</strong>条件变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ReentrantLock reentrantLock=<span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="comment">//newCondition()方法返回reentrantLock对应的一个条件变量</span></span><br><span class="line">   <span class="keyword">static</span> Condition condition=reentrantLock.newCondition();</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">//获取独占锁</span></span><br><span class="line">               reentrantLock.lock();</span><br><span class="line">               System.out.println(<span class="string">&quot;begin wait &quot;</span>);</span><br><span class="line">               <span class="comment">//调用条件变量的await()方法阻塞挂起</span></span><br><span class="line">               condition.await();</span><br><span class="line">               System.out.println(<span class="string">&quot;end wait&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">finally</span> &#123;</span><br><span class="line">               reentrantLock.unlock();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;).start();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">//获取独占锁</span></span><br><span class="line">               reentrantLock.lock();</span><br><span class="line">               Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">               System.out.println(<span class="string">&quot;begin signal &quot;</span>);</span><br><span class="line">               condition.signal();</span><br><span class="line">               System.out.println(<span class="string">&quot;end signal&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">finally</span> &#123;</span><br><span class="line">               reentrantLock.unlock();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;).start();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.onebug.tech/image-20211027192845636.png" alt="image-20211027192845636"></p><p>其实这里的<code>reentrantLock</code>对象等价于<code>synchronized</code> 加上共享变量，调用<code>reentrantLock.lock()</code>方法就相当于进入了<code>synchronized</code> 块（获取了共享变量的内置锁），调用<code>reentrantLock.iunlock()</code>方法就相当于退出<code>synchronized</code> 块。调用条件变量的<code>await()</code>方法就相当于调用共享变量的<code>wait()</code>方法，调用条件变量的<code>signal</code> 方法就相当于调用共享变量的<code>notify()</code>方法。调用条件变量的<code>signalAll()</code>方法就相当于调用共享变量的<code>notifyAll()</code>方法。</p><h2 id="原理剖析"><a href="#原理剖析" class="headerlink" title="原理剖析"></a>原理剖析</h2><p><code>lock.newCondition()</code>的作用其实是new 了一个在AQS 内部声明的<code>ConditionObject</code> 对象， <code>ConditionObject</code> 是AQS 的内部类，可以访问AQS 内部的变量（例如状态变量<code>state</code> ）和方法。在每个条件变量内部都维护了一个条件队列，用来存放调用条件变量的<code>await()</code>方法时被阻塞的线程。注意这个条件队列是单向队列，和AQS 队列不是一回事。</p><p><img src="https://image.onebug.tech/201912222329_295.jpg" alt="浅谈Java中的Condition条件队列，手摸手带你实现一个阻塞队列！ - Java填坑笔记- 博客园"></p><p>当线程调用条件变量的<code>await()</code>方法时（必须先调用锁的<code>lock()</code>方法获取锁），在内部会构造一个类型为<code>Node.CONDITION</code> 的node节点，然后将该节点插入条件队列末尾，之后当前线程会释放获取的锁（ 也就是会操作锁对应的<code>state</code> 变量的值），并被阻塞挂起。这时候如果有其他线程调用<code>lock.lock()</code> 尝试获取锁，就会有一个线程获取到锁，如果获取到锁的线程调用了条件变量的<code>await()</code>方法，则该线程也会被放入条件变量的阻塞队列，然后释放获取到的锁，在<code>await()</code>方法处阻塞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">         <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">     <span class="comment">//调用addConditionWaiter方法创建新的node节点，并插入到条件队列末尾</span></span><br><span class="line">         <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();</span><br><span class="line"><span class="comment">//释放当前锁</span></span><br><span class="line">         <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);</span><br><span class="line">         <span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//调用park方法阻塞挂起当前线程</span></span><br><span class="line">         <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">             LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">             <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         ...</span><br><span class="line">     &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">addConditionWaiter</span><span class="params">()</span> &#123;</span><br><span class="line">           <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> lastWaiter;</span><br><span class="line">           ...</span><br><span class="line">           <span class="comment">//创建类型为Node.CONDITON的节点</span></span><br><span class="line">           <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//向单向队列尾部插入一个元素</span></span><br><span class="line">           <span class="keyword">if</span> (t == <span class="literal">null</span>)</span><br><span class="line">               firstWaiter = node;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               t.nextWaiter = node;</span><br><span class="line">           lastWaiter = node;</span><br><span class="line">           <span class="keyword">return</span> node;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>当另外一个线程调用条件变量的<code>signaL</code>  方法时（ 必须先调用锁的<code>lock()</code> 方法获取锁），在内部会把条件队列里面队头的一个线程节点从条件队列里面移除并放入AQS 的阻塞队列里面， 然后激活这个线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">//将队列头元素移动到AQS队列</span></span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;AbstractQueuedSynchronizer&lt;/code&gt; 抽象同步队列简称AQS ，它是实现同步器的基础组件，并发包中锁的底层就是使用AQS 实现的。另外，大多数开发者可能永远不会直接使用AQS ，但是知道其原理对于架构设计还是很有帮助的。&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="http://blog.onebug.tech/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="java" scheme="http://blog.onebug.tech/tags/java/"/>
    
    <category term="笔记" scheme="http://blog.onebug.tech/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="并发" scheme="http://blog.onebug.tech/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="java并发编程之美" scheme="http://blog.onebug.tech/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>写时复制与弱一致性--CopyOnWriteArrayList源码剖析</title>
    <link href="http://blog.onebug.tech/2021/10/21/java/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/CopyOnWriteList/"/>
    <id>http://blog.onebug.tech/2021/10/21/java/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/CopyOnWriteList/</id>
    <published>2021-10-20T16:00:00.000Z</published>
    <updated>2023-03-23T15:29:42.957Z</updated>
    
    <content type="html"><![CDATA[<p><code>CopyOnWriteArrayList</code> 是一个线程安全的<code>ArrayList</code> ，对其进行的修改操作都是在底层的一个复制的数组（快照）上进行的，也就是使用了<strong>写时复制</strong>策略。</p><p><img src="https://image.onebug.tech/image-20211021195250084.png" alt="image-20211021195250084"></p><p>在<code>CopyOnWriteArrayList</code> 的类图中，每个<code>CopyOnWriteArrayList</code> 对象里面有一个使用<code>volatile</code>修饰的<code>array</code> 数组对象用来存放具体元素，独占锁<code>lock</code>用来保证同时只有1个线程对<code>array</code>进行修改。</p><span id="more"></span><h2 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h2><p><code>CopyOnWriteArrayList</code> 的写操作需要上锁，下面是<code>add(E e)</code>添加元素的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">//获取独占锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取array</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">       <span class="comment">//复制array到新数组，添加元素到新数组</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        <span class="comment">//使用新数组替换原数组</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//释放独占锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setArray</span><span class="params">(Object[] a)</span> &#123;</span><br><span class="line">    array = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>add(E e)</code>操作是通过<code>加锁-复制-添加-覆盖-解锁</code>实现的，保证了线程安全。从代码可以知道，新数组的大小是原来数组大小加一，<code>CopyOnWriteArrayList</code> 是无界数组。</p><p>修改、删除、添加元素的这些写操作的思路都差不多，这里不进行赘述。</p><h2 id="弱一致性的迭代器"><a href="#弱一致性的迭代器" class="headerlink" title="弱一致性的迭代器"></a>弱一致性的迭代器</h2><p>在讨论读操作前，我们先讨论<code>CopyOnWriteArrayList</code> 中的迭代器的弱一致性。弱一致性是指返回迭代器后，其他线程对list 的增删改对迭代器是不可见的。例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">CopyOnWriteArrayList&lt;Integer&gt; copyOnWriteArrayList=</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">Thread thread=<span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    <span class="comment">//写操作</span></span><br><span class="line">    copyOnWriteArrayList.remove(<span class="number">1</span>);</span><br><span class="line">    copyOnWriteArrayList.set(<span class="number">0</span>,<span class="number">100</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//在写操作前获取迭代器</span></span><br><span class="line">Iterator&lt;Integer&gt; iterator=copyOnWriteArrayList.iterator();</span><br><span class="line"><span class="comment">//启动线程</span></span><br><span class="line">thread.start();</span><br><span class="line"><span class="comment">//等待线程执行完毕</span></span><br><span class="line">thread.join();</span><br><span class="line"><span class="comment">//迭代元素</span></span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.onebug.tech/image-20211021205356619.png" alt="image-20211021205356619"></p><p>源码剖析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">COWIterator</span>&lt;E&gt;(getArray(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">COWIterator</span><span class="params">(Object[] elements, <span class="type">int</span> initialCursor)</span> &#123;</span><br><span class="line">    cursor = initialCursor;</span><br><span class="line">    snapshot = elements;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (! hasNext())</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="keyword">return</span> (E) snapshot[cursor++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> cursor &lt; snapshot.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用<code>iterator()</code>方法获取迭代器时实际上会返回一个<code>COWiterator</code> 对象， <code>COWiterator</code> 对象的<code>snapshot</code> 变量保存了当前list 的内容， <code>cursor</code> 是遍历list 时数据的下标。</p><p>为什么说snapshot 是list 的快照呢？明明是指针传递的引用啊，而不是副本。如果在该线程使用返回的迭代器代器遍历元素的过程中， 其他线程没有对list 进行增删改，那么snapshot 本身就是list 的array ， 因为它们是引用关系。但是如果在遍历期间其他线程对该list 进行了增删改，那么snapshot 就是快照了，因为增删改后list 里面的数组被新数组替换了，这时候老数组被snapshot引用。这也说明获取迭代器后， 使用该法代器元素时， 其他线程对该list 进行的增删改不可见，<strong>因为它们操作的是两个不同的数组</strong>， 这就是弱一致性。</p><h2 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h2><p><code>CopyOnWriteArrayList</code> 的读操作不会上锁，也就是说，<strong>读操作是允许多个线程进入的</strong>。下面是<code>get(int index)</code>获取元素操作的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> E <span class="title function_">get</span><span class="params">(Object[] a, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在如上代码中， 当线程x 调用<code>get</code> 方法获取指定位置的元素时，分两步走， 首先获取<code>array</code> 数组（这里命名为步骤A ），然后通过下标访问指定位置的元素（这里命名为步骤B ) ，这是两步操作， 但是在整个过程中并没有进行加锁同步。也就是说，假设这时候List 内容如图所示，里面有1、2 、3 三个元素。</p><p><img src="https://image.onebug.tech/image-20211021201352808.png" alt="image-20211021201352808"></p><p>由于执行步骤A 和步骤B 没有加锁，这就可能导致在线程x执行完步骤A 后执行步骤B前， 另外一个线程y进行了<code>remove</code> 操作，假设要线程y要删除元素1， <code>remove</code> 操作首先会获取独占锁， 然后进行写时复制操作，也就是复制一份当前<code>array</code> 数组， 然后在复制的数组里面删除元素1 ，之后让<code>array</code>指向复制的新数组。而这时候<code>array</code>之前指向的数组的引用计数为1而不是0， 因为线程x 还在使用它，这时线程x 开始执行步骤B ，步骤B 操作的数组是线程y 删除元素之前的数组。</p><p><img src="https://image.onebug.tech/image-20211021201430872.png" alt="image-20211021201430872"></p><p>所以，虽然线程y己经删除了<code>index</code>处的元素，但是线程x 的步骤B 还是<strong>有可能</strong>会返回<code>index</code> 处的元素，这其实就是写时复制策略产生的<strong>弱一致性问题</strong>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt; 是一个线程安全的&lt;code&gt;ArrayList&lt;/code&gt; ，对其进行的修改操作都是在底层的一个复制的数组（快照）上进行的，也就是使用了&lt;strong&gt;写时复制&lt;/strong&gt;策略。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://image.onebug.tech/image-20211021195250084.png&quot; alt=&quot;image-20211021195250084&quot;&gt;&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt; 的类图中，每个&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt; 对象里面有一个使用&lt;code&gt;volatile&lt;/code&gt;修饰的&lt;code&gt;array&lt;/code&gt; 数组对象用来存放具体元素，独占锁&lt;code&gt;lock&lt;/code&gt;用来保证同时只有1个线程对&lt;code&gt;array&lt;/code&gt;进行修改。&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="http://blog.onebug.tech/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="java" scheme="http://blog.onebug.tech/tags/java/"/>
    
    <category term="笔记" scheme="http://blog.onebug.tech/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="并发" scheme="http://blog.onebug.tech/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="java并发编程之美" scheme="http://blog.onebug.tech/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>原子性操作类--高并发下的CAS解决方案</title>
    <link href="http://blog.onebug.tech/2021/10/19/java/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/AtomicLong%E5%92%8CLongAdder/"/>
    <id>http://blog.onebug.tech/2021/10/19/java/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/AtomicLong%E5%92%8CLongAdder/</id>
    <published>2021-10-18T16:00:00.000Z</published>
    <updated>2023-03-23T15:29:42.951Z</updated>
    
    <content type="html"><![CDATA[<p>JUC 包提供了一系列的原子性操作类，这些类都是使用非阻塞算法CAS 实现的，相比使用锁实现原子性操作这在性能上有很大提高。由于原子性操作类的原理都大致相同，所以本文只讲解最简单的<code>AtomicLong</code> 类及JDK 8 中新增的<code>LongAdder</code> 的实现原理。</p><span id="more"></span><h1 id="AtomicLong"><a href="#AtomicLong" class="headerlink" title="AtomicLong"></a>AtomicLong</h1><p>JUC 并发包中包含有<code>Atomiclnteger</code> 、<code>AtomicLong</code> 和<code>AtomicBoolean</code> 等原子性操作类，它们的原理类似。AtomicLong 是原子性递增或者递减类，其内部使用<code>Unsafe</code> 来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicLong</span> <span class="keyword">extends</span> <span class="title class_">Number</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line"><span class="comment">//获取Unsafe实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> Unsafe.getUnsafe();</span><br><span class="line">    <span class="comment">//存放value的偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取value在AtomicLong的偏移量</span></span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicLong.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//实际变量值，使用volatile修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> value;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment">//调用unsafe方法，原子性设置value值为原始值+1， 返回值为原始值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">long</span> <span class="title function_">getAndIncrement</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddLong(<span class="built_in">this</span>, valueOffset, <span class="number">1L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>getAndIncrement()</code>、<code>getAndDecrement()</code>等主要数都是通过调用<code>Unsafe</code> 的<code>getAndAddLong</code> 方法来实现操作，其在JDK8中的实现为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">long</span> <span class="title function_">getAndAddLong</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">long</span> var4)</span> &#123;</span><br><span class="line">        <span class="type">long</span> var6;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">//传入对象地址和实际值偏移量，获取实际值</span></span><br><span class="line">            var6 = <span class="built_in">this</span>.getLongVolatile(var1, var2);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//尝试CAS更新实际值，失败则重试</span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">this</span>.compareAndSwapLong(var1, var2, var6, var6 + var4));</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var6;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="LongAdder"><a href="#LongAdder" class="headerlink" title="LongAdder"></a>LongAdder</h1><p><code>AtomicLong</code> 通过CAS 提供了非阻塞的原子性操作，相比使用阻塞算法的同步器来说它的性能己经很好了，但是使用<code>AtomicLong</code> 时，在高并发下大量线程会同时去竞争更新同一个原子变量，但是由于同时只有一个线程的CAS 操作会成功，这就造成了大量线程竞争失败后，会通过无限循环不断进行自旋尝试CAS 的操作， 而这会白白浪费CPU 资源。JDK 8 新增了一个原子性递增或者递减类<code>LongAdder</code> 用来克服在高并发下使用<code>AtomicLong</code> 的缺点。</p><p>既然<code>AtomicLong</code> 的性能瓶颈是由于过多线程同时去竞争一个变量的更新而产生的，那么可以把一个变量分解为多个变量，让同样多的线程去竞争多个资源，从而解决性能问题，这就是<code>LongAdder</code>设计的思路。</p><p><img src="https://image.onebug.tech/LongAddr-CAS.png" alt="Java AtomicLong 和LongAdder | A Big Boy Blog - Tech Articls &amp; Notes"></p><p><code>LongAdder</code> 在内部维护多个<code>Cell</code> 变量，<code>Cell</code> 类型是<code>AtomicLong</code>的一个改进。这样，在同等并发量的情况下，争夺单个变量更新操作的线程量会减少，这变相地减少了争夺共享资源的并发量。另外，多个线程在争夺同一个<code>Cell</code> 原子变量时如果失败了， 它并不是在当前<code>Cell</code> 变量上一直自旋CAS 重试，而是尝试在其他<code>Cell</code>的变量上进行CAS 尝试，这个改变增加了当前线程重试CAS 成功的可能性。</p><p>最后，在获取<code>LongAdder</code>当前值时， 是把所有<code>Cell</code> 变量的value值累加后再加上<code>base</code>返回的。</p><p>由于<code>Cells</code> 占用的内存是相对比较大的，所以一开始并不创建它，而是在需要时创建，也就是惰性加载。<code>LongAdder</code> 维护了一个延迟初始化的原子性更新数组（默认情况下<code>Cell</code> 数组是<code>null</code>）和一个基值变量<code>base</code> 。</p><p><img src="https://image.onebug.tech/image-20211019171832480.png" alt="image-20211019171832480"></p><p> <code>LongAdder</code> 类内部维护着三个变量。获取<code>LongAdder</code> 的真实值时，得到的其实是<code>base</code> 的值与<code>cells</code> 数组里面所有<code>Cell</code> 元素中的<code>value</code> 值的累加，<code>base</code> 是个基础值，默认为0 。<code>cellsBusy</code> 用来实现自旋锁，状态值只有0 和1，使用CAS操作<code>cellsBusy</code> 来保证同时只有一个线程可以进行创建<code>Cell</code> 元素、扩容<code>cells</code> 数组、初始化<code>cells</code> 数组这些操作。</p><p><code>LongAdder</code> 类的主要函数有：</p><ul><li><code>long sum()</code>：返回当前的值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sum</span><span class="params">()</span> &#123;</span><br><span class="line">       Cell[] as = cells; Cell a;</span><br><span class="line">   <span class="comment">//bash值加上所有Cell内部的value值后就是当前值</span></span><br><span class="line">       <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> base;</span><br><span class="line">       <span class="keyword">if</span> (as != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">               <span class="keyword">if</span> ((a = as[i]) != <span class="literal">null</span>)</span><br><span class="line">                   sum += a.value;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> sum;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>要注意的是，由于计算总和时没有对<code>cells</code>数组进行加锁，所以在累加过程中可能有其他线程对<code>Cell</code> 中的值进行了修改， 也有可能对数组进行了扩容，所以<code>sum</code>返回的值并不是非常精确的， 其返回值并不是一个调用<code>sum</code> 方法时的原子快照值。</p><ul><li><code>add(long x)</code>：增加给定值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">long</span> x)</span> &#123;</span><br><span class="line">    Cell[] as; <span class="type">long</span> b, v; <span class="type">int</span> m; Cell a;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//cell是否为null，是的话就在基础变量base上累加</span></span><br><span class="line">    <span class="keyword">if</span> ((as = cells) != <span class="literal">null</span> || !casBase(b = base, b + x)) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">boolean</span> <span class="variable">uncontended</span> <span class="operator">=</span> <span class="literal">true</span>;  </span><br><span class="line">        <span class="keyword">if</span> (as == <span class="literal">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            决定当前线程应该访问cells 数组里面的哪一个Cell元素</span></span><br><span class="line"><span class="comment">            其中m 是当前cells数组元素个数－1 , getProbe()获取的是当前线程中变量threadLocalRandomProbe的值</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            (a = as[getProbe() &amp; m]) == <span class="literal">null</span> ||</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//用CAS操作去更新分配到的Cell元素的value 值</span></span><br><span class="line">            !(uncontended = a.cas(v = a.value, v + x)))</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//初始化或扩容cells数组</span></span><br><span class="line">            longAccumulate(x, <span class="literal">null</span>, uncontended);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>longAccumulate</code>源码解析： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">longAccumulate</span><span class="params">(<span class="type">long</span> x, LongBinaryOperator fn,</span></span><br><span class="line"><span class="params">                           <span class="type">boolean</span> wasUncontended)</span> &#123;</span><br><span class="line">     <span class="type">int</span> h;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    初始化当前线程的变量threadLocalRandomProbe的值，</span></span><br><span class="line"><span class="comment">    这个变量在计算当前线程应该被分配到cells数组的哪一个Cell 元素时会用到。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">     <span class="keyword">if</span> ((h = getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">         ThreadLocalRandom.current(); <span class="comment">// force initialization</span></span><br><span class="line">         h = getProbe();</span><br><span class="line">         wasUncontended = <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   </span><br><span class="line">     <span class="type">boolean</span> <span class="variable">collide</span> <span class="operator">=</span> <span class="literal">false</span>;                <span class="comment">// True if last slot nonempty</span></span><br><span class="line">     <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">         Cell[] as; Cell a; <span class="type">int</span> n; <span class="type">long</span> v;</span><br><span class="line">         <span class="keyword">if</span> ((as = cells) != <span class="literal">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">             </span><br><span class="line">             <span class="comment">//当前线程计算要访问的Cell元素下标，然后如果发现对应下标元素的值为null</span></span><br><span class="line">             <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="literal">null</span>) &#123;</span><br><span class="line">                 <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;       <span class="comment">// Try to attach new Cell</span></span><br><span class="line">                     <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     新增一个Cell 元素到cell 数组，</span></span><br><span class="line"><span class="comment">                     并且在将其添加到cells 数组之前要竞争设置cellsBusy 为1</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                     <span class="type">Cell</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cell</span>(x);   <span class="comment">// Optimistically create</span></span><br><span class="line"></span><br><span class="line">                     <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                         <span class="type">boolean</span> <span class="variable">created</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                         <span class="keyword">try</span> &#123;               <span class="comment">// Recheck under lock</span></span><br><span class="line">                             Cell[] rs; <span class="type">int</span> m, j;</span><br><span class="line">                             <span class="keyword">if</span> ((rs = cells) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                                 (m = rs.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                                 rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="literal">null</span>) &#123;</span><br><span class="line">                                 rs[j] = r;</span><br><span class="line">                                 created = <span class="literal">true</span>;</span><br><span class="line">                             &#125;</span><br><span class="line">                         &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                             cellsBusy = <span class="number">0</span>;</span><br><span class="line">                         &#125;</span><br><span class="line">                         <span class="keyword">if</span> (created)</span><br><span class="line">                             <span class="keyword">break</span>;</span><br><span class="line">                         <span class="keyword">continue</span>;           <span class="comment">// Slot is now non-empty</span></span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">                 collide = <span class="literal">false</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)       <span class="comment">// CAS already known to fail</span></span><br><span class="line">                 wasUncontended = <span class="literal">true</span>;      <span class="comment">// Continue after rehash</span></span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (a.cas(v = a.value, ((fn == <span class="literal">null</span>) ? v + x :</span><br><span class="line">                                          fn.applyAsLong(v, x))))</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= NCPU || cells != as)</span><br><span class="line">                 collide = <span class="literal">false</span>;            <span class="comment">// At max size or stale</span></span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">                 collide = <span class="literal">true</span>;</span><br><span class="line">             </span><br><span class="line">             <span class="comment">/*</span></span><br><span class="line"><span class="comment">             下面数组是扩容cells数组的代码，扩容条件的前提具体就是</span></span><br><span class="line"><span class="comment">             当前cells 的元素个数小于当前机器CPU个数</span></span><br><span class="line"><span class="comment">             并且当前多个线程访问了cells中同一个元素从而导致冲突使其中一个线程CAS失败。</span></span><br><span class="line"><span class="comment">             和初始化一样，需要cas设置cellsBusy值，保证cells数组的互斥访问。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                 <span class="keyword">try</span> &#123;</span><br><span class="line">                     <span class="keyword">if</span> (cells == as) &#123;      <span class="comment">// Expand table unless stale</span></span><br><span class="line">                         <span class="comment">//扩容为原来的两倍</span></span><br><span class="line">                         Cell[] rs = <span class="keyword">new</span> <span class="title class_">Cell</span>[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                         <span class="comment">//将旧的cells数组复制新的cells数组</span></span><br><span class="line">                         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                             rs[i] = as[i];</span><br><span class="line">                         cells = rs;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                     cellsBusy = <span class="number">0</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">                 collide = <span class="literal">false</span>;</span><br><span class="line">                 <span class="keyword">continue</span>;                   <span class="comment">// Retry with expanded table</span></span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">/*CAS 失败的线程重新计算当前线程的随机值threadLocalRandomProbe,</span></span><br><span class="line"><span class="comment">             以减少下次访问cells元素时的冲突机会*/</span></span><br><span class="line">             h = advanceProbe(h);</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">         <span class="comment">//下面是初始化cells数组的代码</span></span><br><span class="line">         </span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">         cellsBusy 是一个状态标识，</span></span><br><span class="line"><span class="comment">         为0说明当前cells 数组没有在被初始化或者扩容，也没有在新建Cell元素，</span></span><br><span class="line"><span class="comment">         当前线程通过casCellsBusy()设置cellsBusy 为l ，</span></span><br><span class="line"><span class="comment">         则当前线程在初始化cells数组时，其他线程就不能进行对cells数组进行初始化。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">             <span class="type">boolean</span> <span class="variable">init</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">             <span class="keyword">try</span> &#123;                           <span class="comment">// Initialize table</span></span><br><span class="line">                 <span class="keyword">if</span> (cells == as) &#123;</span><br><span class="line">                     <span class="comment">//初始化cells 数组元素个数为2</span></span><br><span class="line">                     Cell[] rs = <span class="keyword">new</span> <span class="title class_">Cell</span>[<span class="number">2</span>];</span><br><span class="line">                     <span class="comment">//使用h&amp;1计算当前线程应该访问celll 数组的哪个位置</span></span><br><span class="line">                     rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Cell</span>(x);</span><br><span class="line">                     cells = rs;</span><br><span class="line">                     <span class="comment">//标识cells 数组已经被初始化</span></span><br><span class="line">                     init = <span class="literal">true</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                 <span class="comment">/*重置了cellsBusy 标记。这里没有使用CAS 操作，却是线程安全的，</span></span><br><span class="line"><span class="comment">                 原因是cellsBusy 是volatile类型的，这保证了变量的内存可见性，</span></span><br><span class="line"><span class="comment">                 另外此时其他地方的代码没有机会修改cellsBusy的值*/</span></span><br><span class="line">                 cellsBusy = <span class="number">0</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (init)</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (casBase(v = base, ((fn == <span class="literal">null</span>) ? v + x :</span><br><span class="line">                                     fn.applyAsLong(v, x))))</span><br><span class="line">             <span class="keyword">break</span>;                          <span class="comment">// Fall back on using base</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>阅读上面的源码后，我们基本可以回答以下几个重要问题：</p><ul><li><p>LongAdder 的结构是怎样的</p><p><code>base</code>基值变量，<code>cells</code>数组，<code>cellsBusy</code>标识</p></li><li><p>当前线程应该访问<code>cells</code>数组里面的哪一个<code>Cell</code> 元素</p><p>元素下标通过<code>cells</code>数组长度对<code>threadLocalRandomProbe</code>取模计算得到，<code>threadLocalRandomProbe</code>可以看成是<code>ThreadLocal</code>类型的变量，只与当前线程相关。</p></li><li><p>如何初始化<code>cells</code>数组？ 略</p></li><li><p><code>cells</code>数组如何扩容？略</p></li><li><p>线程访问分配的Cell 元素有冲突后如何处理：扩容（需要满足<code>cells</code> 数组元素个数小于CPU核心数），并重新计算当前线程的<code>threadLocalRandomProbe</code>，减小冲突概率</p></li><li><p>如何保证线程操作被分配的<code>Cell</code> 元素的原子性：CAS操作</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;JUC 包提供了一系列的原子性操作类，这些类都是使用非阻塞算法CAS 实现的，相比使用锁实现原子性操作这在性能上有很大提高。由于原子性操作类的原理都大致相同，所以本文只讲解最简单的&lt;code&gt;AtomicLong&lt;/code&gt; 类及JDK 8 中新增的&lt;code&gt;LongAdder&lt;/code&gt; 的实现原理。&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="http://blog.onebug.tech/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="java" scheme="http://blog.onebug.tech/tags/java/"/>
    
    <category term="笔记" scheme="http://blog.onebug.tech/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="并发" scheme="http://blog.onebug.tech/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="java并发编程之美" scheme="http://blog.onebug.tech/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>高并发下随机数的获取--ThreadlocalRandom</title>
    <link href="http://blog.onebug.tech/2021/10/16/java/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/ThreadLocal%20Random/"/>
    <id>http://blog.onebug.tech/2021/10/16/java/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/ThreadLocal%20Random/</id>
    <published>2021-10-15T16:00:00.000Z</published>
    <updated>2023-03-23T15:29:42.972Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Random类的局限性"><a href="#Random类的局限性" class="headerlink" title="Random类的局限性"></a>Random类的局限性</h1><p>每个Random 实例里面都有一个原子性的种子变量用来记录当前的种子值，当要生成新的随机数时需要根据当前种子计算新的种子并更新回原子变量。在多线程下使用单个Random 实例生成随机数时，当多个线程同时计算随机数来计算新的种子时，多个线程会竞争同一个原子变量的更新操作，由于原子变量的更新是CAS 操作，同时只有一个线程会成功，所以会造成大量线程进行自旋重试， 这会降低并发性能，所以<code>ThreadLocalRandom</code> 应运而生。</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Random类的核心方法，CAS操作会导致高竞用情况下的性能下降</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">next</span><span class="params">(<span class="type">int</span> bits)</span> &#123;</span><br><span class="line">       <span class="type">long</span> oldseed, nextseed;</span><br><span class="line">       <span class="type">AtomicLong</span> <span class="variable">seed</span> <span class="operator">=</span> <span class="built_in">this</span>.seed;</span><br><span class="line">       <span class="keyword">do</span> &#123;</span><br><span class="line">           oldseed = seed.get();</span><br><span class="line">           nextseed = (oldseed * multiplier + addend) &amp; mask;</span><br><span class="line">       &#125; <span class="keyword">while</span> (!seed.compareAndSet(oldseed, nextseed));</span><br><span class="line">       <span class="keyword">return</span> (<span class="type">int</span>)(nextseed &gt;&gt;&gt; (<span class="number">48</span> - bits));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="ThreadlocalRandom"><a href="#ThreadlocalRandom" class="headerlink" title="ThreadlocalRandom"></a>ThreadlocalRandom</h1><p>为了弥补多线程高并发情况下Random 的缺陷， <code>ThreadLocalRandom</code>类应运而生。<code>ThreadLocalRandom</code> 使用<code>ThreadLocal</code>的原理，让每个线程都持有一个本地的种子变量，该种子变量只有在使用随机数时才会被初始化。在多线程下计算新种子时是根据自己线程内维护的种子变量进行更新，从而避免了竞争。<br><code>ThreadLocalRandom</code> 类似于<code>ThreadLocal</code> 类，就是个工具类。当线程调用<code>ThreadLocalRandom</code> 的<code>current</code>方法时， <code>ThreadLocalRandom</code> 负责初始化调用线程的<code>threadLocalRandomSeed</code> 变量， 也就是初始化种子。<br>当调用<code>ThreadLocalRandom</code> 的<code>nextlnt</code> 方法时，实际上是获取当前线程的<code>threadLocalRandomSeed</code> 变量作为当前种子来计算新的种子，然后更新新的种子到当前线程的<code>threadLocalRandomSeed</code> 变量，而后再根据新种子并使用具体算法计算随机数。</p><blockquote><p><code>threadLocalRandomSeed</code> 变量是Thread 类里面的一个普通long 变量</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//ThreadLocalRandom类的核心代码</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="title function_">nextSeed</span><span class="params">()</span> &#123;</span><br><span class="line">       Thread t; <span class="type">long</span> r; <span class="comment">// read and update per-thread seed</span></span><br><span class="line">       UNSAFE.putLong(t = Thread.currentThread(), SEED,</span><br><span class="line">                      r = UNSAFE.getLong(t, SEED) + GAMMA);</span><br><span class="line">       <span class="keyword">return</span> r;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.onebug.tech/image-20211016224505557.png" alt="image-20211016224505557"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Random类的局限性&quot;&gt;&lt;a href=&quot;#Random类的局限性&quot; class=&quot;headerlink&quot; title=&quot;Random类的局限性&quot;&gt;&lt;/a&gt;Random类的局限性&lt;/h1&gt;&lt;p&gt;每个Random 实例里面都有一个原子性的种子变量用来记录当前的种子值，当要生成新的随机数时需要根据当前种子计算新的种子并更新回原子变量。在多线程下使用单个Random 实例生成随机数时，当多个线程同时计算随机数来计算新的种子时，多个线程会竞争同一个原子变量的更新操作，由于原子变量的更新是CAS 操作，同时只有一个线程会成功，所以会造成大量线程进行自旋重试， 这会降低并发性能，所以&lt;code&gt;ThreadLocalRandom&lt;/code&gt; 应运而生。&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="http://blog.onebug.tech/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="java" scheme="http://blog.onebug.tech/tags/java/"/>
    
    <category term="笔记" scheme="http://blog.onebug.tech/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="并发" scheme="http://blog.onebug.tech/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="java并发编程之美" scheme="http://blog.onebug.tech/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>java多线程编程基础（二）</title>
    <link href="http://blog.onebug.tech/2021/10/15/java/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://blog.onebug.tech/2021/10/15/java/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2021-10-14T16:00:00.000Z</published>
    <updated>2023-03-23T15:29:42.971Z</updated>
    
    <content type="html"><![CDATA[<h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><p><code>synchronized块</code>是Java 提供的一种原子性内置锁， <code>Java</code> 中的每个对象都可以把它当作一个同步锁来使用， 这些Java 内置的使用者看不到的锁被称为内部锁，也叫作监视器锁。<code>synchronized</code> 关键字底层原理属于 JVM 层面。线程的执行代码在进入<code>synchronized</code> 代码块前会自动获取内部锁，这时候其他线程访问该同步代码块时会被阻塞挂起。拿到内部锁的线程会在正常退出同步代码块或者抛出异常后或者在同步块内调用了该内置锁资源的<code>wait</code> 系列方法时释放该内置锁。内置锁是排它锁，也就是当一个线程获取这个锁后， 其他线程必须等待该线程释放锁后才能获取该锁。</p><span id="more"></span><p>由于Java 中的线程是与操作系统的原生线程一一对应的，所以当阻塞一个线程时，需要从用户态切换到内核态执行阻塞操作，这是很耗时的操作，而<code>synchronized</code>的使用就会导致上下文切换。</p><blockquote><p>庆幸的是，JDK1.6 对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销，所以现在的 <code>synchronized</code> 锁效率也很不错了。</p></blockquote><p><code>synchronized</code> 同时具有内存语义，这个内存语义可以解决共享变量内存可见性问题。进入<code>synchronized</code> 块的内存语义是把在<code>synchronized</code> 块内使用到的变量从线程的工作内存中清除，这样在<code>synchronized</code> 块内使用到该变量时就不会从线程的工作内存中获取，而是<strong>直接从主内存中获取</strong>。退出<code>synchronized</code> 块的内存语义是把在<code>synchronized</code> 块内对共享变量的修改刷新到主内存。</p><h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><p>使用锁的方式可以解决共享变量内存可见性问题，但是使用锁太笨重，因为它会带来线程上下文的切换开销。对于解决内存可见性问题， Java 还提供了一种弱形式的同步，也就是使用<code>volatile</code> 关键字。该关键字可以确保对一个变量的更新对其他线程马上可见。当一个变量被声明为<code>volatile</code> 时，线程在<strong>写入变量</strong>时不会把值缓存在寄存器或者其他地方，而是会把值<strong>刷新回主内存</strong>。当其他线程<strong>读取该共享变量</strong>时，会<strong>从主内存重新获取</strong>最新值，而不是使用当前线程的工作内存中的值。<code>volatile</code> 的内存语义和<code>synchronized</code> 的内存语义有相似之处，具体来说就是，当线程写入了<code>volatile</code> 变量值时就等价于线程退出<code>synchronized</code> 同步块（把写入工作内存的变量值同步到主内存），读取<code>volatile</code> 变量值时就相当于进入同步块（ 先清空本地内存变量值，再从主内存获取最新值）。</p><p><code>volatile</code> 只能保证共享变量的可见性，不能解决<code>读—改一写</code>等的原子性问题。下例中，<code>cnt</code>变量已经使用<code>volatile</code> 修饰，最终结果却不正确。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Unsafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntegerCount</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"><span class="comment">//线程不安全</span></span><br><span class="line">        Thread[] threads=<span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;threads.length;i++)&#123;</span><br><span class="line">            threads[i]=<span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">10000</span>;j++)&#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;cnt:&quot;</span>+cnt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.onebug.tech/image-20211015202422807.png"></p><p>一般来说，volatile适合状态验证，不适合累加值，在修饰状态标记量时，要保证对：</p><ul><li>变量的写操作不依赖于当前值</li><li>该变量没有包含在具有其他变量的式子中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//volatile经典用法</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">boolean</span> asleep</span><br><span class="line">...</span><br><span class="line"><span class="keyword">while</span>(!asleep)&#123;</span><br><span class="line"><span class="comment">//do some work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><p>在Java 中， 锁在并发处理中占据了一席之地，但是使用锁有一个不好的地方，就是当一个线程没有获取到锁时会被阻塞挂起， 这会导致线程上下文的切换和重新调度开销。Java 提供了非阻塞的<code>volatile</code> 关键字来解决共享变量的可见性问题， 这在一定程度上弥补了锁带来的开销问题，但是volatile 只能保证共享变量的可见性，不能解决<code>读—改一写</code>等的原子性问题。CAS 即Compare and Swap ，其是JDK 提供的非阻塞原子性操作， 它通过硬件保证了比较更新操作的原子性。JDK 里面的Unsafe 类提供了一系列的<code>compareAndSwap*</code>方法，例如:</p><ul><li><code>boolean compareAndSwapLong(Object obj ,long valueOffset,long expect, long update）</code>方<br>法： 其中<code>compareAndSwap</code> 的意思是比较并交换。CAS 有四个操作数， 分别为： 对象内存位置、对象中的变量的偏移量、变量预期值和新的值。其操作含义是， 如果对象<code>obj</code> 中内存偏移量为<code>valueOffset</code> 的变量值为<code>expect</code> ，则使用新的值<code>update</code> 替换旧的值<code>expect</code> 。这是处理器提供的一个原子性指令。</li></ul><h1 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h1><p>JDK 的<code>rt.jar</code>包中的<code>Unsafe</code> 类提供了硬件级别的原子性操作， <code>Unsafe</code> 类中的方法都是<code>native</code> 方法，它们使用JNI的方式访问本地C++实现，除了上文提到的<code>compareAndSwap*</code>方法，其中还有几个重要的方法：</p><ul><li><code>long objectFieldOffset(Field field）</code> 方法： 返回指定的变量在所属类中的内存偏移地址，该偏移地址仅仅在该Unsafe 函数中访问指定宇段时使用。</li><li><code>void park(boolean isAbsolute, long time）</code> 方法： 阻塞当前线程</li><li><code>void unpark(Object thread）</code> 方法：唤醒调用<code>park</code>后阻塞的线程。</li></ul><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h2><ul><li><p>悲观锁指对数据被外界修改持保守态度，认为数据很容易就会被其他线程修改，所以在数据被处理前先对数据进行加锁，并在整个数据处理过程中，使数据处于锁定状态。悲观锁的实现往往依靠数据库提供的锁机制，即在数据库中，在对数据记录操作前给记录加排它锁。如果获取锁失败， 则说明数据正在被其他线程修改， 当前线程则等待或者抛出异常。如果获取锁成功，则对记录进行操作，然后提交事务后释放排它锁。</p></li><li><p>乐观锁是相对悲观锁来说的，它认为数据在一般情况下不会造成冲突，所以在访问记录前不会加排它锁，而是在进行数据提交更新时，才会正式对数据冲突与否进行检测。</p></li></ul><h2 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h2><p>根据线程获取锁的抢占机制，锁可以分为公平锁和非公平锁：</p><ul><li>公平锁表示线程获取锁的顺序是按照线程请求锁的时间早晚来决定的，也就是最早请求锁的线程将最早获取到锁。</li><li>非公平锁可以在运行时闯入，也就是先来不一定先得。</li></ul><h2 id="独占锁和共享锁"><a href="#独占锁和共享锁" class="headerlink" title="独占锁和共享锁"></a>独占锁和共享锁</h2><p>根据锁只能被单个线程持有还是能被多个线程共同持有，锁可以分为独占锁和共享锁：</p><ul><li>独占锁保证任何时候都只有一个线程能得到锁， <code>ReentrantLock</code> 就是以独占方式实现的。独占锁是一种悲观锁，由于每次访问资源都先加上互斥锁，这限制了并发性，因为读操作并不会影响数据的一致性，而独占锁只允许在同一时间由一个线程读取数据，其他线程必须等待当前线程释放锁才能进行读取。</li><li>共享锁则可以同时由多个线程持有，例如<code>ReadWriteLock</code> 读写锁，它允许一个资源可以被多线程同时进行读操作。共享锁则是一种乐观锁，它放宽了加锁的条件，允许多个线程同时进行读操作</li></ul><h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><p>当一个线程要获取一个被其他线程持有的独占锁时，该线程会被阻塞，那么当一个线程再次获取它自己己经获取的锁时，如果不被阻塞，那么我们说该锁是可重入的，也就是只要该线程获取了该锁，那么可以无限次数（严格来说是有限次数）地进入被该锁锁住的代码。</p><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>由于Java 中的线程是与操作系统中的线程一一对应的，所以当一个线程在获取锁（比如独占锁）失败后，会被切换到内核状态而被挂起。当该线程获取到锁时又需要将其切换到内核状态而唤醒该线程。而从用户状态切换到内核状态的开销是比较大的，在一定程度上会影响并发性能。自旋锁则是，当前线程在获取锁时，如果发现锁已经被其他线程占有，它不马上阻塞自己，在不放弃CPU 使用权的情况下，多次尝试获取，很有可能在后面几次尝试中其他线程己经释放了锁。如果尝试指定的次数后仍没有获取到锁则当前线程才会被阻塞挂起。由此看来自旋锁是使用CPU 时间换取线程阻塞与调度的开销，但是很有可能这些CPU 时间白白浪费了。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;synchronized&quot;&gt;&lt;a href=&quot;#synchronized&quot; class=&quot;headerlink&quot; title=&quot;synchronized&quot;&gt;&lt;/a&gt;synchronized&lt;/h1&gt;&lt;p&gt;&lt;code&gt;synchronized块&lt;/code&gt;是Java 提供的一种原子性内置锁， &lt;code&gt;Java&lt;/code&gt; 中的每个对象都可以把它当作一个同步锁来使用， 这些Java 内置的使用者看不到的锁被称为内部锁，也叫作监视器锁。&lt;code&gt;synchronized&lt;/code&gt; 关键字底层原理属于 JVM 层面。线程的执行代码在进入&lt;code&gt;synchronized&lt;/code&gt; 代码块前会自动获取内部锁，这时候其他线程访问该同步代码块时会被阻塞挂起。拿到内部锁的线程会在正常退出同步代码块或者抛出异常后或者在同步块内调用了该内置锁资源的&lt;code&gt;wait&lt;/code&gt; 系列方法时释放该内置锁。内置锁是排它锁，也就是当一个线程获取这个锁后， 其他线程必须等待该线程释放锁后才能获取该锁。&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="http://blog.onebug.tech/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="java" scheme="http://blog.onebug.tech/tags/java/"/>
    
    <category term="笔记" scheme="http://blog.onebug.tech/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="并发" scheme="http://blog.onebug.tech/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="java并发编程之美" scheme="http://blog.onebug.tech/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>线程封闭的常用策略--ThreadLocal</title>
    <link href="http://blog.onebug.tech/2021/10/10/java/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/ThreadLocal/"/>
    <id>http://blog.onebug.tech/2021/10/10/java/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/ThreadLocal/</id>
    <published>2021-10-09T16:00:00.000Z</published>
    <updated>2023-03-23T15:29:42.973Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程封闭"><a href="#线程封闭" class="headerlink" title="线程封闭"></a>线程封闭</h1><p>当访问共享变量时，往往需要加锁来保证数据同步。<strong>一种避免使用同步的方式就是不共享数据。如果仅在单线程中访问数据，就不需要同步了，这种技术称为线程封闭。</strong></p><p>线程封闭技术有一个常见的应用，JDBC的Connection对象。Connection对象在实现的时候并没有对线程安全做太多的处理，JDBC的规范里也没有要求Connection对象必须是线程安全的。实际在服务器应用程序中，线程从连接池获取了一个Connection对象，使用完再把Connection对象返回给连接池，由于大多数请求都是由单线程采用同步的方式来处理的，并且在Connection对象返回之前，连接池不会将它分配给其他线程。因此这种连接管理模式处理请求时隐含的将Connection对象封闭在线程里面，这样我们使用的Connection对象虽然本身不是线程安全的，但是它通过线程封闭也做到了线程安全。</p><p>实现线程封闭，一般有三种方法：Ad-hoc 线程封闭、堆栈封闭、<strong>ThreadLocal线程封闭</strong>。</p><span id="more"></span><h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p>ThreadLocal 是JDK 包提供的，它提供了线程本地变量，也就是如果你创建了一个ThreadLocal 变量，那么访问这个变量的每个线程都会有这个变量的一个本地副本。当多个线程操作这个变量时，实际操作的是自己本地内存里面的变量，从而避免了线程安全问题。创建一个ThreadLocal 变量后，每个线程都会复制一个变量到自己的本地内存中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//   一个简单ThreadLocal示例</span></span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;String&gt; localVal=<span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        localVal.set(<span class="string">&quot;main THREAD&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            System.out.println(localVal.get());</span><br><span class="line">            localVal.set(<span class="string">&quot;THREAD 1&quot;</span>);</span><br><span class="line">            System.out.println(localVal.get());</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            localVal.set(<span class="string">&quot;THREAD 2&quot;</span>);</span><br><span class="line">            System.out.println(localVal.get());</span><br><span class="line">        &#125;).start();</span><br><span class="line">        </span><br><span class="line">        localVal.remove();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.onebug.tech/image-20211010191615958.png" alt="image-20211010191615958"></p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p><img src="https://image.onebug.tech/image-20211010191911770.png" alt="image-20211010191911770"></p><p><code>Thread</code> 类中有一个<code>threadLocals</code> 和一个<code>inheritableThreadLocals</code> ， 它们都是<code>ThreadLocalMap</code> 类型的变量， 而<code>ThreadLocalMap</code> 是一个定制化的<code>Hashmap</code> 。其实每个线程的本地变量不是存放在<code>ThreadLocal</code> 实例里面，而是存放在调用线程的<code>threadLocals</code> 变量里面。也就是说， <code>ThreadLocal</code> 类型的本地变量存放在具体的线程内存空间中。而<code>ThreadLocal</code> 就是一个工具壳类，它通过<code>set</code> 方法把<code>value</code> 值放入调用线程的<code>threadLocals</code> 里面并存放起来，当调用线程调用它的get 方法时，再从当前线程的<code>threadLocals</code> 变量里面将其拿出来使用。</p><p><code>ThreadLocal</code>工具类的<code>set</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="comment">//获取当前线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">//获取线程对应的ThreadLocalMap</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">    <span class="comment">// 将this作为key,写入ThreadLocalMap </span></span><br><span class="line">    map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ThreadLocal</code>工具类的<code>get</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">    ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><p>内存泄露与预防：每个线程的本地变量存放在线程自己的内存变量<code>threadLocals</code> 中，如果当前线程一直不消亡， 那么这些本地变量会一直存在， 所以可能会造成内存溢出， 因此使用完毕后要记得调用<code>ThreadLocal</code> 的<code>remove</code> 方法删除对应线程的<code>threadLocals</code> 中的本地变量。</p></li><li><p><code>InheritableThreadLocal</code>：<code>InheritableThreadLocal</code>继承自<code>ThreadLocal</code> ， 其提供了一个特性，就是让子线程可以访问在父线程中设置的本地变量。它的实现原理是当父线程创建子线程时，构造函数会把父线程中<code>inheritableThreadLocals</code> 变量里面的本地变量复制一份保存到子线程的<code>inheritableThreadLocals</code> 变量里面。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;线程封闭&quot;&gt;&lt;a href=&quot;#线程封闭&quot; class=&quot;headerlink&quot; title=&quot;线程封闭&quot;&gt;&lt;/a&gt;线程封闭&lt;/h1&gt;&lt;p&gt;当访问共享变量时，往往需要加锁来保证数据同步。&lt;strong&gt;一种避免使用同步的方式就是不共享数据。如果仅在单线程中访问数据，就不需要同步了，这种技术称为线程封闭。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;线程封闭技术有一个常见的应用，JDBC的Connection对象。Connection对象在实现的时候并没有对线程安全做太多的处理，JDBC的规范里也没有要求Connection对象必须是线程安全的。实际在服务器应用程序中，线程从连接池获取了一个Connection对象，使用完再把Connection对象返回给连接池，由于大多数请求都是由单线程采用同步的方式来处理的，并且在Connection对象返回之前，连接池不会将它分配给其他线程。因此这种连接管理模式处理请求时隐含的将Connection对象封闭在线程里面，这样我们使用的Connection对象虽然本身不是线程安全的，但是它通过线程封闭也做到了线程安全。&lt;/p&gt;
&lt;p&gt;实现线程封闭，一般有三种方法：Ad-hoc 线程封闭、堆栈封闭、&lt;strong&gt;ThreadLocal线程封闭&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="http://blog.onebug.tech/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="java" scheme="http://blog.onebug.tech/tags/java/"/>
    
    <category term="笔记" scheme="http://blog.onebug.tech/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="并发" scheme="http://blog.onebug.tech/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="java并发编程之美" scheme="http://blog.onebug.tech/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>java多线程编程基础（一）</title>
    <link href="http://blog.onebug.tech/2021/10/08/java/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://blog.onebug.tech/2021/10/08/java/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2021-10-07T16:00:00.000Z</published>
    <updated>2023-03-23T15:29:42.964Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h1><p>在讨论什么是线程前有必要先说下什么是进程，因为线程是进程中的一个实体，线程本身是不会独立存在的。进程是代码在数据集合上的一次运行活动， 是系统进行资源分配和调度的基本单位， 线程则是进程的一个执行路径， 一个进程中至少有一个线程，进程中的多个线程共享进程的资源。操作系统在分配资源时是把资源分配给进程的， 但是CPU 资源比较特殊， 它是被分配到线程的， 因为真正要占用C PU 运行的是线程， 所以也说线程是CPU 分配的基本单位。</p><span id="more"></span><h1 id="线程的创建与启动"><a href="#线程的创建与启动" class="headerlink" title="线程的创建与启动"></a>线程的创建与启动</h1><p>Java 中有三种线程创建方式，分别为：</p><h2 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h2><p>实现<code>Runnable</code> 接口的<code>run</code> 方法。使用<code>lambda</code>简化代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123; System.out.println(<span class="string">&quot;Task #1 is running&quot;</span>); &#125;;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br></pre></td></tr></table></figure><h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><p>继承<code>Thread</code> 类并重写<code>run</code> 的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;child thread run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ThreadTest</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><p>使用<code>FutureTask</code> 方式。<code>FutureTask</code>实现了<code>Callable</code>接口，能够获取异步任务的返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建异步任务</span></span><br><span class="line">FutureTask&lt;Integer&gt; futureTask=<span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;task#2: cal 1+2&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+<span class="number">2</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">//启动任务</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待任务执行完毕，并返回结果</span></span><br><span class="line"><span class="type">int</span> result=futureTask.get();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;result is &quot;</span>+result);</span><br></pre></td></tr></table></figure><h1 id="线程通知与等待"><a href="#线程通知与等待" class="headerlink" title="线程通知与等待"></a>线程通知与等待</h1><h2 id="wait-和notify"><a href="#wait-和notify" class="headerlink" title="wait()和notify()"></a>wait()和notify()</h2><p>当一个线程调用一个共享变量的<code>wait()</code>方法时， 该调用线程会被阻塞挂起， 直到发生下面几件事情之一才返回： </p><ul><li>其他线程调用了该共享对象的<code>notify()</code>或者<code>notifyAll()</code>方法；</li><li>其他线程调用了该线程的<code>interrupt()</code>方法， 该线程抛出<code>InterruptedException</code> 异常返回。</li></ul><p>一个线程调用共享对象的notify（）方法后，会唤醒一个在该共享变量上调用<code>wait</code>系列方法后被挂起的线程。一个共享变量上可能会有多个线程在等待，具体唤醒哪个等待的线程是<strong>随机</strong>的。不同于<code>notify()</code>函数只会唤醒一个被阻塞到该共享变量上的线程，<code>notifyAll()</code>方法则会唤醒所有在该共享变量上由于调用<code>wait</code> 系列方法而被挂起的线程。</p><p><code>notify</code>和<code>wait</code>系列方法，都需要当前线程获取到了共享变量的监视器锁后，才可以调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Thread thread1=<span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!prepare)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread()+<span class="string">&quot;阻塞挂起中...&quot;</span>);</span><br><span class="line">                lock.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread()+<span class="string">&quot;被唤醒&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程被中断&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">thread1.start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            prepare=<span class="literal">true</span>;</span><br><span class="line">            System.out.println(Thread.currentThread()+<span class="string">&quot;唤醒其他阻塞挂起的线程&quot;</span>);</span><br><span class="line">            lock.notify();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><p><img src="https://image.onebug.tech/image-20211008205319745.png" alt="image-20211008205319745"></p><blockquote><p>另外需要注意的是，当前线程调用共享变量的<code>wait()</code>方法后只会释放当前共享变量上的锁，如果当前线程还持有其他共享变量的锁，则这些锁是不会被释放的</p></blockquote><h2 id="虚假唤醒"><a href="#虚假唤醒" class="headerlink" title="虚假唤醒"></a>虚假唤醒</h2><p>另外需要注意的是，一个线程可以从挂起状态变为可以运行状态（ 也就是被唤醒）即使该线程没有被其他线程调用<code>notify()</code>、<code>notifyAll()</code>方法进行通知，或者被中断，或者等待超时，这就是所谓的虚假唤醒。<br>虽然虚假唤醒在应用实践中很少发生，但要防患于未然，做法就是不停地去测试该线程被唤醒的条件是否满足，不满足则继续等待，也就是说在一个循环中调用<code>wait()</code>方法进行防范。退出循环的条件是满足了唤醒该线程的条件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">synchronized (obj)&#123;</span><br><span class="line">    while (!prepare)&#123;</span><br><span class="line">        //阻塞挂起</span><br><span class="line">        obj.wait();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="wait超时"><a href="#wait超时" class="headerlink" title="wait超时"></a>wait超时</h2><ul><li><code>wait(long timeout)</code>：该方法相比<code>wait()</code> 方法多了一个超时参数，它的不同之处在于，如果一个线程调用共享对象的该方法挂起后， 没有在指定的timeout ms 时间内被唤醒，那么该函数还是会因为超时而返回。</li></ul><h1 id="线程的其他方法"><a href="#线程的其他方法" class="headerlink" title="线程的其他方法"></a>线程的其他方法</h1><h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><p>在项目实践中经常会遇到一个场景，就是是需要等待某几件事情完成后才能继续往下执行，比如多个线程加载资源， 需要等待多个线程全部加载完毕再汇总处理。Thread 类中有一个简单的<code>join</code> 方法就可以做这个事情。（事实上不太使用该方法，<code>AQS</code>中的<code>CountdownLatch</code>更为强大和常用）</p><h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h2><p>Thread 类中有一个静态的<code>sleep</code>方法，当一个执行中的线程调用了<code>Thread</code> 的<code>sleep</code> 方法后，调用线程会暂时让出指定时间的执行权，也就是在这期间不参与CPU的调度。指定的睡眠时间到了后该函数会正常返回，线程就处于就绪状态，然后参与CPU 的调度，获取到CPU 资源后就可以继续运行了。不同于<code>wait</code>方法，线程在调用<code>sleep</code>方法后，该线程所拥有的监视器资源，比如锁还是持有不让出的。</p><h2 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h2><p>Thread 类中有一个静态的yield 方法，当一个线程调用<code>yield</code>方法时，实际就是在暗示线程调度器当前线程请求让出自己的CPU使用，但是线程调度器可以无条件忽略这个暗示。当一个线程调用<code>yield</code> 方法时， 当前线程会让出CPU使用权，然后处于就绪状态，线程调度器会从线程就绪队列里面获取一个线程优先级最高的线程，当然也有可能会调度到刚刚让出CPU 的那个线程来获取CPU 执行权，这也是<code>yield</code>和<code>sleep</code>不同的地方。</p><h1 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h1><p>Java 中的线程中断是一种线程间的协作模式，通过设置线程的中断标志并不能直接终止该线程的执行， 而是被中断的线程根据中断状态自行处理。</p><ul><li><code>void interrup()</code> 方法： 中断线程， 例如，当线程A 运行时，线程B 可以调用钱程A的<code>interrupt()</code>方法来设置线程A 的中断标志为true 并立即返回。<strong>设置标志仅仅是设置标志， 线程A 实际并没有被中断， 它会继续往下执行</strong>。如果线程A 因为调用了<code>wait</code> 系列函数、<code>join</code> 方法或者<code>sleep</code> 方法而被阻塞挂起，这时候若线程B 调用线程A 的<code>interrupt()</code> 方法，线程A 会在调用这些方法的地方抛出<code>InterruptedException</code> 异常而返回。</li><li><code>boolean isinterrupte()</code> 方法： 检测当前线程是否被中断，如果是返回<code>true</code> ， 否则返回<code>false</code> 。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Thread thread=<span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">float</span> i=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (i&lt;<span class="number">1000</span>) &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//                clean up if required</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        thread.interrupt();</span><br><span class="line">        System.out.println(<span class="string">&quot;中断线程&quot;</span>+thread);</span><br></pre></td></tr></table></figure><p><img src="https://image.onebug.tech/image-20211008212955074.png" alt="image-20211008212955074"></p><p>可以看到，程序没有抛出异常，而是正常执行。</p><h1 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h1><p>死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的互相等待的现象，在无外力作用的情况下，这些线程会一直相互等待而无法继续运行下去。</p><p>死锁的产生必须具备以下四个条件：</p><ul><li>互斥条件： 指线程对己经获取到的资源进行排它性使用， 即该资源同时只由一个线程占用。如果此时还有其他线程请求获取该资源，则请求者只能等待，直至占有资源的线程释放该资源。</li><li>请求并持有条件： 指一个线程己经持有了至少一个资源， 但又提出了新的资源请求，而新资源己被其他线程占有，所以当前线程会被阻塞，但阻塞的同时并不释放自己己经获取的资源。</li><li>不可剥夺条件： 指线程获取到的资源在自己使用完之前不能被其他线程抢占， 只有在自己使用完毕后才由自己释放该资源。</li><li>环路等待条件： 指在发生死锁时， 必然存在一个线程→资源的环形链， 即线程集合{TO , TL T2 ，…， Tn ｝中的TO 正在等待一个Tl 占用的资源， Tl 正在等待T2 占用的资源，……Tn 正在等待己被TO 占用的资源。</li></ul><p>一个线程死锁的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> Object resource1=<span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> Object resource2=<span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Thread threadA=<span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;threadA 尝试获取 resource1中...&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (resource1)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;threadA 获取 resource1成功&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;threadA 尝试获取 resource2中...&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (resource2)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;threadA 获取 resource2成功&quot;</span>);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Thread threadB=<span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;threadB 尝试获取 resource2中...&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (resource2)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;threadB 获取 resource2成功&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;threadB尝试获取 resource1中...&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (resource1)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;threadB 获取 resource1成功&quot;</span>);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.onebug.tech/image-20211008214107190.png" alt="image-20211008214107190"></p><p>如图所示，<code>threadA</code>和<code>threadB</code>形成了线程死锁。</p><p><img src="https://image.onebug.tech/image-20211008213421323.png" alt="image-20211008213421323"></p><p>关于如何避免线程死锁，操作系统中有详细介绍，这里不赘述。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;什么是线程&quot;&gt;&lt;a href=&quot;#什么是线程&quot; class=&quot;headerlink&quot; title=&quot;什么是线程&quot;&gt;&lt;/a&gt;什么是线程&lt;/h1&gt;&lt;p&gt;在讨论什么是线程前有必要先说下什么是进程，因为线程是进程中的一个实体，线程本身是不会独立存在的。进程是代码在数据集合上的一次运行活动， 是系统进行资源分配和调度的基本单位， 线程则是进程的一个执行路径， 一个进程中至少有一个线程，进程中的多个线程共享进程的资源。操作系统在分配资源时是把资源分配给进程的， 但是CPU 资源比较特殊， 它是被分配到线程的， 因为真正要占用C PU 运行的是线程， 所以也说线程是CPU 分配的基本单位。&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="http://blog.onebug.tech/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="java" scheme="http://blog.onebug.tech/tags/java/"/>
    
    <category term="笔记" scheme="http://blog.onebug.tech/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="并发" scheme="http://blog.onebug.tech/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="java并发编程之美" scheme="http://blog.onebug.tech/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>Netty的优化</title>
    <link href="http://blog.onebug.tech/2021/09/30/java/netty/Netty%E4%BC%98%E5%8C%96/"/>
    <id>http://blog.onebug.tech/2021/09/30/java/netty/Netty%E4%BC%98%E5%8C%96/</id>
    <published>2021-09-29T16:00:00.000Z</published>
    <updated>2023-03-23T15:29:42.983Z</updated>
    
    <content type="html"><![CDATA[<h1 id="共享Handler"><a href="#共享Handler" class="headerlink" title="共享Handler"></a>共享Handler</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap</span><br><span class="line">                .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> &#123;</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">Spliter</span>());<span class="comment">//帧解码器</span></span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">PacketDecoder</span>());<span class="comment">//数据包解码器</span></span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">HandlerA</span>());<span class="comment">//业务Handler</span></span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">HandlerB</span>());<span class="comment">//业务Handler</span></span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">HandlerC</span>());<span class="comment">//业务Handler</span></span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">PacketEncoder</span>());<span class="comment">//数据包编码器</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure><p>每次有新连接到来的时候，都会调用 <code>ChannelInitializer</code> 的 <code>initChannel()</code> 方法，然后这里相关的 <code>handler</code> 都会被 <code>new</code> 一次。许多 <code>handler</code>，他们内部都是没有成员变量的，也就是说是无状态的，我们完全可以使用单例模式，即调用 <code>pipeline().addLast()</code> 方法的时候，都直接使用单例，不需要每次都 <code>new</code>，提高效率，也避免了创建很多小的对象。</p><p>单例改造：对于无状态<code>Handler</code>，使用单例模式，多个channel共享一个实例</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 1. 加上注解标识，表明该 handler 是可以多个 channel 共享的</span></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerA</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;APacket&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 构造单例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">HandlerA</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerA</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">HandlerA</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>@ChannelHandler.Sharable</code> 显示地告诉 Netty，这个 handler 是支持多个 channel 共享的，否则会报错。</p></blockquote><h1 id="合并编解码器"><a href="#合并编解码器" class="headerlink" title="合并编解码器"></a>合并编解码器</h1><p>Netty 内部提供了一个类，叫做 <code>MessageToMessageCodec</code>，使用它可以让我们的编解码操作放到一个类里面去实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PacketCodecHandler</span> <span class="keyword">extends</span> <span class="title class_">MessageToMessageCodec</span>&lt;ByteBuf,Packet&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> PacketCodecHandler INSTANCE=<span class="keyword">new</span> <span class="title class_">PacketCodecHandler</span>();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(ChannelHandlerContext ctx, Packet msg, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        out.add(PacketCodeC.DEFAULT.encode(ctx.alloc(),msg));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf msg, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        out.add(PacketCodeC.DEFAULT.decode(msg));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> <code>PacketCodecHandler</code>一般是一个无状态的 <code>handler</code>，因此，同样可以使用单例模式来实现。我们需要实现 <code>MessageToMessageCodec</code>的<code>decode()</code> 和 <code>encode()</code> 方法，<code>decode</code> 是将二进制数据 <code>ByteBuf</code> 转换为 java 对象 <code>Packet</code>，而 <code>encode</code> 操作是一个相反的过程，在 <code>encode()</code> 方法里面，我们需要传入了 <code>channel</code> 的 内存分配器，手工分配了 <code>ByteBuf</code>。</p><h1 id="缩短事件传播路径"><a href="#缩短事件传播路径" class="headerlink" title="缩短事件传播路径"></a>缩短事件传播路径</h1><h2 id="合并平行-handler"><a href="#合并平行-handler" class="headerlink" title="合并平行 handler"></a>合并平行 handler</h2><p>在很多情况下，每次 decode 出来一个指令对象之后，其实只会在一个指令 <code>handler</code> 上进行处理，因此，我们其实可以把这么多的指令 <code>handler</code> 压缩为一个 <code>handler</code>实现路由功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@ChannelHandler.Sharable</span><br><span class="line">public class RouteHandler extends SimpleChannelInboundHandler&lt;Packet&gt; &#123;</span><br><span class="line">    public static final RouteHandler INSTANCE = new RouteHandler();</span><br><span class="line"></span><br><span class="line">    private Map&lt;Byte, SimpleChannelInboundHandler&lt;? extends Packet&gt;&gt; routeMap;</span><br><span class="line"></span><br><span class="line">    private IMHandler() &#123;</span><br><span class="line">        routeMap = new HashMap&lt;Byte, SimpleChannelInboundHandler&lt;? extends Packet&gt;&gt;()&#123;&#123;</span><br><span class="line">            put(CommandA, HandlerA.INSTANCE);</span><br><span class="line">           put(CommandB, HandlerB.INSTANCE);</span><br><span class="line">           put(CommandC, HandlerC.INSTANCE);</span><br><span class="line"></span><br><span class="line">        &#125;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void channelRead0(ChannelHandlerContext ctx, Packet packet) throws Exception &#123;</span><br><span class="line">        routeMap.get(packet.getCommand()).channelRead(ctx, packet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过上述优化方法后，我们的<code>pipeline</code>最终变成这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap</span><br><span class="line">                .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    protected void initChannel(NioSocketChannel ch) &#123;</span><br><span class="line">                        ch.pipeline().addLast(new Spliter());//帧解码器</span><br><span class="line">                        ch.pipeline().addLast(new PacketCodecHandler.INSTANCE());//数据包编解码器</span><br><span class="line">                        ch.pipeline().addLast(RouteHandler.INSTANCE);//路由</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure><blockquote><p>第一个<code>Handler</code>是帧解码器 <code>Spliter</code>，我们是无法使用单例模式进行改造的，因为他内部实现是与每个 <code>channel</code> 有关，每个 <code>Spliter</code> 需要维持每个 channel 当前读到的数据，也就是说他是有状态的。</p></blockquote><h2 id="更改事件传播源"><a href="#更改事件传播源" class="headerlink" title="更改事件传播源"></a>更改事件传播源</h2><p>如果你的 <code>outBound</code> 类型的 <code>handler</code> 较多，在写数据的时候能用 <code>ctx.writeAndFlush()</code> 就用这个方法。</p><p><code>ctx.writeAndFlush()</code> 是从 pipeline 链中的当前节点开始往前找到第一个 outBound 类型的 handler 把对象往前进行传播，如果这个对象确认不需要经过其他 outBound 类型的 handler 处理，就使用这个方法。</p><p><img src="https://image.onebug.tech/1664b767ddcf7711~tplv-t2oaga2asx-watermark.awebp" alt="image.png"></p><p><code>ctx.channel().writeAndFlush()</code> 是从 <code>pipeline</code> 链中的最后一个 <code>outBound</code> 类型的 <code>handler</code> 开始，把对象往前进行传播，如果你确认当前创建的对象需要经过后面的 <code>outBound</code> 类型的 handler，那么就调用此方法。</p><p><img src="https://image.onebug.tech/1664b767de0cf5ea~tplv-t2oaga2asx-watermark.awebp" alt="image.png"></p><h1 id="减少阻塞主线程的操作"><a href="#减少阻塞主线程的操作" class="headerlink" title="减少阻塞主线程的操作"></a>减少阻塞主线程的操作</h1><p>通常我们的应用程序会涉及到数据库或者网络，比如以下这个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, T packet)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. balabala 一些逻辑</span></span><br><span class="line">    <span class="comment">// 2. 数据库或者网络等一些耗时的操作</span></span><br><span class="line">    <span class="comment">// 3. writeAndFlush()</span></span><br><span class="line">    <span class="comment">// 4. balabala 其他的逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于Netty是基于事件驱动的异步网络框架，一个 <code>handler</code> 中的 <code>channelRead0()</code> 方法阻塞了 NIO 线程，最终都会拖慢绑定在该 NIO 线程上的其他所有的 <code>channel</code>。对于耗时的操作，我们需要把这些耗时的操作丢到我们的业务线程池或利用消息队列中去处理，这样，就可以避免一些耗时的操作影响 Netty 的 NIO 线程，从而影响其他的 <code>channel</code>。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;共享Handler&quot;&gt;&lt;a href=&quot;#共享Handler&quot; class=&quot;headerlink&quot; title=&quot;共享Handler&quot;&gt;&lt;/a&gt;共享Handler&lt;/h1&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;serverBootstrap&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                .childHandler(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;ChannelInitializer&lt;/span&gt;&amp;lt;NioSocketChannel&amp;gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;initChannel&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(NioSocketChannel ch)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        ch.pipeline().addLast(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;Spliter&lt;/span&gt;());&lt;span class=&quot;comment&quot;&gt;//帧解码器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        ch.pipeline().addLast(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;PacketDecoder&lt;/span&gt;());&lt;span class=&quot;comment&quot;&gt;//数据包解码器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        ch.pipeline().addLast(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;HandlerA&lt;/span&gt;());&lt;span class=&quot;comment&quot;&gt;//业务Handler&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        ch.pipeline().addLast(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;HandlerB&lt;/span&gt;());&lt;span class=&quot;comment&quot;&gt;//业务Handler&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        ch.pipeline().addLast(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;HandlerC&lt;/span&gt;());&lt;span class=&quot;comment&quot;&gt;//业务Handler&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        ch.pipeline().addLast(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;PacketEncoder&lt;/span&gt;());&lt;span class=&quot;comment&quot;&gt;//数据包编码器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;每次有新连接到来的时候，都会调用 &lt;code&gt;ChannelInitializer&lt;/code&gt; 的 &lt;code&gt;initChannel()&lt;/code&gt; 方法，然后这里相关的 &lt;code&gt;handler&lt;/code&gt; 都会被 &lt;code&gt;new&lt;/code&gt; 一次。许多 &lt;code&gt;handler&lt;/code&gt;，他们内部都是没有成员变量的，也就是说是无状态的，我们完全可以使用单例模式，即调用 &lt;code&gt;pipeline().addLast()&lt;/code&gt; 方法的时候，都直接使用单例，不需要每次都 &lt;code&gt;new&lt;/code&gt;，提高效率，也避免了创建很多小的对象。&lt;/p&gt;
&lt;p&gt;单例改造：对于无状态&lt;code&gt;Handler&lt;/code&gt;，使用单例模式，多个channel共享一个实例&lt;/p&gt;</summary>
    
    
    
    <category term="netty" scheme="http://blog.onebug.tech/categories/netty/"/>
    
    
    <category term="java" scheme="http://blog.onebug.tech/tags/java/"/>
    
    <category term="netty" scheme="http://blog.onebug.tech/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>心跳与空闲检测</title>
    <link href="http://blog.onebug.tech/2021/09/30/java/netty/%E5%BF%83%E8%B7%B3%E4%B8%8E%E7%A9%BA%E9%97%B2%E6%A3%80%E6%B5%8B/"/>
    <id>http://blog.onebug.tech/2021/09/30/java/netty/%E5%BF%83%E8%B7%B3%E4%B8%8E%E7%A9%BA%E9%97%B2%E6%A3%80%E6%B5%8B/</id>
    <published>2021-09-29T16:00:00.000Z</published>
    <updated>2023-03-23T15:29:42.992Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-网络问题"><a href="#1-网络问题" class="headerlink" title="1. 网络问题"></a>1. 网络问题</h2><p>下图是网络应用程序普遍会遇到的一个问题：连接假死</p><p><img src="https://image.onebug.tech/1664c39eb393e946~tplv-t2oaga2asx-watermark.awebp" alt="image.png"></p><p>连接假死的现象是：在某一端（服务端或者客户端）看来，底层的 TCP 连接已经断开了，但是应用程序并没有捕获到，因此会认为这条连接仍然是存在的，从 TCP 层面来说，只有收到四次握手数据包或者一个 RST 数据包，连接的状态才表示已断开。</p><p>连接假死会带来以下两大问题</p><span id="more"></span><ol><li>对于服务端来说，因为每条连接都会耗费 cpu 和内存资源，大量假死的连接会逐渐耗光服务器的资源，最终导致性能逐渐下降，程序奔溃。</li><li>对于客户端来说，连接假死会造成发送数据超时，影响用户体验。</li></ol><p>通常，连接假死由以下几个原因造成的</p><ol><li>应用程序出现线程堵塞，无法进行数据的读写。</li><li>客户端或者服务端网络相关的设备出现故障，比如网卡，机房故障。</li><li>公网丢包。公网环境相对内网而言，非常容易出现丢包，网络抖动等现象，如果在一段时间内用户接入的网络连续出现丢包现象，那么对客户端来说数据一直发送不出去，而服务端也是一直收不到客户端来的数据，连接就一直耗着。</li></ol><p>如果我们的应用是面向用户的，那么公网丢包这个问题出现的概率是非常大的。对于内网来说，内网丢包，抖动也是会有一定的概率发生。一旦出现此类问题，客户端和服务端都会受到影响，接下来，我们分别从服务端和客户端的角度来解决连接假死的问题。</p><h2 id="2-服务端空闲检测"><a href="#2-服务端空闲检测" class="headerlink" title="2. 服务端空闲检测"></a>2. 服务端空闲检测</h2><p>对于服务端来说，客户端的连接如果出现假死，那么服务端将无法收到客户端的数据，也就是说，如果能一直收到客户端发来的数据，那么可以说明这条连接还是活的，因此，服务端对于连接假死的应对策略就是空闲检测。</p><p>何为空闲检测？空闲检测指的是每隔一段时间，检测这段时间内是否有数据读写，简化一下，我们的服务端只需要检测一段时间内，是否收到过客户端发来的数据即可，Netty 自带的 <code>IdleStateHandler</code> 就可以实现这个功能。</p><p>接下来，我们写一个类继承自 <code>IdleStateHandler</code>，来定义检测到假死连接之后的逻辑。</p><blockquote><p>IMIdleStateHandler.java</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class IMIdleStateHandler extends IdleStateHandler &#123;</span><br><span class="line"></span><br><span class="line">    private static final int READER_IDLE_TIME = 15;</span><br><span class="line"></span><br><span class="line">    public IMIdleStateHandler() &#123;</span><br><span class="line">        super(READER_IDLE_TIME, 0, 0, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void channelIdle(ChannelHandlerContext ctx, IdleStateEvent evt) &#123;</span><br><span class="line">        System.out.println(READER_IDLE_TIME + &quot;秒内未读到数据，关闭连接&quot;);</span><br><span class="line">        ctx.channel().close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先，我们观察一下 <code>IMIdleStateHandler</code> 的构造函数，他调用父类 <code>IdleStateHandler</code> 的构造函数，有四个参数，其中第一个表示读空闲时间，指的是在这段时间内如果没有数据读到，就表示连接假死；第二个是写空闲时间，指的是 在这段时间如果没有写数据，就表示连接假死；第三个参数是读写空闲时间，表示在这段时间内如果没有产生数据读或者写，就表示连接假死。写空闲和读写空闲为0，表示我们不关心者两类条件；最后一个参数表示时间单位。在我们的例子中，表示的是：如果 15 秒内没有读到数据，就表示连接假死。</li><li>连接假死之后会回调 <code>channelIdle()</code> 方法，我们这个方法里面打印消息，并手动关闭连接。</li></ol><p>接下来，我们把这个 handler 插入到服务端 pipeline 的最前面</p><blockquote><p>NettyServer.java</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap</span><br><span class="line">        .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">            protected void initChannel(NioSocketChannel ch) &#123;</span><br><span class="line">                // 空闲检测</span><br><span class="line">                ch.pipeline().addLast(new IMIdleStateHandler());</span><br><span class="line">                ch.pipeline().addLast(new Spliter());</span><br><span class="line">                // ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>为什么要插入到最前面？是因为如果插入到最后面的话，如果这条连接读到了数据，但是在 inBound 传播的过程中出错了或者数据处理完完毕就不往后传递了（我们的应用程序属于这类），那么最终 <code>IMIdleStateHandler</code> 就不会读到数据，最终导致误判。</p><p>服务端的空闲检测时间完毕之后，接下来我们再思考一下，在一段时间之内没有读到客户端的数据，是否一定能判断连接假死呢？并不能，如果在这段时间之内客户端确实是没有发送数据过来，但是连接是 ok 的，那么这个时候服务端也是不能关闭这条连接的，为了防止服务端误判，我们还需要在客户端做点什么。</p><h2 id="3-客户端定时发心跳"><a href="#3-客户端定时发心跳" class="headerlink" title="3. 客户端定时发心跳"></a>3. 客户端定时发心跳</h2><p>服务端在一段时间内没有收到客户端的数据，这个现象产生的原因可以分为以下两种：</p><ol><li>连接假死。</li><li>非假死状态下确实没有发送数据。</li></ol><p>我们只需要排除掉第二种可能性，那么连接自然就是假死的。要排查第二种情况，我们可以在客户端定期发送数据到服务端，通常这个数据包称为心跳数据包，接下来，我们定义一个 handler，定期发送心跳给服务端</p><blockquote><p>HeartBeatTimerHandler.java</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class HeartBeatTimerHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    private static final int HEARTBEAT_INTERVAL = 5;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        scheduleSendHeartBeat(ctx);</span><br><span class="line"></span><br><span class="line">        super.channelActive(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void scheduleSendHeartBeat(ChannelHandlerContext ctx) &#123;</span><br><span class="line">        ctx.executor().schedule(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            if (ctx.channel().isActive()) &#123;</span><br><span class="line">                ctx.writeAndFlush(new HeartBeatRequestPacket());</span><br><span class="line">                scheduleSendHeartBeat(ctx);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;, HEARTBEAT_INTERVAL, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ctx.executor()</code> 返回的是当前的 channel 绑定的 NIO 线程，不理解没关系，只要记住就行，然后，NIO 线程有一个方法，<code>schedule()</code>，类似 jdk 的延时任务机制，可以隔一段时间之后执行一个任务，而我们这边是实现了每隔 5 秒，向服务端发送一个心跳数据包，这个时间段通常要比服务端的空闲检测时间的一半要短一些，我们这里直接定义为空闲检测时间的三分之一，主要是为了排除公网偶发的秒级抖动。</p><p>实际在生产环境中，我们的发送心跳间隔时间和空闲检测时间可以略长一些，可以设置为几分钟级别，具体应用可以具体对待，没有强制的规定。</p><p>我们上面其实解决了服务端的空闲检测问题，服务端这个时候是能够在一定时间段之内关掉假死的连接，释放连接的资源了，但是对于客户端来说，我们也需要检测到假死的连接。</p><h2 id="4-服务端回复心跳与客户端空闲检测"><a href="#4-服务端回复心跳与客户端空闲检测" class="headerlink" title="4. 服务端回复心跳与客户端空闲检测"></a>4. 服务端回复心跳与客户端空闲检测</h2><p>客户端的空闲检测其实和服务端一样，依旧是在客户端 pipeline 的最前方插入 <code>IMIdleStateHandler</code></p><blockquote><p>NettyClient.java</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bootstrap</span><br><span class="line">        .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">            public void initChannel(SocketChannel ch) &#123;</span><br><span class="line">                // 空闲检测</span><br><span class="line">                ch.pipeline().addLast(new IMIdleStateHandler());</span><br><span class="line">                ch.pipeline().addLast(new Spliter());</span><br><span class="line">                // ...</span><br></pre></td></tr></table></figure><p>然后为了排除是否是因为服务端在非假死状态下确实没有发送数据，服务端也要定期发送心跳给客户端。</p><p>而其实在前面我们已经实现了客户端向服务端定期发送心跳，服务端这边其实只要在收到心跳之后回复客户端，给客户端发送一个心跳响应包即可。如果在一段时间之内客户端没有收到服务端发来的数据，也可以判定这条连接为假死状态。</p><p>因此，服务端的 pipeline 中需要再加上如下一个 handler - <code>HeartBeatRequestHandler</code>，由于这个 handler 的处理其实是无需登录的，所以，我们将该 handler 放置在 <code>AuthHandler</code> 前面</p><blockquote><p>NettyServer.java</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap</span><br><span class="line">                ch.pipeline().addLast(new IMIdleStateHandler());</span><br><span class="line">                ch.pipeline().addLast(new Spliter());</span><br><span class="line">                ch.pipeline().addLast(PacketCodecHandler.INSTANCE);</span><br><span class="line">                ch.pipeline().addLast(LoginRequestHandler.INSTANCE);</span><br><span class="line">                // 加在这里</span><br><span class="line">                ch.pipeline().addLast(HeartBeatRequestHandler.INSTANCE);</span><br><span class="line">                ch.pipeline().addLast(AuthHandler.INSTANCE);</span><br><span class="line">                ch.pipeline().addLast(IMHandler.INSTANCE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p><code>HeartBeatRequestHandler</code> 相应的实现为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@ChannelHandler.Sharable</span><br><span class="line">public class HeartBeatRequestHandler extends SimpleChannelInboundHandler&lt;HeartBeatRequestPacket&gt; &#123;</span><br><span class="line">    public static final HeartBeatRequestHandler INSTANCE = new HeartBeatRequestHandler();</span><br><span class="line"></span><br><span class="line">    private HeartBeatRequestHandler() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void channelRead0(ChannelHandlerContext ctx, HeartBeatRequestPacket requestPacket) &#123;</span><br><span class="line">        ctx.writeAndFlush(new HeartBeatResponsePacket());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现非常简单，只是简单地回复一个 <code>HeartBeatResponsePacket</code> 数据包。客户端在检测到假死连接之后，断开连接，然后可以有一定的策略去重连，重新登录等等，这里就不展开了，留给读者自行实现。</p><p>关于心跳与健康检测相关的内容就讲解到这里，原理理解清楚了并不难实现，最后，我们来对本小节内容做一下总结。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><ol><li>我们首先讨论了连接假死相关的现象以及产生的原因。</li><li>要处理假死问题首先我们要实现客户端与服务端定期发送心跳，在这里，其实服务端只需要对客户端的定时心跳包进行回复。</li><li>客户端与服务端如果都需要检测假死，那么直接在 pipeline 的最前方插入一个自定义 <code>IdleStateHandler</code>，在 <code>channelIdle()</code> 方法里面自定义连接假死之后的逻辑。</li><li>通常空闲检测时间要比发送心跳的时间的两倍要长一些，这也是为了排除偶发的公网抖动，防止误判。</li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-网络问题&quot;&gt;&lt;a href=&quot;#1-网络问题&quot; class=&quot;headerlink&quot; title=&quot;1. 网络问题&quot;&gt;&lt;/a&gt;1. 网络问题&lt;/h2&gt;&lt;p&gt;下图是网络应用程序普遍会遇到的一个问题：连接假死&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://image.onebug.tech/1664c39eb393e946~tplv-t2oaga2asx-watermark.awebp&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;连接假死的现象是：在某一端（服务端或者客户端）看来，底层的 TCP 连接已经断开了，但是应用程序并没有捕获到，因此会认为这条连接仍然是存在的，从 TCP 层面来说，只有收到四次握手数据包或者一个 RST 数据包，连接的状态才表示已断开。&lt;/p&gt;
&lt;p&gt;连接假死会带来以下两大问题&lt;/p&gt;</summary>
    
    
    
    <category term="netty" scheme="http://blog.onebug.tech/categories/netty/"/>
    
    
    <category term="java" scheme="http://blog.onebug.tech/tags/java/"/>
    
    <category term="netty" scheme="http://blog.onebug.tech/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>TCP的拆包和粘包</title>
    <link href="http://blog.onebug.tech/2021/09/06/java/netty/%E6%8B%86%E5%8C%85%E4%B8%8E%E7%B2%98%E5%8C%85/"/>
    <id>http://blog.onebug.tech/2021/09/06/java/netty/%E6%8B%86%E5%8C%85%E4%B8%8E%E7%B2%98%E5%8C%85/</id>
    <published>2021-09-05T16:00:00.000Z</published>
    <updated>2023-03-23T15:29:42.993Z</updated>
    
    <content type="html"><![CDATA[<h1 id="粘包、半包"><a href="#粘包、半包" class="headerlink" title="粘包、半包"></a>粘包、半包</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在网络传输中，粘包和半包应该是最常出现的问题。</p><p>TCP 传输中，客户端发送数据，实际是把数据写入到了 TCP 的缓存中，粘包和半包也就会在此时产生。</p><p>客户端给服务端发送了两条消息<code>ABC</code>和<code>DEF</code>，服务端这边的接收会有多少种情况呢？有可能是一次性收到了所有的消息<code>ABCDEF</code>，有可能是收到了三条消息<code>AB</code>、<code>CD</code>、<code>EF</code>。</p><p>上面所说的一次性收到了所有的消息<code>ABCDEF</code>，类似于粘包。如果客户端发送的包的大小比 TCP 的缓存容量小，并且 TCP 缓存可以存放多个包，那么客户端和服务端的一次通信就可能传递了多个包，这时候服务端从 TCP 缓存就可能一下读取了多个包，这种现象就叫<code>粘包</code>。</p><p>上面说的后面那种收到了三条消息<code>AB</code>、<code>CD</code>、<code>EF</code>，类似于半包。如果客户端发送的包的大小比 TCP 的缓存容量大，那么这个数据包就会被分成多个包，通过 Socket 多次发送到服务端，服务端第一次从接受缓存里面获取的数据，实际是整个包的一部分，这时候就产生了<code>半包</code>(半包不是说只收到了全包的一半，是说收到了全包的一部分)。</p><span id="more"></span><h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><p>因为TCP是面向连接的传输协议，TCP传输的数据是以流的形式，而流数据是没有明确的开始结尾边界，所以TCP也没办法判断哪一段流属于一个消息。</p><p><img src="https://image.onebug.tech/1460000021175323" alt="TCP协议传输过程.jpg"></p><p>因为TCP会根据缓冲区的实际情况进行包的划分，在业务上认为，有的包被拆分成多个包进行发送，也可能多个晓小的包封装成一个大的包发送，这就是TCP的粘包或者拆包。</p><p><img src="https://image.onebug.tech/1460000021175317" alt="粘包拆包图解.png"></p><p>假设客户端分别发送了两个数据包D1和D2给服务端，由于服务端一次读取到字节数是不确定的，故可能存在以下几种情况：</p><ol><li>服务端分两次读取到两个独立的数据包，分别是D1和D2，没有粘包和拆包。</li><li>服务端一次接收到了两个数据包，D1和D2粘在一起，发生粘包。</li><li>服务端分两次读取到数据包，第一次读取到了完整的D1包和D2包的部分内容，第二次读取到了D2包的剩余内容，发生拆包。</li><li>服务端分两次读取到数据包，第一次读取到部分D1包，第二次读取到剩余的D1包和全部的D2包。</li></ol><p>当TCP缓存再小一点的话，会把D1和D2分别拆成多个包发送。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>解决半包粘包的问题其实就是定义消息边界的问题。因为TCP只负责数据发送，并不处理业务上的数据，所以只能在上层应用协议栈解决，目前的解决方案归纳：</p><ol><li>消息定长，每个报文的大小固定，如果数据不够，空位补空格。</li><li>在包的尾部加回车换行符标识。</li><li>将消息分为消息头与消息体，消息头中包含消息总长度。</li><li>设计更复杂的协议。</li></ol><h1 id="Netty解决方案"><a href="#Netty解决方案" class="headerlink" title="Netty解决方案"></a>Netty解决方案</h1><h2 id="LineBasedFrameDecoder"><a href="#LineBasedFrameDecoder" class="headerlink" title="LineBasedFrameDecoder"></a>LineBasedFrameDecoder</h2><p>基于回车换行符的解码器，当遇到”n”或者 “rn”结束符时，分为一组。支持携带结束符或者不带结束符两种编码方式，也支持配置单行的最大长度。</p><h2 id="DelimiterBasedFrameDecoder"><a href="#DelimiterBasedFrameDecoder" class="headerlink" title="DelimiterBasedFrameDecoder"></a>DelimiterBasedFrameDecoder</h2><p>分隔符解码器，可以指定消息结束的分隔符，它可以自动完成以分隔符作为码流结束标识的消息的解码。回车换行解码器实际上是一种特殊的DelimiterBasedFrameDecoder解码器。</p><h2 id="FixedLengthFrameDecoder"><a href="#FixedLengthFrameDecoder" class="headerlink" title="FixedLengthFrameDecoder"></a>FixedLengthFrameDecoder</h2><p>固定长度解码器，它能够按照指定的长度对消息进行自动解码,当制定的长度过大，消息过短时会有资源浪费，但是使用起来简单。</p><h2 id="LengthFieldBasedFrameDecoder"><a href="#LengthFieldBasedFrameDecoder" class="headerlink" title="LengthFieldBasedFrameDecoder"></a>LengthFieldBasedFrameDecoder</h2><p>通用解码器，一般协议头中带有长度字段，通过使用LengthFieldBasedFrameDecoder传入特定的参数，来解决拆包粘包。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;粘包、半包&quot;&gt;&lt;a href=&quot;#粘包、半包&quot; class=&quot;headerlink&quot; title=&quot;粘包、半包&quot;&gt;&lt;/a&gt;粘包、半包&lt;/h1&gt;&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;在网络传输中，粘包和半包应该是最常出现的问题。&lt;/p&gt;
&lt;p&gt;TCP 传输中，客户端发送数据，实际是把数据写入到了 TCP 的缓存中，粘包和半包也就会在此时产生。&lt;/p&gt;
&lt;p&gt;客户端给服务端发送了两条消息&lt;code&gt;ABC&lt;/code&gt;和&lt;code&gt;DEF&lt;/code&gt;，服务端这边的接收会有多少种情况呢？有可能是一次性收到了所有的消息&lt;code&gt;ABCDEF&lt;/code&gt;，有可能是收到了三条消息&lt;code&gt;AB&lt;/code&gt;、&lt;code&gt;CD&lt;/code&gt;、&lt;code&gt;EF&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;上面所说的一次性收到了所有的消息&lt;code&gt;ABCDEF&lt;/code&gt;，类似于粘包。如果客户端发送的包的大小比 TCP 的缓存容量小，并且 TCP 缓存可以存放多个包，那么客户端和服务端的一次通信就可能传递了多个包，这时候服务端从 TCP 缓存就可能一下读取了多个包，这种现象就叫&lt;code&gt;粘包&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;上面说的后面那种收到了三条消息&lt;code&gt;AB&lt;/code&gt;、&lt;code&gt;CD&lt;/code&gt;、&lt;code&gt;EF&lt;/code&gt;，类似于半包。如果客户端发送的包的大小比 TCP 的缓存容量大，那么这个数据包就会被分成多个包，通过 Socket 多次发送到服务端，服务端第一次从接受缓存里面获取的数据，实际是整个包的一部分，这时候就产生了&lt;code&gt;半包&lt;/code&gt;(半包不是说只收到了全包的一半，是说收到了全包的一部分)。&lt;/p&gt;</summary>
    
    
    
    <category term="netty" scheme="http://blog.onebug.tech/categories/netty/"/>
    
    
    <category term="java" scheme="http://blog.onebug.tech/tags/java/"/>
    
    <category term="netty" scheme="http://blog.onebug.tech/tags/netty/"/>
    
  </entry>
  
</feed>
