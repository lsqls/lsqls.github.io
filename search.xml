<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ROS的基础——DDS</title>
    <url>/2022/02/01/ROS/DDS/</url>
    <content><![CDATA[<p>DDS（数据分发服务）是一套通信协议和API标准，以数据为中心是他的特点，它基于发布-订阅模型进行设计。而FastRTPS是<em>eProsima</em>公司对DDS的一个开源实现。DDS是一套中间件，提供介于操作系统和应用程序之间的功能，提供了低延迟、高可靠的通信以及可扩展的架构。DDS其实分为两部分，一部分是DDS规范，一部份则是DDSI-RTPS协议，是一个互操作性协议，也就是真正实现通讯机制的部分，在ROS2中，也正是这部分，取代了ROS1的TCPROS和UDPROS。</p>
<span id="more"></span>

<blockquote>
<p>所谓互操作性协议，就是为了满足互操作性而产生的一个协议，互操作性就是指两个实体的通信能力，如果两个实体之间能够在任何情况下都无误解的进行通信，那么我们就说这两个实体可以正确的互操作。</p>
</blockquote>
<p>DDS的架构是这个样子的：</p>
<p><img src="http://image.onebug.tech/202202241359562.svg+xml" alt="../../_images/library_overview.svg"></p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><strong>DDS实现的数据共享可以理解成一个抽象的全局数据空间，任何应用程序，不论开发语言，或者运行的操作系统类型，都可以通过相同的方式访问这个全局数据空间，就好像访问本地的存储空间一样。</strong>当然全局数据空间仅仅是一个抽象的概念，在实现时仍然是分别存储在每个应用程序的本地空间当中。在系统运行时，数据是按需传输或存储的，数据的发布者仅仅发送对方需要的数据，而订阅者仅接收并存储本地应用程序当前需要的数据。</p>
<p><strong>DDS还提供了非常灵活的QoS策略</strong>，以满足用户对数据共享方式的不同需求，比如可靠性，故障处理等等。针对数据安全性要求比较高的系统，<strong>DDS还提供了细颗粒度的数据安全控制</strong>，包括应用程序身份认证，权限控制，数据加密等等。</p>
<p><strong>DDS提供了对数据发布者和订阅者的动态发现机制</strong>，这意味着用户不必去配置通信节点的地址或其他属性信息，因为他们在运行的过程中会自动发现对方，并自动完成相关配置，即实现了即插即用。</p>
<h1 id="专业名词"><a href="#专业名词" class="headerlink" title="专业名词"></a>专业名词</h1><ul>
<li><strong>Domain：</strong>代表一个通信平面，由Domain ID唯一标识，只有在同一个域内的通信实体才可以通信；如果考虑车内通信，可以只划分1个Domain，也可以按照交互规则或其他规则，定义多个Domain；</li>
<li><strong>Domain Participant：</strong>代表域内通信的应用程序的本地成员身份，简单来说，就是说明同一数据域内的通信成员；</li>
<li><strong>Topic：</strong>是数据的抽象概念，由TopicName标识，关联相应数据的数据类型(DataType)，如果把车内所涉及的所有Topic集合在一起，这样就形成一个虚拟的全局数据空间“Global Data Space”，进一步弱化了节点的概念，所以域参与者已经不是节点的概念了；</li>
<li><strong>DataWriter：</strong>数据写入者，类似缓存，把需要发布的主题数据从应用层写入到DataWriter中；</li>
<li><strong>DataReader：</strong>数据读取者，同样可以理解为一种缓存，从订阅者得到主题数据，随之传给应用层；</li>
<li><strong>Publisher：</strong>发布者，发布主题数据，至少与1个DataWriter关联，通过调用DataWriter的相关函数将数据发出去；</li>
<li><strong>Subscriber：</strong>订阅者，订阅主题数据，至少与1个DataReader关联。当数据到达时，应用程序可能忙于执行其他操作或应用程序只是等待该消息时，这样就会存在两种情况，同步访问和异步通知。</li>
</ul>
<h1 id="DPSC模型"><a href="#DPSC模型" class="headerlink" title="DPSC模型"></a>DPSC模型</h1><p><strong>DCPS（Data-Centric Publish-Subscribe）是DDS标准中定义的以数据为中心的订阅-发布模型。在这个模型中，向全局数据空间写入数据的一方称为Publishers和DataWriter，同样地，在全局数据空间中读取数据的一方称为Subscriber和DataReader</strong>。下图中展示了它们之间的逻辑关系。除了DCPS模型，DDS标准中还定义了一套完整的应用程序接口（API），该接口标准是与平台无关的，这意味着不论应用程序使用什么开发语言，或运行在什么平台之上，只要DDS中间件的实现符合DDS标准，那么相关的应用程序即可实现不同平台间的移植。</p>
<p><img src="http://image.onebug.tech/20220225121143.svg+xml" alt="../../_images/rtps_domain.svg"></p>
<p>数据的发送过程，简单来说就是应用程序调用DataWriter对象提供的write方法，把数据传递给Publisher对象，而Publisher负责将数据在网络上发送出去。</p>
<blockquote>
<p>一个DataWriter只能从属一个Publisher，而Publisher可以拥有多个DataWriter，每一个DataWriter都绑定一个Topic。</p>
</blockquote>
<p>数据的接收过程，简单来说就是Subscriber负责从网络上接收数据，并把它存储在对应的DataReader中。</p>
<blockquote>
<p>一个DataReader只能从属一个Subscriber，而Subscriber可以拥有多个DataReader，每一个DataReader都绑定一个Topic。</p>
</blockquote>
<h1 id="Qos策略"><a href="#Qos策略" class="headerlink" title="Qos策略"></a>Qos策略</h1><p><strong>用户可以通过设置QoS策略来控制数据在应用程序之间共享的方式</strong>，每个DCPS实体，包括Topic，DataWriter，Publisher，DataReader，Subscriber等，都能够独立配置相应的QoS策略。</p>
<p>下面是几种常用的QoS策略（略）：</p>
<ul>
<li>DEADLINE(Topic周期更新)</li>
<li>LIFESPAN（DataWriter写入的数据样本具有到期时间）</li>
<li>HISTORY（DataWriter保存并发送旧的采样数据）</li>
<li>RELIABILITY（”可靠传输”）</li>
</ul>
<p><img src="http://image.onebug.tech/202203062318832.jpeg" alt="img"></p>
<h1 id="RTSP协议"><a href="#RTSP协议" class="headerlink" title="RTSP协议"></a>RTSP协议</h1><p>DDS的标准中并不包含传输层协议，RTPS（Real-Time Publish Subscribe）能够很好的契合DDS协议特点。<strong>RTPS基于多播、无连接的传输模型，这个模型可以映射到不同的传输协议上，如UDP&#x2F;IP（这也是目前RTPS标准中唯一被标准化的传输协议）。</strong></p>
<p><img src="http://image.onebug.tech/202203062318265.svg+xml" alt="../../_images/transport_comparison.svg"></p>
<blockquote>
<p>组播的原理：组播IP地址到底是谁的IP？？ - 车小胖的回答 - 知乎 <a href="https://www.zhihu.com/question/27233903/answer/108374395">https://www.zhihu.com/question/27233903/answer/108374395</a></p>
</blockquote>
<p><img src="http://image.onebug.tech/202203062318554.svg+xml" alt="../_images/DDS_concept.svg"></p>
]]></content>
      <categories>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>dds</tag>
        <tag>ros</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS2备忘录</title>
    <url>/2022/02/13/ROS/ROS2/</url>
    <content><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>ubuntu 20.04</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install ros-rolling-desktop</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a href="http://docs.ros.org/en/rolling/Installation/Ubuntu-Install-Debians.html#">http://docs.ros.org/en/rolling/Installation/Ubuntu-Install-Debians.html#</a></p>
</blockquote>
<span id="more"></span>

<h1 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h1><ul>
<li>“workspace”是一个ROS术语，表示在系统上使用ROS2进行开发的位置。</li>
<li>核心ROS工作区被称为”underlay“，本地ROS工作区称为 ”overlays“</li>
</ul>
<p>环境设置脚本自启动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;source /opt/ros/rolling/setup.bash&quot; &gt;&gt; ~/.bashrc</span><br><span class="line">printenv | grep -i ROS</span><br></pre></td></tr></table></figure>

<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><p>ROS图（ROS graph）是一个由ROS 2元素组成的网络，在同一时间一起处理数据。图中包括所有的可执行文件和它们之间的联系。</p>
<p>ROS中的每个节点（ROS Node）应该只负责单一模块化的用途（例如，一个节点负责控制车轮马达，一个节点负责控制激光测距仪等等）。每个节点可以通过主题（topics）、服务（services）、行动（actions）或参数（parameters）向其他节点发送和接收数据。</p>
<p><img src="http://image.onebug.tech/202203062319650.gif" alt="../_images/Nodes-TopicandService.gif"></p>
<p>一个完整的机器人系统由许多协同工作的节点组成。在ROS2中，单个可执行文件（C++程序、Python程序等）可以包含一个或多个节点。</p>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><ul>
<li><p><code>ros2 run &lt;package_name&gt; &lt;executable_name&gt;</code>：从包启动可执行文件。</p>
</li>
<li><p><code>ros2 node list</code>：显示所有运行节点的名称，当您想要与一个节点交互时，或者当您的系统运行许多节点并且需要跟踪它们时，这尤其有用。</p>
</li>
<li><p>使用<code>Remapping</code>可以指定节点属性（如节点名称、主题名称、服务名称等）</p>
<p>例：<code>ros2 run turtlesim turtlesim_node --ros-args --remap __node:=my_turtle</code></p>
</li>
<li><p><code>ros2 node info &lt;node_name&gt;</code>  ：知道了节点的名称，可以通过该命令访问有关节点的更多信息</p>
</li>
</ul>
<h2 id="Topics"><a href="#Topics" class="headerlink" title="Topics"></a>Topics</h2><p>ROS2将复杂系统分解为许多模块化节点。主题（Topics）是ROS图的一个重要元素，充当节点交换消息的总线。</p>
<p><img src="http://image.onebug.tech/202203062319555.gif" alt="../../_images/Topic-SinglePublisherandSingleSubscriber.gif"></p>
<p>节点可以将数据发布到任意数量的主题，同时可以订阅任意数量的主题。主题是在节点之间以及系统不同部分之间移动数据的主要方式之一。也就是说，主题可以不只是点对点的交流，它可以是一对多、多对一或多对多。</p>
<p><img src="http://image.onebug.tech/202203062319254.gif" alt="../../_images/Topic-MultiplePublisherandMultipleSubscriber.gif"></p>
<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>我们可以使用<code>rqt_graph</code>来可视化不断变化的节点和主题，以及它们之间的连接。</p>
<p><img src="http://image.onebug.tech/202203062319960.png" alt="../../_images/rqt_graph.png"></p>
<p>上图描述了<code>/turtlesim</code>节点和<code>/teleop_turtle</code>节点如何通过主题相互通信。<code>/teleop_turtle</code>节点将数据发布到<code>/turtle1/cmd_vel</code>主题中（输入用于移动海龟的按键），并且<code>/turtlesim</code>节点订阅该主题以接收数据。</p>
<h3 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h3><ul>
<li><p><code>ros2 topic list</code>：返回系统中当前活动的所有主题的列表</p>
</li>
<li><p><code>ros2 topic list -t</code>：将返回相同的主题列表，返回结果括号中的是主题类型。</p>
</li>
<li><p><code>ros2 topic echo &lt;topic_name&gt; </code>：查看主题上正在发布的数据</p>
</li>
<li><p><code>ros2 topic info &lt;topic_name&gt;</code>：返回主题信息（有多少个订阅者，有多少个发布者）</p>
</li>
<li><p><code>ros2 interface show &lt;type&gt;</code>：节点使用消息通过主题发送数据。发布者和订阅者必须发送和接收相同类型的消息才能进行通信。如果主题<code>/turtle1/cmd_vel</code>的类型是<code>geometry_msgs/msg/Twist</code>，这意味着在<code>geometry_msgs</code>包中有一个名为<code>Twist</code>的消息。<code>ros2 interface show &lt;msg type&gt;</code>可以查看该类型的细节，假设得到的类型细节为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Vector3  linear</span><br><span class="line">        float64 x</span><br><span class="line">        float64 y</span><br><span class="line">        float64 z</span><br><span class="line">Vector3  angular</span><br><span class="line">        float64 x</span><br><span class="line">        float64 y</span><br><span class="line">        float64 z</span><br></pre></td></tr></table></figure>

<p>这说明<code>/turtlesim</code>节点需要一条消息，该消息包含两个向量，即<code>linear</code>向量和<code>angular</code>向量，每个向量包含三个元素。</p>
</li>
<li><p><code>ros2 topic pub &lt;topic_name&gt; &lt;msg_type&gt; &#39;&lt;args&gt;&#39;</code>：使用该命令直接将数据发布到主题，前提是数据的具体结构。需要注意的是，<code>args</code>需要符合YAML语法规范，例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ros2 topic pub --once  /turtle1/cmd_vel geometry_msgs/msg/Twist &quot;&#123;linear: &#123;x: 2.0, y: 0.0, z: 0.0&#125;, angular: &#123;x: 0.0, y: 0.0, z: 1.8&#125;&#125;&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>ros2 topic hz </code>：查看数据发布的速率</p>
</li>
</ul>
<h2 id="Services"><a href="#Services" class="headerlink" title="Services"></a>Services</h2><p>服务（services）是ROS图中节点的另一种通信方法。服务基于呼叫和响应（call-and-response）模型，而不是发布者-订阅者（publisher-subscriber）模型。虽然主题允许节点订阅数据流并获得持续更新，但服务仅在客户端专门调用时提供数据。</p>
<p><img src="http://image.onebug.tech/202203062319118.gif" alt="../../_images/Service-SingleServiceClient.gif"></p>
<p><img src="http://image.onebug.tech/202203062319686.gif" alt="../../_images/Service-MultipleServiceClient.gif"></p>
<h3 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h3><ul>
<li><code>ros2 service list</code>：返回系统中当前活动的所有服务的列表</li>
<li><code>ros2 service type &lt;service_name&gt; </code>：服务类型的定义与主题类型类似，只是服务类型有两部分：一部分用于请求，另一部分用于响应。假如一个服务的类型是<code>std_srvs/srv/Empty</code>，这表示服务调用在发出请求时不发送数据，在接收响应时不接收数据。</li>
<li><code>ros2 service find &lt;service_type&gt;</code>：查找特定类型的所有服务</li>
<li><code>ros2 interface show &lt;service_type_name&gt;</code> ：返回类型的具体结构，返回结果的<code>---</code>将请求结构（上面）与响应结构（下面）分开。</li>
<li><code>ros2 service call &lt;service_name&gt; &lt;service_type&gt; &lt;arguments&gt;</code>：调用服务</li>
</ul>
<h2 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a>Parameters</h2><p>参数（parameters）是节点的配置值。节点可以将参数存储为整数、浮点、布尔、字符串和列表。在ROS2中，每个节点维护自己的参数。所有参数都可动态重新配置，并基于ROS 2服务构建。</p>
<h3 id="命令-3"><a href="#命令-3" class="headerlink" title="命令"></a>命令</h3><ul>
<li><p><code>ros2 param list </code>：查看参数列表</p>
</li>
<li><p><code>ros2 param get &lt;node_name&gt; &lt;parameter_name&gt;</code>：查看参数类型和当前值</p>
</li>
<li><p><code>ros2 param set &lt;node_name&gt; &lt;parameter_name&gt; &lt;value&gt;</code>：设置参数值</p>
</li>
<li><p><code>ros2 param dump &gt; dumpfile</code>：查看节点的所有当前参数值</p>
</li>
<li><p><code>ros2 param load &lt;node_name&gt; &lt;parameter_file&gt;</code>：将参数从文件加载到当前运行的节点</p>
<blockquote>
<p>只读参数只能在启动前修改，启动后修改有可能会出现问题（比如一些QOS参数）</p>
</blockquote>
</li>
<li><p><code>ros2 run &lt;package_name&gt; &lt;executable_name&gt; --ros-args --params-file &lt;file_name&gt;</code>：在启动时加载参数</p>
</li>
</ul>
<h2 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h2><p>Actions是ROS 2中的通信类型之一，用于长时间运行的任务。它们由三部分组成：目标（goal）、反馈（feedback）和结果（result）</p>
<p><img src="http://image.onebug.tech/202203062319195.gif" alt="../_images/Action-SingleActionClient.gif"></p>
<p>行动建立在主题和服务之上，功能与服务类似，只是可以取消操作。它们还提供稳定的反馈，而不是像服务一样只返回单一响应。</p>
<p>Actions使用client-server模型，类似于pubsub模型（在主题教程中介绍）。“action client”节点向“action server”节点发送目标，后者确认目标并返回反馈流和结果。</p>
<h3 id="命令-4"><a href="#命令-4" class="headerlink" title="命令"></a>命令</h3><ul>
<li><p><code>ros2 action list -t</code></p>
</li>
<li><p><code>ros2 action info</code></p>
</li>
<li><p><code>ros2 interface show</code>：返回结果被<code>---</code>分为三个部分，分别是目标请求的结构、结果的结构、反馈的结构。</p>
</li>
<li><p><code>ros2 action send_goal &lt;action_name&gt; &lt;action_type&gt; &lt;values&gt; --feedback</code> ：发生Action中的目标</p>
</li>
</ul>
<h1 id="工作区"><a href="#工作区" class="headerlink" title="工作区"></a>工作区</h1><p>工作区（workspace）是包含ROS2包的目录。</p>
<ul>
<li><p>source ROS2环境：<code>source /opt/ros/rolling/setup.bash</code></p>
</li>
<li><p>创建目录：最好是为每个新的工作区创建新目录，并将所有的包都放置在<code>src</code>文件夹</p>
<blockquote>
<p>在<code>src</code>文件夹执行：<code>git clone https://github.com/ros/ros_tutorials.git -b rolling-devel</code></p>
</blockquote>
</li>
<li><p>在构建工作区之前，您需要解析包依赖关系：<code>rosdep install -i --from-path src --rosdistro rolling -y</code>，</p>
<blockquote>
<p>找不到<code>rosdep</code>命令 的解决方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;apt install python3-rosdep2</span><br></pre></td></tr></table></figure>
<p><code>rosdep update</code> 失败的解决方法：</p>
<ol>
<li>使用rosdepc：<a href="https://www.guyuehome.com/35408">本文之后，世上再无rosdep更新失败问题！如果有….小鱼就… - 古月居 (guyuehome.com)</a></li>
<li>使用github proxy：<a href="https://zhuanlan.zhihu.com/p/392082731">ROS安装过程中如何解决 rosdep update 命令出现错误 - 知乎 (zhihu.com)</a></li>
</ol>
</blockquote>
</li>
<li><p>使用<code>colcon</code>构建工作空间：<code>colcon build</code>。<code>build</code>完成后会生成三个文件夹，<code>build</code>、<code>install</code>、<code>log</code>，其中<code>install</code>目录是您的工作区的安装文件所在的位置，您可以使用它来source overlay。</p>
<blockquote>
<ul>
<li>找不到<code>colcon</code>：</li>
</ul>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt install -y \</span><br><span class="line">build-essential \</span><br><span class="line">cmake \</span><br><span class="line">git \</span><br><span class="line">python3-colcon-common-extensions \</span><br><span class="line">python3-flake8 \</span><br><span class="line">python3-pip \</span><br><span class="line">python3-pytest-cov \</span><br><span class="line">python3-rosdep \</span><br><span class="line">python3-setuptools \</span><br><span class="line">python3-vcstool \</span><br><span class="line">wget</span><br><span class="line"><span class="comment"># install some pip packages needed for testing</span></span><br><span class="line">python3 -m pip install -U \</span><br><span class="line">flake8-blind-except \</span><br><span class="line">flake8-builtins \</span><br><span class="line">flake8-class-newline \</span><br><span class="line">flake8-comprehensions \</span><br><span class="line">flake8-deprecated \</span><br><span class="line">flake8-docstrings \</span><br><span class="line">flake8-import-order \</span><br><span class="line">flake8-quotes \</span><br><span class="line">pytest-repeat \</span><br><span class="line">pytest-rerunfailures \</span><br><span class="line">pytest</span><br></pre></td></tr></table></figure>

<ul>
<li>build 失败的解决办法：</li>
</ul>
<p> python版本的问题，将<code>/usr/bin</code>中的python3.5执行文件改成其他文件名，只留下python3.8执行文件</p>
</blockquote>
</li>
<li><p>source overlay（本地工作区）：<code>. install/local_setup.bash</code></p>
<blockquote>
<p>在source本地工作区之前，需要打开一个新的终端，与构建工作区的终端分开，这一点非常重要，不然有可能会产生复杂的问题</p>
</blockquote>
</li>
<li><p>修改本地工作区的代码：</p>
<ol>
<li>将<code>~/dev_ws/src/ros_tutorials/turtlesim/src/turtle_frame.cpp</code>中52行的<code>setWindowTitle(&quot;TurtleSim&quot;);</code>修改为<code>setWindowTitle(&quot;MyTurtleSim&quot;);</code></li>
<li><code>colcon build</code></li>
<li><code>. install/local_setup.bash</code>、<code>ros2 run turtlesim turtlesim_node</code></li>
</ol>
</li>
</ul>
<h1 id="ROS包"><a href="#ROS包" class="headerlink" title="ROS包"></a>ROS包</h1><p>包（package）可以被认为是你的ROS 2代码的容器。如果你希望能够安装你的代码或与他人分享，那么你就需要把它组织在一个包里。通过包，你可以发布你的ROS 2工作，并允许其他人轻松构建和使用它。</p>
<p>ROS 2的软件包创建使用<code>ament</code>作为其构建系统，<code>colcon</code>作为其构建工具，你可以使用官方支持的CMake或Python来创建一个软件包。除了这些，也存在其他的构建方式。</p>
<blockquote>
<p>Ament是catkin编译工具的优化迭代版本。 </p>
<p>colcon是一个构建软件包集合的命令行工具，是ros构建工具catkin_make, catkin_make_isolated, catkin_tools 和ament_tools的迭代版本。</p>
</blockquote>
<p>Python构建软件包需要：</p>
<ul>
<li><code>package.xml</code>文件，包含关于包的元信息。</li>
<li><code>setup.py</code>，包含如何安装软件包的说明</li>
<li><code>setup.cfg</code> 在软件包有可执行文件时是必需的，这样 ros2 run 可以找到它们。</li>
<li><code>/&lt;package_name&gt;</code> 一个与你的软件包同名的目录，被ROS 2工具用来寻找你的软件包，包含<code>__init__.py</code></li>
</ul>
<p>最简单的Python包文件结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my_package/</span><br><span class="line">      setup.py</span><br><span class="line">      package.xml</span><br><span class="line">      resource/my_package</span><br></pre></td></tr></table></figure>

<p>CMake构建软件包需要：</p>
<ul>
<li><p><code>package.xml</code>文件，包含关于包的元信息。</p>
</li>
<li><p><code>CMakeLists.txt</code>文件，描述了如何构建包内的代码</p>
</li>
</ul>
<p>最简单的的C&#x2F;C++包文件结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my_package/</span><br><span class="line">      setup.py</span><br><span class="line">      package.xml</span><br><span class="line">      resource/my_package</span><br></pre></td></tr></table></figure>

<p>一个工作区可以包含你想要的任何数量的包，每个包都在自己的文件夹里。你也可以在一个工作区中拥有不同构建类型的包（CMake、Python等），但是不能有嵌套的包。最好的做法是在你的工作区里有一个src文件夹，并在那里创建你的包。这样可以保持工作区顶层的干净。</p>
<p>一个典型的工作空间可能看起来是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">workspace_folder/</span><br><span class="line">    src/</span><br><span class="line">      package_1/</span><br><span class="line">          CMakeLists.txt</span><br><span class="line">          package.xml</span><br><span class="line"></span><br><span class="line">      package_2/</span><br><span class="line">          setup.py</span><br><span class="line">          package.xml</span><br><span class="line">          resource/package_2</span><br><span class="line">      ...</span><br><span class="line">      package_n/</span><br><span class="line">          CMakeLists.txt</span><br><span class="line">          package.xml</span><br></pre></td></tr></table></figure>

<p>在ROS 2中创建一个新包的命令语法是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ros2 pkg create --build-type ament_cmake &lt;package_name&gt;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ros2 pkg create --build-type ament_python &lt;package_name&gt;</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ros2 pkg create --build-type ament_cmake --node-name my_node my_package</span><br></pre></td></tr></table></figure>

<p>把软件包放在工作区是一件有意义的事，因为你可以通过在工作区根目录下运行<code>colcon build</code>来一次性构建所有软件包，而不用单独构建每个包。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">colcon build --packages-select my_package</span><br></pre></td></tr></table></figure>

<blockquote>
<p>build失败，原因是email和maintainer包含反斜杆，去掉就行</p>
</blockquote>
<p>尝试运行，<code>ros2 run my_package my_node</code>会看到输出。修改<code>my_node.cpp</code>，重新编译运行，可以看到不同的输出。</p>
<h1 id="pubsub模型"><a href="#pubsub模型" class="headerlink" title="pubsub模型"></a>pubsub模型</h1><h2 id="C-版本"><a href="#C-版本" class="headerlink" title="C++版本"></a>C++版本</h2><h2 id="Python版本"><a href="#Python版本" class="headerlink" title="Python版本"></a>Python版本</h2><h3 id="创建包"><a href="#创建包" class="headerlink" title="创建包"></a>创建包</h3><p>在<code>src</code>文件下执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ros2 pkg create --build-type ament_python py_pubsub</span><br></pre></td></tr></table></figure>

<h3 id="发布Node"><a href="#发布Node" class="headerlink" title="发布Node"></a>发布Node</h3><p>在<code>src/py_pubsub/py_pubsub</code>目录下添加文件<code>publisher_member_function.py</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> rclpy</span><br><span class="line"><span class="keyword">from</span> rclpy.node <span class="keyword">import</span> Node</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># import内置的字符串消息类型，Node使用可以该类型来结构化它在Topic上传递的数据。</span></span><br><span class="line"><span class="keyword">from</span> std_msgs.msg <span class="keyword">import</span> String</span><br><span class="line"></span><br><span class="line"><span class="comment"># MinimalPublisher继承自Node类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MinimalPublisher</span>(<span class="title class_ inherited__">Node</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 指定node名称是minimal_publisher</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(<span class="string">&#x27;minimal_publisher&#x27;</span>)</span><br><span class="line">        <span class="comment"># 声明该节点在一个名为topic的主题上发布String类型的消息,并且 &quot;队列大小 &quot;为10。</span></span><br><span class="line">        self.publisher_ = self.create_publisher(String, <span class="string">&#x27;topic&#x27;</span>, <span class="number">10</span>)</span><br><span class="line">        timer_period = <span class="number">0.5</span>  <span class="comment"># seconds</span></span><br><span class="line">        <span class="comment"># 创建了一个定时器，它的回调每0.5秒执行一次</span></span><br><span class="line">        self.timer = self.create_timer(timer_period, self.timer_callback)</span><br><span class="line">        self.i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># timer_callback函数创建一个附加有计数器值的消息，并在控制台打印该值。</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">timer_callback</span>(<span class="params">self</span>):</span><br><span class="line">        msg = String()</span><br><span class="line">        msg.data = <span class="string">&#x27;Hello World: %d&#x27;</span> % self.i</span><br><span class="line">        self.publisher_.publish(msg)</span><br><span class="line">        self.get_logger().info(<span class="string">&#x27;: &quot;%s&quot;&#x27;</span> % msg.data)</span><br><span class="line">        self.i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">args=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="comment"># 初始化 rclpy 库</span></span><br><span class="line">    rclpy.init(args=args)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建节点</span></span><br><span class="line">    minimal_publisher = MinimalPublisher()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># &quot;spin&quot;节点，使其回调被调用。</span></span><br><span class="line">    <span class="comment"># </span></span><br><span class="line">    rclpy.spin(minimal_publisher)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Destroy the node explicitly</span></span><br><span class="line">    <span class="comment"># (optional - otherwise it will be done automatically</span></span><br><span class="line">    <span class="comment"># when the garbage collector destroys the node object)</span></span><br><span class="line">    minimal_publisher.destroy_node()</span><br><span class="line">    rclpy.shutdown()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>spin与ROS线程调度：<a href="https://levelup.gitconnected.com/ros-spinning-threading-queuing-aac9c0a793f">ROS publisher queue, subscriber queue, callback queue and spinner threads tutorial | Level Up Coding (gitconnected.com)</a></p>
</blockquote>
<h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><p>在<code>package.xml</code>中添加依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;exec_depend&gt;rclpy&lt;/exec_depend&gt;</span><br><span class="line">&lt;exec_depend&gt;std_msgs&lt;/exec_depend&gt;</span><br></pre></td></tr></table></figure>

<h3 id="添加入口点（entry-point）"><a href="#添加入口点（entry-point）" class="headerlink" title="添加入口点（entry point）"></a>添加入口点（entry point）</h3><p>打开<code>setup.py</code>，将信息修改为<code>package.xml</code>中的信息。并修改以下字段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">entry_points=&#123;</span><br><span class="line">        &#x27;console_scripts&#x27;: [</span><br><span class="line">                &#x27;talker = py_pubsub.publisher_member_function:main&#x27;,</span><br><span class="line">        ],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="检查setup-cfg"><a href="#检查setup-cfg" class="headerlink" title="检查setup.cfg"></a>检查setup.cfg</h3><p>一般来说，<code>setup.cfg</code>的文件内容是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[develop]</span><br><span class="line">script_dir=<span class="variable">$base</span>/lib/py_pubsub</span><br><span class="line">[install]</span><br><span class="line">install_scripts=<span class="variable">$base</span>/lib/py_pubsub</span><br></pre></td></tr></table></figure>

<p>含义是告诉 <code>setuptools</code> 要把你的可执行文件放在 <code>lib</code> 中，因为 ros2 run 会在那里寻找可执行文件。</p>
<h3 id="订阅Node"><a href="#订阅Node" class="headerlink" title="订阅Node"></a>订阅Node</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> rclpy</span><br><span class="line"><span class="keyword">from</span> rclpy.node <span class="keyword">import</span> Node</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> std_msgs.msg <span class="keyword">import</span> String</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MinimalSubscriber</span>(<span class="title class_ inherited__">Node</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(<span class="string">&#x27;minimal_subscriber&#x27;</span>)</span><br><span class="line">        <span class="comment"># 订阅者的代码不需要定时器,因为一旦收到消息，它的回调就会被调用。</span></span><br><span class="line">        self.subscription = self.create_subscription(</span><br><span class="line">            String,</span><br><span class="line">            <span class="string">&#x27;topic&#x27;</span>,</span><br><span class="line">            self.listener_callback,</span><br><span class="line">            <span class="number">10</span>)</span><br><span class="line">        self.subscription  <span class="comment"># prevent unused variable warning</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 回调函数简单地将消息的数据打印到控制台。</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">listener_callback</span>(<span class="params">self, msg</span>):</span><br><span class="line">        self.get_logger().info(<span class="string">&#x27;I heard: &quot;%s&quot;&#x27;</span> % msg.data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">args=<span class="literal">None</span></span>):</span><br><span class="line">    rclpy.init(args=args)</span><br><span class="line"></span><br><span class="line">    minimal_subscriber = MinimalSubscriber()</span><br><span class="line"></span><br><span class="line">    rclpy.spin(minimal_subscriber)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Destroy the node explicitly</span></span><br><span class="line">    <span class="comment"># (optional - otherwise it will be done automatically</span></span><br><span class="line">    <span class="comment"># when the garbage collector destroys the node object)</span></span><br><span class="line">    minimal_subscriber.destroy_node()</span><br><span class="line">    rclpy.shutdown()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>在<code>setup.py</code>添加入口点：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;listener = py_pubsub.subscriber_member_function:main&#x27;</span>,</span><br></pre></td></tr></table></figure>

<h3 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#检查依赖</span></span><br><span class="line">rosdep install -i --from-path src --rosdistro rolling -y</span><br><span class="line"><span class="comment">#编译安装</span></span><br><span class="line">colcon build --packages-select py_pubsub</span><br><span class="line"></span><br><span class="line"><span class="comment">#运行</span></span><br><span class="line"><span class="comment">#terminal1</span></span><br><span class="line">. install/setup.bash</span><br><span class="line">ros2 run py_pubsub talker</span><br><span class="line"></span><br><span class="line"><span class="comment">#terminal2</span></span><br><span class="line">. install/setup.bash</span><br><span class="line">ros2 run py_pubsub listener</span><br></pre></td></tr></table></figure>

<h1 id="CS模型"><a href="#CS模型" class="headerlink" title="CS模型"></a>CS模型</h1><h2 id="C-版本-1"><a href="#C-版本-1" class="headerlink" title="C++版本"></a>C++版本</h2><p>请求和响应的结构由一个<code>.srv</code>文件决定。</p>
<h3 id="创建包-1"><a href="#创建包-1" class="headerlink" title="创建包"></a>创建包</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ros2 pkg create --build-type ament_cmake cpp_srvcli --dependencies rclcpp example_interfaces</span><br></pre></td></tr></table></figure>

<p>参数<code>--dependencies</code>将自动在<code>package.xml</code>和<code>CMakeLists.txt</code>中添加必要的依赖关系行。</p>
<p><code>example_interfaces</code>包中有我们将需要的<code>.srv</code>文件的包。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int64 a</span><br><span class="line">int64 b</span><br><span class="line">---</span><br><span class="line">int64 sum</span><br></pre></td></tr></table></figure>

<h3 id="服务端Node"><a href="#服务端Node" class="headerlink" title="服务端Node"></a>服务端Node</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;example_interfaces/srv/add_two_ints.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// add函数将请求中的两个整数相加，并将sum交给响应，同时在控制台打印信息。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;example_interfaces::srv::AddTwoInts::Request&gt; request,</span></span></span><br><span class="line"><span class="params"><span class="function">          std::shared_ptr&lt;example_interfaces::srv::AddTwoInts::Response&gt;      response)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  response-&gt;sum = request-&gt;a + request-&gt;b;</span><br><span class="line">  <span class="built_in">RCLCPP_INFO</span>(rclcpp::<span class="built_in">get_logger</span>(<span class="string">&quot;rclcpp&quot;</span>), <span class="string">&quot;Incoming request\na: %ld&quot;</span> <span class="string">&quot; b: %ld&quot;</span>,</span><br><span class="line">                request-&gt;a, request-&gt;b);</span><br><span class="line">  <span class="built_in">RCLCPP_INFO</span>(rclcpp::<span class="built_in">get_logger</span>(<span class="string">&quot;rclcpp&quot;</span>), <span class="string">&quot;sending back response: [%ld]&quot;</span>, (<span class="type">long</span> <span class="type">int</span>)response-&gt;sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化ROS 2 C++客户端库</span></span><br><span class="line">  rclcpp::<span class="built_in">init</span>(argc, argv);</span><br><span class="line">    <span class="comment">// 创建一个名为add_two_ints_server的节点</span></span><br><span class="line">  std::shared_ptr&lt;rclcpp::Node&gt; node = rclcpp::Node::<span class="built_in">make_shared</span>(<span class="string">&quot;add_two_ints_server&quot;</span>);</span><br><span class="line">    <span class="comment">// 为该节点创建一个名为add_two_ints的服务,并与 add 方法绑定</span></span><br><span class="line">  rclcpp::Service&lt;example_interfaces::srv::AddTwoInts&gt;::SharedPtr service =</span><br><span class="line">    node-&gt;<span class="built_in">create_service</span>&lt;example_interfaces::srv::AddTwoInts&gt;(<span class="string">&quot;add_two_ints&quot;</span>, &amp;add);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">RCLCPP_INFO</span>(rclcpp::<span class="built_in">get_logger</span>(<span class="string">&quot;rclcpp&quot;</span>), <span class="string">&quot;Ready to add two ints.&quot;</span>);</span><br><span class="line">    <span class="comment">// spin节点，使服务可用。</span></span><br><span class="line"></span><br><span class="line">  rclcpp::<span class="built_in">spin</span>(node);</span><br><span class="line">  rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加入口"><a href="#添加入口" class="headerlink" title="添加入口"></a>添加入口</h3><p><code>add_executable</code>宏会生成一个可以用ros2 run来运行的执行文件，在<code>CMakeLists.txt</code>中添加以下代码块，以创建一个名为server的可执行文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add_executable(server src/add_two_ints_server.cpp)</span><br><span class="line">ament_target_dependencies(server</span><br><span class="line">rclcpp example_interfaces)</span><br></pre></td></tr></table></figure>

<p>为了让ros2运行能够找到可执行文件，需要在文件末尾添加以下几行，就在<code>ament_package()</code>之前。</p>
<h3 id="客户端Node"><a href="#客户端Node" class="headerlink" title="客户端Node"></a>客户端Node</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;rclcpp/rclcpp.hpp&quot;</span><br><span class="line">#include &quot;example_interfaces/srv/add_two_ints.hpp&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;chrono&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line"></span><br><span class="line">using namespace std::chrono_literals;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">  rclcpp::init(argc, argv);</span><br><span class="line"></span><br><span class="line">  if (argc != 3) &#123;</span><br><span class="line">      RCLCPP_INFO(rclcpp::get_logger(&quot;rclcpp&quot;), &quot;usage: add_two_ints_client X Y&quot;);</span><br><span class="line">      return 1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::shared_ptr&lt;rclcpp::Node&gt; node = rclcpp::Node::make_shared(&quot;add_two_ints_client&quot;);</span><br><span class="line">  rclcpp::Client&lt;example_interfaces::srv::AddTwoInts&gt;::SharedPtr client =</span><br><span class="line">    node-&gt;create_client&lt;example_interfaces::srv::AddTwoInts&gt;(&quot;add_two_ints&quot;);</span><br><span class="line"></span><br><span class="line">  auto request = std::make_shared&lt;example_interfaces::srv::AddTwoInts::Request&gt;();</span><br><span class="line">  request-&gt;a = atoll(argv[1]);</span><br><span class="line">  request-&gt;b = atoll(argv[2]);</span><br><span class="line"></span><br><span class="line">  while (!client-&gt;wait_for_service(1s)) &#123;</span><br><span class="line">    if (!rclcpp::ok()) &#123;</span><br><span class="line">      RCLCPP_ERROR(rclcpp::get_logger(&quot;rclcpp&quot;), &quot;Interrupted while waiting for the service. Exiting.&quot;);</span><br><span class="line">      return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    RCLCPP_INFO(rclcpp::get_logger(&quot;rclcpp&quot;), &quot;service not available, waiting again...&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  auto result = client-&gt;async_send_request(request);</span><br><span class="line">  // Wait for the result.</span><br><span class="line">  if (rclcpp::spin_until_future_complete(node, result) ==</span><br><span class="line">    rclcpp::FutureReturnCode::SUCCESS)</span><br><span class="line">  &#123;</span><br><span class="line">    RCLCPP_INFO(rclcpp::get_logger(&quot;rclcpp&quot;), &quot;Sum: %ld&quot;, result.get()-&gt;sum);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    RCLCPP_ERROR(rclcpp::get_logger(&quot;rclcpp&quot;), &quot;Failed to call service add_two_ints&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  rclcpp::shutdown();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一样需要添加入口</p>
<h3 id="编译运行-1"><a href="#编译运行-1" class="headerlink" title="编译运行"></a>编译运行</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">colcon build --packages-select cpp_srvcli</span><br><span class="line"></span><br><span class="line">. install/setup.bash</span><br><span class="line">ros2 run cpp_srvcli server</span><br><span class="line"></span><br><span class="line">. install/setup.bash</span><br><span class="line">ros2 run cpp_srvcli client 2 3</span><br></pre></td></tr></table></figure>

<h2 id="Python版本-1"><a href="#Python版本-1" class="headerlink" title="Python版本"></a>Python版本</h2><h1 id="自定义的msg和srv"><a href="#自定义的msg和srv" class="headerlink" title="自定义的msg和srv"></a>自定义的msg和srv</h1><h2 id="创建包-2"><a href="#创建包-2" class="headerlink" title="创建包"></a>创建包</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ros2 pkg create --build-type ament_cmake tutorial_interfaces</span><br></pre></td></tr></table></figure>

<p>注意必须是一个CMake包。</p>
<p>好的做法是将<code>.msg</code>和<code>.srv</code>文件放在软件包内各自的目录中。</p>
<h2 id="创建自定义的definitions"><a href="#创建自定义的definitions" class="headerlink" title="创建自定义的definitions"></a>创建自定义的definitions</h2><p>注意<code>msg</code>、<code>srv</code>、<code>src</code>文件夹在同一层级</p>
<ul>
<li><p><code>Num.msg</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int64 num</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>AddThreeInts.srv</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int64 a</span><br><span class="line">int64 b</span><br><span class="line">int64 c</span><br><span class="line">---</span><br><span class="line">int64 sum	</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>CMakeLists.txt</code>：将定义的接口转换为特定语言的代码（如C++和Python），以便它们可以在这些语言中使用，需要添加以下代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find_package(rosidl_default_generators REQUIRED)</span><br><span class="line"></span><br><span class="line">rosidl_generate_interfaces($&#123;PROJECT_NAME&#125;</span><br><span class="line">  &quot;msg/Num.msg&quot;</span><br><span class="line">  &quot;srv/AddThreeInts.srv&quot;</span><br><span class="line"> )</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>package.xml</code>：接口依赖<code>rosidl_default_generators</code>来生成特定语言的代码，你需要声明对它的依赖性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;build_depend&gt;rosidl_default_generators&lt;/build_depend&gt;</span><br><span class="line"></span><br><span class="line">&lt;exec_depend&gt;rosidl_default_runtime&lt;/exec_depend&gt;</span><br><span class="line"></span><br><span class="line">&lt;member_of_group&gt;rosidl_interface_packages&lt;/member_of_group&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="编译查看"><a href="#编译查看" class="headerlink" title="编译查看"></a>编译查看</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">colcon build --packages-select tutorial_interfaces</span><br><span class="line"></span><br><span class="line">. install/setup.bash</span><br><span class="line">ros2 interface show tutorial_interfaces/msg/Num</span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><ul>
<li><p>源码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;tutorial_interfaces/msg/num.hpp&quot;                      # CHANGE</span><br></pre></td></tr></table></figure>
</li>
<li><p>CMakeLists.txt</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find_package(tutorial_interfaces REQUIRED)                      # CHANGE</span><br><span class="line">ament_target_dependencies(talker rclcpp tutorial_interfaces)    # CHANGE</span><br><span class="line">ament_target_dependencies(listener rclcpp tutorial_interfaces)  # CHANGE</span><br></pre></td></tr></table></figure>
</li>
<li><p>package.xml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;depend&gt;tutorial_interfaces&lt;/depend&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><ul>
<li><p>源码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from tutorial_interfaces.msg import Num                        # CHANGE</span><br></pre></td></tr></table></figure>
</li>
<li><p>package.xml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;exec_depend&gt;tutorial_interfaces&lt;/exec_depend&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="拓展ROS-2的接口-interface"><a href="#拓展ROS-2的接口-interface" class="headerlink" title="拓展ROS 2的接口(interface)"></a>拓展ROS 2的接口(interface)</h1><p>你可以在一个新的接口定义中使用一个现有的接口定义。</p>
<h1 id="ROS-Launch"><a href="#ROS-Launch" class="headerlink" title="ROS Launch"></a>ROS Launch</h1><h2 id="ROS2-启动系统"><a href="#ROS2-启动系统" class="headerlink" title="ROS2 启动系统"></a>ROS2 启动系统</h2><p>ROS 2中的启动系统负责帮助用户描述其系统的配置，然后按照描述执行。系统的配置包括运行什么程序，在哪里运行，向它们传递什么参数，以及ROS特定的约定，通过给它们各自不同的配置，使整个系统中的组件易于重复使用。它还负责监控启动的进程的状态，并报告和&#x2F;或对这些进程的状态变化做出反应。</p>
<p>用Python编写的启动文件可以启动和停止不同的节点，也可以触发各种事件并对其采取行动。提供这个框架的包是 launch_ros，它在下面使用非ROS专用的启动框架。</p>
<h2 id="编写ROS-2启动文件"><a href="#编写ROS-2启动文件" class="headerlink" title="编写ROS 2启动文件"></a>编写ROS 2启动文件</h2><p>如果你还没有，请确保你浏览了关于如何创建ROS 2软件包的快速入门教程。在ROS 2中创建启动文件的一种方法是使用Python文件，这些文件由ROS 2 CLI工具ros2 launch来执行。我们首先使用<code>ros2 pkg create &lt;pkg-name&gt; --dependencies [deps]</code> 在我们的工作区创建一个ROS 2软件包，并创建一个新的启动目录。</p>
<h3 id="C-包"><a href="#C-包" class="headerlink" title="C++ 包"></a>C++ 包</h3><p>如果你正在创建一个C++包，我们将只调整CMakeLists.txt文件，添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Install launch files.</span><br><span class="line">install(DIRECTORY</span><br><span class="line">  launch</span><br><span class="line">  DESTINATION share/$&#123;PROJECT_NAME&#125;/</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>到文件的末尾（但在<code>ament_package()</code>之前）。</p>
<h3 id="编写启动文件"><a href="#编写启动文件" class="headerlink" title="编写启动文件"></a>编写启动文件</h3><p>在你的启动目录中，创建一个后缀为<code>.launch.py</code>的新启动文件。例如：<code>my_script.launch.py</code>。</p>
<p>你的启动文件应该定义<code>generate_launch_description()</code>，它返回一个 launch.LaunchDescription()，供 <code>ros2 launch</code>使用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> launch</span><br><span class="line"><span class="keyword">import</span> launch.actions</span><br><span class="line"><span class="keyword">import</span> launch.substitutions</span><br><span class="line"><span class="keyword">import</span> launch_ros.actions</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_launch_description</span>():</span><br><span class="line">    <span class="keyword">return</span> launch.LaunchDescription([</span><br><span class="line">        launch.actions.DeclareLaunchArgument(</span><br><span class="line">            <span class="string">&#x27;node_prefix&#x27;</span>,</span><br><span class="line">            default_value=[launch.substitutions.EnvironmentVariable(<span class="string">&#x27;USER&#x27;</span>), <span class="string">&#x27;_&#x27;</span>],</span><br><span class="line">            description=<span class="string">&#x27;Prefix for node names&#x27;</span>),</span><br><span class="line">        launch_ros.actions.Node(</span><br><span class="line">            package=<span class="string">&#x27;demo_nodes_cpp&#x27;</span>, node_executable=<span class="string">&#x27;talker&#x27;</span>, output=<span class="string">&#x27;screen&#x27;</span>,</span><br><span class="line">            node_name=[launch.substitutions.LaunchConfiguration(<span class="string">&#x27;node_prefix&#x27;</span>), <span class="string">&#x27;talker&#x27;</span>]),</span><br><span class="line">    ])</span><br></pre></td></tr></table></figure>

<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ros2 launch my_package script.launch.py</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ROS2</category>
      </categories>
      <tags>
        <tag>ros</tag>
      </tags>
  </entry>
  <entry>
    <title>ros2与dds</title>
    <url>/2022/02/13/ROS/ros2dds/</url>
    <content><![CDATA[<p>在探索ROS下一代通信系统的选项时，最初的选择是改进ROS 1的传输，或者使用ZeroMQ、Protocol Buffers和zeroconf（Bonjour&#x2F;Avahi）等组件库构建一个新的中间件。然而，除了这些选项（这两个选项都涉及到我们从头开始构建一个中间件），ROS项目组还考虑了其他端到端的中间件。在研究中，一个中间件脱颖而出，那就是DDS。</p>
<p>使用端到端中间件（如DDS）的好处是，需要维护的代码要少得多，而且中间件的行为和确切规格已经被提炼成文档。有了这种具体的规范，第三方可以审查、审计和实施具有不同程度的互操作性的中间件。此外，如果要从现有的库中构建一个新的中间件，无论如何都需要创建这种类型的规范。</p>
<span id="more"></span>

<h1 id="什么是DDS"><a href="#什么是DDS" class="headerlink" title="什么是DDS"></a>什么是DDS</h1><p><strong>DDS提供了一个发布-订阅的传输（publish-subscribe transport ）</strong>，这与ROS1的发布-订阅的传输非常相似。<strong>DDS使用OMG定义的接口描述语言进行消息定义和序列化。</strong></p>
<p>类似于ROS的服务系统，DDS有一个请求-响应式的传输（request-response style transport）。</p>
<p><strong>DDS提供的发现系统是一个分布式发现系统，这允许任何两个DDS程序进行通信，而不需要像ROS1 master那样的工具。</strong>这使得系统的容错性和灵活性更高。同时，DDS不需要使用动态发现机制，多个DDS供应商提供了静态发现的选项。</p>
<h2 id="技术上的可行性"><a href="#技术上的可行性" class="headerlink" title="技术上的可行性"></a>技术上的可行性</h2><p>DDSI-RTPS非常灵活，允许它用于可靠的、高水平的系统集成以及嵌入式设备上的实时应用。<strong>由于DDS默认是在UDP上实现的，它不依赖于可靠的传输或硬件进行通信。这意味着DDS必须重新发明可靠性轮子（基本上是TCP加上或减去一些功能），但作为交换，DDS获得了便携性和对行为的控制。通过对几个可靠性参数的控制，即DDS所说的服务质量（QoS），为控制通信行为提供了最大的灵活性。</strong></p>
<blockquote>
<p>尽管DDS的默认实现是通过UDP，并且只要求传输的功能水平，但有供应商支持通过TCP实现的DDS。</p>
</blockquote>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p><strong>eProsima的FastRTPS实现可在GitHub上获得</strong>，并获得LGPL许可。</p>
<p><a href="https://github.com/eProsima/Fast-RTPS">https://github.com/eProsima/Fast-RTPS</a></p>
<h1 id="构建在DDS上的ROS"><a href="#构建在DDS上的ROS" class="headerlink" title="构建在DDS上的ROS"></a>构建在DDS上的ROS</h1><p>ROS 2将在DDS之上提供一个类似于ROS 1的接口，为大多数ROS用户隐藏了DDS的复杂性，但又为那些有极端用例或需要与其他现有DDS系统集成的用户单独提供对底层DDS实现的访问。</p>
<p><img src="http://image.onebug.tech/202203062322524.png" alt="DDS and ROS API Layout"></p>
<h2 id="发现"><a href="#发现" class="headerlink" title="发现"></a>发现</h2><p>DDS将完全取代ROS1基于主控的发现系统。ROS需要利用DDS的API来获取信息，如所有节点的列表，所有主题的列表，以及它们是如何连接的。对这些信息的访问将被隐藏在ROS定义的API后面，防止用户直接调用DDS。</p>
<p><strong>DDS发现系统的优点是，在默认情况下，它是完全分布式的，不会出现中央故障点</strong>。DDS还允许用户在其发现系统中定义元数据，这将使ROS能够在发布-订阅上附加更高级别的概念。</p>
<h2 id="发布-订阅传输"><a href="#发布-订阅传输" class="headerlink" title="发布-订阅传输"></a>发布-订阅传输</h2><p>DDSI-RTPS协议取代ROS的TCPROS和UDPROS线协议，用于发布&#x2F;订阅。DDS API为ROS的典型发布&#x2F;订阅模式提供了更多的参与者。 </p>
<p>DDS的主题（Topic）与ROS中的主题概念相似。</p>
<p><strong>DDS中的参与者（Participant）ROS的节点（Node）概念相似</strong>。但在DDS中，节点会被表示为独立的代码对象，既不是订阅者也不是发布者。</p>
<p><img src="http://image.onebug.tech/202202241356558.svg+xml" alt="../../_images/dds_domain.svg"></p>
<h2 id="高效的传输方式"><a href="#高效的传输方式" class="headerlink" title="高效的传输方式"></a>高效的传输方式</h2><p>在ROS 1中，没有一个标准的共享内存传输，如果有任务需要比本地主机TCP更快的速度时，可以使用Nodelets。Nodelets允许发布者和订阅者通过传递<code>boost::shared_ptrs</code>到消息中来共享数据。这种进程内的通信几乎比任何进程间的通信选项更快，而且与网络发布-订阅实现向兼容。</p>
<p><strong>大多数DDS供应商会以透明的方式使用共享内存来优化消息流量（甚至在进程之间），只在离开Localhost时使用有线协议和UDP套接字</strong>，这为DDS提供了相当大的性能提升。</p>
<h2 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h2><p>目前的ROS消息定义有很大的价值。格式很简单，而且消息本身已经在机器人社区的多年使用中得到了发展。当前ROS代码的大部分语义内容都是由这些消息的结构和内容驱动的，因此保留消息的格式和内存表示法具有很大的价值。为了达到这个目标，<strong>ROS 2保留ROS 1那样的消息定义和内存表示</strong>。</p>
<p>因此，<strong>ROS 1的<code>.msg</code>文件将继续使用，.msg文件会被转换为<code>.idl</code>文件，以便它们可以被DDS使用。</strong>ROS 2 API将专门处理内存中的<code>.msg</code>风格的消息对象，并在发布前将其转换为.idl对象。</p>
<p><img src="http://image.onebug.tech/202203062320088.png" alt="Message Generation Diagram"></p>
<blockquote>
<p>在每次调用发布时将消息逐字段转换为另一种对象类型的似乎是一个巨大的性能问题，但实验表明，与序列化的成本相比，这种转换的成本是微不足道的。</p>
</blockquote>
<h2 id="语言支持"><a href="#语言支持" class="headerlink" title="语言支持"></a>语言支持</h2><p>DDS供应商通常至少提供C、C++和Java的实现，因为这些语言的API是由DDS规范明确定义的。ROS 2系统的其中一个目标是提供功能完整的C语言API，开发人员可以将C语言的API包装成一个像Python、Ruby和Lisp这样的语言。</p>
<h2 id="DDS实现的依赖"><a href="#DDS实现的依赖" class="headerlink" title="DDS实现的依赖"></a>DDS实现的依赖</h2><p>ROS 2的目标之一是要尽量减少依赖的数量，以提高可移植性并保持精简的依赖列表。</p>
<p>DDS的一个亮点，就是依赖的精简。DDS的C语言实现只依赖于系统库，C++实现只依赖于C++03编译器，而Java实现只需要JVM和Java标准库。在Ubuntu和OS X上，OpenSplice（其中一种实现）的C、C++、Java和C#实现加在一起，其大小不到3兆字节，并且没有其他依赖性。就依赖的精简性而言，DDS非常有吸引力。</p>
]]></content>
      <categories>
        <category>ROS2</category>
      </categories>
      <tags>
        <tag>ros</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux备忘录</title>
    <url>/2020/06/27/linux/linux%E5%A4%87%E5%BF%98%E5%BD%95/</url>
    <content><![CDATA[<p>Linux备忘录，记录经常忘记的一些命令以及概念。</p>
<span id="more"></span>

<ul>
<li><code>Ctrl + D</code>  结束键盘输入</li>
<li><code>man</code>常用的数字代表的指令类型<ul>
<li><strong>1</strong>用户再shell环境中可以操作的指令和可执行文件</li>
<li><strong>5</strong>配置文件</li>
<li><strong>8</strong>系统管理员可以使用的管理指令</li>
</ul>
</li>
<li><code>info</code> 与<code>man</code>类似，但是<code>info</code>将文档分成一个个页面，每个页面可以跳转</li>
<li><code>/usr/share/doc</code> 存放着软件的一整套说明文件</li>
<li><code>sync</code>将内存中的文件数据立即同步到磁盘</li>
<li>磁盘<ul>
<li>IDE 133MB&#x2F;s</li>
<li>SATA SATA-II  300MB&#x2F;s，SATA-III 600MB&#x2F;s</li>
<li>SCSI  </li>
<li>SAS  6Gb&#x2F;s</li>
</ul>
</li>
<li>磁盘的文件名，文件名后面序号的确定与系统检测到磁盘的顺序有关，而与磁盘所插入的插槽位置无关<ul>
<li>IDE磁盘：&#x2F;dev&#x2F;hd[a-d]</li>
<li>SATA&#x2F;SCSI&#x2F;SAS  ：&#x2F;dev&#x2F;sd[a-p]</li>
</ul>
</li>
<li>MBR<ul>
<li>主要开机记录占446bytes，分区表占64bytes</li>
<li>分区表最多存储四个分区分为主分区和扩展分区，扩展分区只有一个</li>
<li>扩展分区使用其它扇区来记录额外的分区表，从而分出更多逻辑分区</li>
<li>Linux分区当成文件，分区文件的命名方式为：磁盘文件名+编号，例如&#x2F;dev&#x2F;sda1。逻辑分区的编号从5开始</li>
</ul>
</li>
<li>GPT<ul>
<li>GPT为了兼容所有磁盘，在定义扇区上使用逻辑区块地址（Logic Block Address，LBA），LBA扇区大小通常为512bytes</li>
<li>GPT第一个区块记录MBR，紧接着33个区块记录分区信息，最后的33个区块用于对分区信息进行备份，33个区块的第一个区块为GPT表头记录，这个部分记录了分区表本身位置与大小和备份分区的位，同时放置了分区表的校验码（CRC32）。</li>
<li>GPT没有扩展分区的概念，都是主分区，每个LBA可以分为4个分区，因此总共可以分128个分区。</li>
<li>MBR不支持2.2TN以上的硬盘，GPT则最多支持到8ZB</li>
</ul>
</li>
<li>BIOS不可以读取GPT分区表，UEFI可以读取</li>
<li>对分区进行格式化就是在分区上建立文件系统，一个分区通常只能格式化一个文件系统，但是磁盘阵列等技术可以将一个分区格式化称为多个文件系统</li>
<li>文件系统<ul>
<li>inode ，一个文件占用一个inode，记录文件的属性和文件内容所在的block编号</li>
<li>block：记录文件的具体内容</li>
<li>superblock：记录文件系统的整体信息，包括inode和block的总量、使用量、剩余量，文件系统的格式和相关信息</li>
<li>block bitmap：记录block是否被使用的位图</li>
</ul>
</li>
<li>在Ext2文件系统中所支持的block大小有1K，2K，以及4K三种</li>
<li>inode组成：权限、拥有者与群组、容量、ctime、mtime、定义文件特性的旗标（flag，如SetUID）、文件真正内容的指向</li>
<li>每个inode的大小是固定的。为了引用大量的block编号，除了使用直接指向外引入了间接、双间接、三间接引用，这决定了文件系统的最大的单文件大小</li>
<li>建立目录，系统分配一个inode和至少一个block，block中记录的是该目录下的文件名和inode的对应关系</li>
<li>文件的inode本身不记录文件名，文件名记录在目录中，因此新增文件、删除文件、更改文件名这些与文件名有关的操作都与目录的写权限相关</li>
<li>ext3&#x2F;ext4文件系统引入了日志功能，可以利用日志解决block bitmap与block数据不一致的问题</li>
<li>linux 最基础的三个目录：<ul>
<li><code>/root</code> 根目录</li>
<li><code>/usr</code> （unix software resource）软件默认安装目录</li>
<li><code>/var</code>  （varible）存放系统或程序运行中的数据文件</li>
</ul>
</li>
<li><code>mtime</code>：文件内容被修改会更新；<code>ctime</code>：文件的状态改变会更新；<code>atime</code>：读文件时会更新</li>
<li><code>mkdir -p</code> 递归创建目录</li>
<li><code>umask</code>通过掩码表示设置默认权限，文件默认权限为666，目录默认权限为777。<code>umask 0077</code>，之后创建的目录默认权限为700，文件默认权限是600。</li>
<li><code>ln</code>实体链接在目录下创建一个条目，记录文件名与inode编号，不能跨越文件系统、不能对目录进行链接</li>
<li><code>ln -s</code>符号链接保存着源文件所在的绝对路径，可以理解为Windows的快捷方式</li>
<li><code>head</code>：获取文件前几行；<code>tail</code> 获取文件后几行</li>
<li><code>whereis</code>：搜寻相关的的可执行文件、源代码文件、帮助文件</li>
<li><code>locate</code>利用数据库进行搜索，使用<code>updatedb</code>来立即更新数据库</li>
<li><code>find[basedir] [option]</code><ul>
<li><code>-mtime n</code> 列出在n天前的那一天修改过内容的文件</li>
<li><code>-mtime +n</code>列出在n天之前修改过内容的文件</li>
<li><code>-mtime -n</code> 列出在n天之内修改过内容的文件</li>
<li><code>-user name</code>；<code>-group name</code>；<code>-nouser</code>；<code>-nogroup</code></li>
<li><code>-name filename</code></li>
</ul>
</li>
<li><code>gzip</code>、<code>bzip2</code>、<code>xz</code>的压缩比不断优化，不过要注意的是，压缩比越高，压缩的世家就越长</li>
<li><code>tar</code><ul>
<li>打包压缩 <code>tar -zvcf filename.tar.gz</code></li>
<li>查看      <code>tar -ztvf  filename.tar.gz</code></li>
<li>解压缩   <code>tar -zvxf   filename.tar.gz</code></li>
</ul>
</li>
<li>对一个变量赋值直接使用<code>=</code></li>
<li>对变量的使用需要早变量前加上<code>$</code>，也可以用<code>$&#123;&#125;</code>的形式</li>
<li>变量内容中如果有空格，必须使用双引号或者单引号，双引号中的特殊字符可以保留原本特性，单引号内的特殊字符就是特殊字符本身</li>
<li>可以使用`指令`或者${指令}的方式将指令的执行结果赋值给变量</li>
<li>可以使用<code>export</code>命令将自定义变量转为环境变量，环境变量可以在子程序也就是当前bash产生的子bash中使用</li>
<li>指令搜索顺序<ul>
<li>绝对或相对路径</li>
<li>别名</li>
<li>Bash内置指令</li>
<li>$PATH指定的路径搜索找到的第一个指令</li>
</ul>
</li>
<li>数据量重定向<ul>
<li>标准输入 0  <code>&lt;</code>或<code>&lt;&lt;</code></li>
<li>标准输出 1 <code>&gt;</code>或<code>&gt;&gt;</code></li>
<li>标准错误输出 2 <code>2&gt;</code> 或<code>2&gt;&gt;</code></li>
</ul>
</li>
<li><code>2&gt;&amp;1</code>表示将标准错误输出转换为标准输出： <code>find /home -name .bashrrc &gt; list 2&gt;&amp;1</code></li>
<li><code>cut</code>对数据进行切分，取出想要的部分，切分过程一行一行地进行。取出登入者的用户名：<code>last | cut -d &#39; &#39; -f 1</code></li>
<li>以<code>/etc/passwd</code>的第三列进行排序：<code>cat /etc/passwd | sort -t &#39;:&#39;  -k 3</code></li>
<li>取得每个人的登录总次数：<code>last|cut -d  &#39; &#39; -f 1 |sort| uniq -c</code> </li>
<li><code>awk</code>每次只处理一行，处理的最小单位是字段，每个字段的命令方式为<code>$n</code>，n从1开始，<code>$0</code>表示一整行，具体：<code>awk &#39;条件类型 &#123;动作1&#125; 条件类型 &#123;动作2&#125; ...&#39; filename </code></li>
<li><code>awk</code>变量：<code>NF</code>（每一行拥有的字段数）；<code>NR</code>（目前所处理的是第几行数据）；<code>FS</code>（目前的分隔字符，默认是空格）  </li>
<li><code>awk</code>示例：<code>/etc/passwd</code>文件的第三个字段为UID，对UID小于10的数据进行处理：<code>cat /etc/passwd|awk &#39;BEGIN &#123;FS=&quot;:&quot;&#125; $3&lt;10 &#123;print $1 &quot;\t&quot; $3&#125;&#39;</code></li>
<li><code>pstree -A</code>查看进程树</li>
<li>查看特定端口的进程：<code>netstat -anp|grep port</code></li>
<li>一个父进程退出，它的一个或者多个进程还在运行，这些子进程将称为孤儿进程，孤儿进程将会被init进程收养</li>
<li>如果子进程退出，父进程并没有调用<code>wait()</code>或者<code>waitpid()</code>，那么子进程的进程描述符仍然保存在系统中，这种进程被称之为僵尸进程，僵尸进程有可能对系统造成危害，消灭僵尸进程只需要将其父进程杀死即可。</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>备忘录</tag>
      </tags>
  </entry>
  <entry>
    <title>笔记-基于Kali_Linux的渗透研究</title>
    <url>/2020/05/27/linux/%E7%AC%94%E8%AE%B0-%E5%9F%BA%E4%BA%8EKali_Linux%E7%9A%84%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E7%A0%94%E7%A9%B6/</url>
    <content><![CDATA[<p>本文是阅读《基于Kali_Linux的渗透研究》之后写下的笔记。</p>
<span id="more"></span>

<h2 id="渗透信息收集"><a href="#渗透信息收集" class="headerlink" title="渗透信息收集"></a>渗透信息收集</h2><h3 id="主机探测与端口扫描"><a href="#主机探测与端口扫描" class="headerlink" title="主机探测与端口扫描"></a>主机探测与端口扫描</h3><h4 id="活跃主机扫描"><a href="#活跃主机扫描" class="headerlink" title="活跃主机扫描"></a>活跃主机扫描</h4><ul>
<li><p>ICMP Ping</p>
</li>
<li><p>Metasploit主机发现模块</p>
<p><code>modules/auxiliary/scanner/discovery</code>目录下的模块，主要有<code>arp_sweep</code>、<code>ipv6_multicast_ping</code>、<code>ipv6_nerghbor</code>、<code>udp_probe</code>、<code>udp_sweep</code>。<code>arp_sweep</code>使用ARP请求美剧本地局域网络中的所有活跃主机，<code>udp_sweep</code>通过发送UDP数据包探查指定主机是否活跃，并发现其主机上的UDP服务。</p>
</li>
<li><p>Nmap主机探测</p>
<p><code>nmap -sn  192.168.0.1/24</code> C段扫描，发现活跃主机</p>
</li>
</ul>
<h4 id="操作系统识别"><a href="#操作系统识别" class="headerlink" title="操作系统识别"></a>操作系统识别</h4><p><code>nmap -O  [靶机IP地址]</code>，如果识别的信息不够，可以加上<code>-sV</code>参数</p>
<h4 id="端口扫描与服务类型探测"><a href="#端口扫描与服务类型探测" class="headerlink" title="端口扫描与服务类型探测"></a>端口扫描与服务类型探测</h4><p>目前常见的端口扫描有：TCP  Connect 扫描、TCP  SYN 扫描 、TCP  ACK 扫描 、TCP  FIN扫描。</p>
<h5 id="Nmap扫描端口"><a href="#Nmap扫描端口" class="headerlink" title="Nmap扫描端口"></a>Nmap扫描端口</h5><p>常见的扫描类型参数有：</p>
<ul>
<li><code>-sT</code>  TCP  Connect 扫描</li>
<li><code>-sS</code> TCP SYN扫描</li>
<li><code>-sP</code> 通过发送ICMP Ping 请求探测主机是否存活，原理同Ping</li>
<li><code>-sA</code> TCP ACK 扫描</li>
</ul>
<p>常见的扫描选项有：</p>
<ul>
<li><code>-Pn</code>  在扫描之前，不发生ICMP  echo  测试目标是否活跃</li>
<li><code>-O</code>  启用TCP&#x2F;IP协议栈的指纹特征来获取主机操作系统类型信息</li>
<li><code>-F</code> 快速扫描模式，只扫描默认端口</li>
</ul>
<h5 id="Python编程实现端口扫描"><a href="#Python编程实现端口扫描" class="headerlink" title="Python编程实现端口扫描"></a>Python编程实现端口扫描</h5><p>使用BSD套接字的接口进行编程</p>
<h5 id="Nmap探测服务"><a href="#Nmap探测服务" class="headerlink" title="Nmap探测服务"></a>Nmap探测服务</h5><p>端口扫描可以得到服务的简单信息，如果需要获取更加详细的服务版本信心，需要添加<code>-sV</code>选项。</p>
<h4 id="探测结果分析"><a href="#探测结果分析" class="headerlink" title="探测结果分析"></a>探测结果分析</h4><p>将探测到的信息汇总在表上，将端口和服务信息进行归类，并按照可能的攻击路线进行分类。</p>
<p><img src="http://image.onebug.tech/image-20200514161950520.png" alt="常见端口极其说明，以及攻击方向"></p>
<h3 id="网络服务扫描与查点"><a href="#网络服务扫描与查点" class="headerlink" title="网络服务扫描与查点"></a>网络服务扫描与查点</h3><p>对网络上特定服务进行扫描，可以增加渗透成功的概率。在确定开放端口后，通常会对相应端口上运行服务的信息进行更加升入的挖掘，这被称为服务查点。</p>
<h4 id="Telnet-服务扫描"><a href="#Telnet-服务扫描" class="headerlink" title="Telnet 服务扫描"></a>Telnet 服务扫描</h4><p>Telnet是一个历史悠久但缺乏安全性的网络服务，由于Telnet没有对传输过程中的数据进行加密，这使得使用Telnet的网络设备存在安全风险。可以使用Metasploit<code>中的辅助模块telnet_version</code>进行Telnet服务查点。</p>
<h4 id="SSH服务扫描"><a href="#SSH服务扫描" class="headerlink" title="SSH服务扫描"></a>SSH服务扫描</h4><p>与Telnet服务相比，SSH采用的是安全的加密信息传输方式。可以使用Metasploit中的<code>ssh_version</code>进行SSH服务查点。</p>
<h4 id="FPT服务查点"><a href="#FPT服务查点" class="headerlink" title="FPT服务查点"></a>FPT服务查点</h4><p>FPT（File Transfer Protocol）是用于在网络上进行文件传输的一套协议标准，使用的是客户&#x2F;服务模式，属于网络传输协议的应用层。可以使用Metasploit中的<code>fpt_version</code>进行FPT服务查点。</p>
<h4 id="数据库服务查点"><a href="#数据库服务查点" class="headerlink" title="数据库服务查点"></a>数据库服务查点</h4><p>这是漏洞频发的“重灾区”，常见的有：SQL Server 的1433端口、Oracle SQL的1521端口、MySQL的3306端口、Postgre SQL的5453。可以使用Metasploit中不同的数据库查询模块进行服务查点：<code>msssql_ping</code>、<code>tnssnr_version</code>、<code>mysql_version</code>、<code>postgres_version</code>。</p>
<h3 id="网络漏洞扫描"><a href="#网络漏洞扫描" class="headerlink" title="网络漏洞扫描"></a>网络漏洞扫描</h3><p>常见的获取漏洞的方法是使用漏洞扫描工具，主要有<strong>Nessus</strong>和OpenVas，还可以直接到官方网站获取一些设备或系统的漏洞信息。</p>
<h2 id="Web渗透测试"><a href="#Web渗透测试" class="headerlink" title="Web渗透测试"></a>Web渗透测试</h2><h3 id="常见的Web攻击类型"><a href="#常见的Web攻击类型" class="headerlink" title="常见的Web攻击类型"></a>常见的Web攻击类型</h3><p><img src="http://image.onebug.tech/image-20200514175813811.png" alt="2017年Web应用的各类攻击次数占比"></p>
<h3 id="SQL注入攻击"><a href="#SQL注入攻击" class="headerlink" title="SQL注入攻击"></a>SQL注入攻击</h3><p>SQL注入漏洞产生需要满足两个条件：</p>
<ol>
<li>参数用户可控，即前端传给后端的参数内容是用户可以控制的</li>
<li>参数是带入数据库查询，即传入的参数拼接到SQL语句且带入数据库查询</li>
</ol>
<h4 id="SQL注入实例分析"><a href="#SQL注入实例分析" class="headerlink" title="SQL注入实例分析"></a>SQL注入实例分析</h4><ul>
<li><p>测试是否存在注入点，以及注入的类型</p>
<p><img src="http://image.onebug.tech/image-20200514182000220.png" alt="SQL注入测试数据"></p>
</li>
<li><p>获取数据库相关信息</p>
<p>首先使用<code>order by  num</code>判断数据库查询字段数，然后通过<code>union select 1,2,3...</code>联合查询语句判断出具体显示字段的显示位，确定显示位后，可以使用SQL注入常用的内置函数获取数据库的信息，最后获取数据库中表名和列名并导出数据库中的数据，验证数据的有效性可以到<a href="www.cmd5.com">www.cmd5.com</a>。</p>
</li>
</ul>
<h3 id="XSS跨站脚本攻击"><a href="#XSS跨站脚本攻击" class="headerlink" title="XSS跨站脚本攻击"></a>XSS跨站脚本攻击</h3><p>跨站脚本攻击允许用户将恶意代码注入到网页中，其他使用者在浏览网页时会受到影响&#x2F;根据XSS脚本注入方式的不同，XSS攻击一般可以分为三种：反射型XSS、存储型XSS、DOM型XSS。</p>
<ul>
<li>反射性XSS又称非持久性XSS，此攻击类型具有一次性，其攻击方式为：攻击者通过电子邮件等方式将包含XSS代码的恶意链接发送给目标用户。</li>
<li>存储型XSS又称为持久型XSS，攻击脚本将被永久放在服务器的数据库或文件中。这种攻击多见于论坛、博客和留言板。</li>
<li>DOM型XSS是一种特殊的反射型XSS,它是基于DOM文档对象模型的一种漏洞。DOM型XSS攻击方式为：用户请求一个专门被设计的URL，它由攻击者提交且其中包含XSS代码，而服务器的响应不会以任何形式包含攻击者的脚本，当用户的浏览器处理这个响应时，DOM对象就会处理XSS代码。</li>
</ul>
<h3 id="文件上传攻击"><a href="#文件上传攻击" class="headerlink" title="文件上传攻击"></a>文件上传攻击</h3><p>上传webshell工具：BurpSuit</p>
<h2 id="终端主机渗测试"><a href="#终端主机渗测试" class="headerlink" title="终端主机渗测试"></a>终端主机渗测试</h2><h3 id="网络服务渗透"><a href="#网络服务渗透" class="headerlink" title="网络服务渗透"></a>网络服务渗透</h3><p>网络服务渗透攻击指的是以远程主机所运行的网络服务为目标，向目标服务开放端口发送内嵌而已内容并符合该网络协议的数据包，利用网络服务程序内部的安全漏洞，劫持目标程序控制流，实施远程执行代码的行为，最终达到控制目标系统的目的。</p>
<p>在利用漏洞进行渗透测试时，需要注意：</p>
<ul>
<li>网络环境需要满足需求，测试主机和目标主机至少能够互相ping通</li>
<li>高危漏洞要明确，需要通过漏洞扫描工具识别</li>
<li>有可能会由于网络环境不稳定导致入侵失败，需要多次尝试</li>
</ul>
<h3 id="Windows-Server-2003"><a href="#Windows-Server-2003" class="headerlink" title="Windows Server 2003"></a>Windows Server 2003</h3><ul>
<li>Windows远程桌面漏洞：MS12-020</li>
<li>SMB网络服务漏洞：MS17-010</li>
</ul>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ul>
<li>Samba服务渗透攻击</li>
<li>Tomcat 服务渗透攻击</li>
<li>Telnet远程服务渗透攻击</li>
</ul>
<h3 id="Windows-7"><a href="#Windows-7" class="headerlink" title="Windows 7"></a>Windows 7</h3><ul>
<li>SMB服务漏洞：MS17-010</li>
<li>DNS解析漏洞：MS11-030</li>
</ul>
]]></content>
      <categories>
        <category>web渗透</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>web渗透</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>高频面试题</title>
    <url>/2021/03/17/java/%E5%85%AB%E8%82%A1/</url>
    <content><![CDATA[<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="hashmap底层原理（数据结构、为什么用红黑树等）、"><a href="#hashmap底层原理（数据结构、为什么用红黑树等）、" class="headerlink" title="hashmap底层原理（数据结构、为什么用红黑树等）、"></a>hashmap底层原理（数据结构、为什么用红黑树等）、</h2><ul>
<li><p>JDK1.8之前：</p>
</li>
<li><p>链表数组、拉链法</p>
</li>
<li><p>扰动函数：增加低位的随机性（原哈希值右移16位然后与原哈希值异或得到新哈希值），解决取模后索引位置的碰撞问题</p>
</li>
<li><p>数组长度：<code>n=2^m</code>，取模操作<code>hash%n</code>等价于<code>(n-1)&amp;hash</code></p>
</li>
<li><p>JDK1.8之后：链表长度过长会自动转成红黑树，减少搜索时间</p>
</li>
</ul>
<h2 id="ArrayList与LinkedList区别"><a href="#ArrayList与LinkedList区别" class="headerlink" title="ArrayList与LinkedList区别"></a>ArrayList与LinkedList区别</h2><p> <code>Arraylist</code> 底层使用的是 <code>Object</code> 数组；<code>LinkedList</code> 底层使用的是双向链表数据结构</p>
<h2 id="Jvm内存模型"><a href="#Jvm内存模型" class="headerlink" title="Jvm内存模型"></a>Jvm内存模型</h2><p><img src="http://image.onebug.tech/202203151539359.png" alt="img"></p>
<p><img src="http://image.onebug.tech/202203151536380.png" alt="img"></p>
<p><strong>线程私有</strong></p>
<ul>
<li><p>程序计数器：指向下一条需要执行的字节码指令</p>
</li>
<li><p>虚拟机栈：Java 方法执行的内存模型，每次Java方法调用的数据都是通过虚拟机栈传递的。</p>
</li>
<li><p>本地方法栈：Native方法执行的内存模型，每次Native方法调用的数据都是通过本地方法机栈传递的。</p>
</li>
</ul>
<p><strong>线程共享</strong></p>
<ul>
<li><p>堆：存放对象实例</p>
</li>
<li><p>元空间【方法区】：存放常量、类信息、静态变量、JIT编译后的代码</p>
</li>
<li><p>直接内存：NIO中的基础</p>
</li>
</ul>
<h2 id="Jvm垃圾回收算法"><a href="#Jvm垃圾回收算法" class="headerlink" title="Jvm垃圾回收算法"></a>Jvm垃圾回收算法</h2><ul>
<li><p>回收区域：堆是需要回收的核心区域</p>
<p><img src="http://image.onebug.tech/202203161705214.png" alt="img"></p>
<p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1，当它的年龄增加到一定程度，就会被晋升到老年代中。</p>
</li>
<li><p>判断可回收：可达性分析，GCROOTS：类静态属性、常量、虚拟机栈中、本地方法栈中 引用的对象</p>
</li>
<li><p>垃圾收集算法：</p>
<ul>
<li>标记清除【内存碎片问题】、标记整理【效率低】：用于老年代</li>
<li>标记复制：用于新生代，在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。</li>
</ul>
</li>
</ul>
<h2 id="volatile关键字的原理与作用"><a href="#volatile关键字的原理与作用" class="headerlink" title="volatile关键字的原理与作用"></a>volatile关键字的原理与作用</h2><ul>
<li>作用：防止指令重排、保证内存可见性【不保证原子性：<code>i++</code>由多个原子操作组成】</li>
<li>原理：禁止指令重排，在写操作后加入屏障指令，将本地内存中的共享变量值刷新到主内存，在读操作前加入屏障指令，从主内存中读取共享变量。</li>
</ul>
<h2 id="Java集合类（线程安全-x2F-不安全）"><a href="#Java集合类（线程安全-x2F-不安全）" class="headerlink" title="Java集合类（线程安全&#x2F;不安全）"></a>Java集合类（线程安全&#x2F;不安全）</h2><ul>
<li>StringBuilder是线程不安全的，而StringBuffer是线程安全的。</li>
<li>ArrayList线程不安全，CopyOnWriteArrayList线程安全</li>
<li>HashMap线程不安全，ConcurrentHashMap线程安全</li>
<li>并发队列：ConcurrentLinkedQueue、LinkedBlockingQueue、ArrayBlockingQueue、PriorityBlockingQueue、DelayQueue</li>
</ul>
<h2 id="【-】Synchronized和Lock的实现原理与区别"><a href="#【-】Synchronized和Lock的实现原理与区别" class="headerlink" title="【@】Synchronized和Lock的实现原理与区别"></a>【@】Synchronized和Lock的实现原理与区别</h2><ul>
<li><p>Synchronized：基于对象监视器锁，<code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。【JVM层面】</p>
</li>
<li><p>Lock：基于AQS队列【JDK层面】</p>
<blockquote>
<p><a href="http://www.onebug.tech/2021/10/27/java/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/AQS/">Java并发包的基石–抽象同步队列(AQS) | 冰冻橘子的自留地 (onebug.tech)</a></p>
</blockquote>
</li>
<li><p>区别：Lock 的高级功能：等待可中断、公平锁、多条件绑定</p>
</li>
</ul>
<h2 id="ConcurrentHashMap原理，如何保证线程安全"><a href="#ConcurrentHashMap原理，如何保证线程安全" class="headerlink" title="ConcurrentHashMap原理，如何保证线程安全"></a>ConcurrentHashMap原理，如何保证线程安全</h2><p><strong>1.7</strong></p>
<p><img src="http://image.onebug.tech/202203171035371.png" alt="Java 7 ConcurrentHashMap 存储结构"></p>
<p><strong>1.8</strong></p>
<p>1.8抛弃了原有的 Segment 分段锁，而采用了 <code>CAS + synchronized</code> 来保证并发安全性。</p>
<h2 id="Java线程池核心参数与工作流程，拒绝策略"><a href="#Java线程池核心参数与工作流程，拒绝策略" class="headerlink" title="Java线程池核心参数与工作流程，拒绝策略"></a>Java线程池核心参数与工作流程，拒绝策略</h2><p><img src="http://image.onebug.tech/202203151637996.jpeg" alt="这里写图片描述"></p>
<blockquote>
<p><a href="http://www.onebug.tech/2021/04/20/java/java%E5%B9%B6%E5%8F%91/ch11%E7%BA%BF%E7%A8%8B%E6%B1%A0/">线程池 | 冰冻橘子的自留地 (onebug.tech)</a></p>
</blockquote>
<ul>
<li><p><code>corepool</code>、<code>queue</code>、<code>maximumpool</code>、<code>reject</code>四级处理</p>
<blockquote>
<p><code>keepAliveTime</code> 用于配置闲置线程最长存活时间，直到收缩到 <code>corePoolSize</code> 的大小</p>
</blockquote>
</li>
<li><p><code>reject</code>有：抛出异常（<code>abort</code>）、由上层线程执行（<code>callruns</code>）、删除该任务(<code>discard</code>)、删除老任务(<code>discardoldest</code>)</p>
</li>
</ul>
<h2 id="【-】类加载机制"><a href="#【-】类加载机制" class="headerlink" title="【@】类加载机制"></a>【@】类加载机制</h2><p><img src="http://image.onebug.tech/202203171109722.png" alt="img"></p>
<p>加载：获取二进制字节流&#x3D;&gt;生成方法区运行时数据结构&#x3D;&gt;生成class对象作为方法区数据入口</p>
<p>连接：验证、准备【初始化默认值】、解析【符号引用替换为直接引用，也就是得到类或者字段、方法在内存中的指针或者偏移量】</p>
<p>初始化：初始化方法 <code>&lt;clinit&gt; ()</code></p>
<h2 id="【-】SpringAOP的底层原理"><a href="#【-】SpringAOP的底层原理" class="headerlink" title="【@】SpringAOP的底层原理"></a>【@】SpringAOP的底层原理</h2><p>Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 <strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理，如下图所示：</p>
<p>动态代理：设计模式是代理模式【使用代理对象来代替对真实对象的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能】。本质上是通过类加载，然后修改类字节码，重新加载到JVM中，具体是通过反射完成。</p>
<p><img src="http://image.onebug.tech/202203171108344.png" alt="Understanding the Proxy Design Pattern | by Mithun Sasidharan | Medium"></p>
<p><img src="http://image.onebug.tech/202203171049799.png" alt="SpringAOPProcess"></p>
<h1 id="数据库Mysql"><a href="#数据库Mysql" class="headerlink" title="数据库Mysql"></a>数据库Mysql</h1><h2 id="Mysql的几种存储引擎"><a href="#Mysql的几种存储引擎" class="headerlink" title="Mysql的几种存储引擎"></a>Mysql的几种存储引擎</h2><ul>
<li><p>MyISAM 只有表级锁(table-level locking)，而 InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。MyISAM 不提供事务支持。</p>
</li>
<li><p>InnoDB 提供事务支持，具有提交(commit)和回滚(rollback)事务的能力。</p>
</li>
<li><p>MyISAM 不支持，而 InnoDB 支持。</p>
</li>
</ul>
<h2 id="Mysql的聚簇索引和非聚簇索引作用与区别"><a href="#Mysql的聚簇索引和非聚簇索引作用与区别" class="headerlink" title="Mysql的聚簇索引和非聚簇索引作用与区别"></a>Mysql的聚簇索引和非聚簇索引作用与区别</h2><p>聚簇索引就是按照每张表的主键构造一颗B+树，同时叶子节点中存放的就是整张表的行记录数据，也将聚集索引的叶子节点称为数据页。这个特性决定了索引组织表中数据也是索引的一部分，每张表只能拥有一个聚簇索引。</p>
<p>在<strong>聚簇索引之上创建的索引称之为辅助索引</strong>，辅助索引访问数据总是需要二次查找。辅助索引叶子节点存储的不再是行的物理位置，而是主键值。通过辅助索引首先找到的是主键值，再通过主键值找到数据行的数据页，再通过数据页中的Page Directory找到数据行。</p>
<h2 id="索引的数据结构对比（hash、B树与B-树），为什么不用红黑树"><a href="#索引的数据结构对比（hash、B树与B-树），为什么不用红黑树" class="headerlink" title="索引的数据结构对比（hash、B树与B+树），为什么不用红黑树"></a>索引的数据结构对比（hash、B树与B+树），为什么不用红黑树</h2><ul>
<li><p>hash表：不支持范围查找，一般不使用</p>
</li>
<li><p>红黑树的弊端：<strong>红黑树是二叉树</strong>！红黑树一个节点只能存出一个值，在大规模数据存储的时候，红黑树往往出现由于<strong>树的深度过大</strong>而造成磁盘IO读写过于频繁，进而导致效率低下的情况。</p>
</li>
<li><p>B树（多路平衡查找树）：B树是一种<strong>自平衡的多叉搜索树，一个节点可以拥有两个以上的子节点，节点中的数据索引从左到右递增排列</strong>。这种数据结构能够让查找数据、顺序访问、插入数据及删除的动作，都在O(logn)时间内完成。</p>
</li>
<li><p>B+树：</p>
<p><img src="http://image.onebug.tech/20210420165409106.png" alt="img"></p>
</li>
<li><p>B树和B+树的区别：B 树的叶子节点都是独立的，B+树的叶子节点有一条引用链指向与它相邻的叶子节点。B+树只在叶子节点存储数据，查找速度稳定。</p>
</li>
</ul>
<h2 id="Mysql的默认隔离级别、不同等级隔离级别解决的问题与实现原理"><a href="#Mysql的默认隔离级别、不同等级隔离级别解决的问题与实现原理" class="headerlink" title="Mysql的默认隔离级别、不同等级隔离级别解决的问题与实现原理"></a>Mysql的默认隔离级别、不同等级隔离级别解决的问题与实现原理</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT @@transaction_isolation;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center">READ-UNCOMMITTED</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">READ-COMMITTED</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><strong>REPEATABLE-READ</strong>【默认隔离级别】</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">SERIALIZABLE</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table>
<ul>
<li><p>脏读：在一个事务内读取到另一个事务中修改但未提交的数据。</p>
</li>
<li><p>不可重复读：在一个事务内读取到另一个事务中修改后提交的数据。</p>
</li>
<li><p>幻读：在一个事务内插入时遇到到另一个事务中插入后提交的数据。</p>
<blockquote>
<p>不可重复读侧重表达 读-读，幻读则是说 读-写，用写来证实读的是鬼影。幻读，并不是说两次读取获取的结果集不同，幻读侧重的方面是某一次的 select 操作得到的结果所表征的数据状态无法支撑后续的业务操作。更为具体一些：select 某记录是否存在，不存在，准备插入此记录，但执行 insert 时发现此记录已存在，无法插入，此时就发生了幻读。</p>
<p>解决方法：RR级别下只要对 SELECT 操作也手动加行（X）锁即可类似 SERIALIZABLE 级别。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#FOR UPDATE 也会对此 “记录” 加锁</span><br><span class="line">SELECT `id` FROM `users` WHERE `id` = 1 FOR UPDATE;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<h2 id="【TODO】Mvcc实现机制-RC和RR隔离级别下的区别"><a href="#【TODO】Mvcc实现机制-RC和RR隔离级别下的区别" class="headerlink" title="【TODO】Mvcc实现机制(RC和RR隔离级别下的区别)"></a>【TODO】Mvcc实现机制(RC和RR隔离级别下的区别)</h2><p><a href="https://javaguide.cn/database/mysql/innodb-implementation-of-mvcc.html#%E4%B8%80%E8%87%B4%E6%80%A7%E9%9D%9E%E9%94%81%E5%AE%9A%E8%AF%BB%E5%92%8C%E9%94%81%E5%AE%9A%E8%AF%BB">InnoDB存储引擎对MVCC的实现 | JavaGuide</a></p>
<h2 id="Mysql事务及特性"><a href="#Mysql事务及特性" class="headerlink" title="Mysql事务及特性"></a>Mysql事务及特性</h2><p>事务是指逻辑上的一组操作，组成这组操作的各个单元，要不全成功要不全失败。</p>
<h2 id="Mysql-sql优化，慢Sql如何排查"><a href="#Mysql-sql优化，慢Sql如何排查" class="headerlink" title="Mysql sql优化，慢Sql如何排查"></a>Mysql sql优化，慢Sql如何排查</h2><p><a href="https://www.cnblogs.com/zjfjava/p/12257772.html">mysql优化之 — 慢SQL分析 - 雪山上的蒲公英 - 博客园 (cnblogs.com)</a></p>
<h2 id="索引失效的几种场景"><a href="#索引失效的几种场景" class="headerlink" title="索引失效的几种场景"></a>索引失效的几种场景</h2><p><a href="https://www.cnblogs.com/liehen2046/p/11052666.html">索引失效的7种情况 - liehen2046 - 博客园 (cnblogs.com)</a></p>
<h1 id="【-】数据库Redis"><a href="#【-】数据库Redis" class="headerlink" title="【@】数据库Redis"></a>【@】数据库Redis</h1><h2 id="Redis基本数据类型"><a href="#Redis基本数据类型" class="headerlink" title="Redis基本数据类型"></a>Redis基本数据类型</h2><p>String、List、Set、Hash、SortedSet、BitMap</p>
<h2 id="Redis底层数据结构"><a href="#Redis底层数据结构" class="headerlink" title="Redis底层数据结构"></a>Redis底层数据结构</h2><p>除了动态字符串、链表、字典【包含两个哈希表数，方便渐进式rehash】、还有维持有序性的跳表、维持不重复性的整数集合、节约内存的压缩列表</p>
<p><img src="http://image.onebug.tech/202203171139206.png" alt="img"></p>
<h2 id="Redis持久化方式，RDB和AOF的区别与优劣势"><a href="#Redis持久化方式，RDB和AOF的区别与优劣势" class="headerlink" title="Redis持久化方式，RDB和AOF的区别与优劣势"></a>Redis持久化方式，RDB和AOF的区别与优劣势</h2><p>RDB（Redis Database）：将某个时间点的所有数据都存放到硬盘上。如果数据量很大，保存快照的时间会很长，由于是隔一段时间触发一次，实时性不是很好，系统崩溃后丢失的数据可能会很多。</p>
<p>AOF（Append  Only File）：每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到内存缓存 中，然后再根据 <code>appendfsync</code> 配置来决定何时将其同步到硬盘中的 AOF 文件。缺点是随着服务器写请求的增多，AOF 文件会越来越大。对此，Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。</p>
<h2 id="Redis如何实现分布式锁？"><a href="#Redis如何实现分布式锁？" class="headerlink" title="Redis如何实现分布式锁？"></a>Redis如何实现分布式锁？</h2><p>可以使用 Redis 自带的 <strong>SETNX</strong> 命令实现分布式锁：</p>
<ul>
<li><p>使用 SETNX（set if not exist）指令插入一个键值对，如果 Key 已经存在，那么会返回 False，否则插入成功并返回 True。【和CAS一样】</p>
</li>
<li><p>SETNX 指令和数据库的唯一索引类似，保证了只存在一个 Key 的键值对，那么可以用一个 Key 的键值对是否存在来判断是否存于锁定状态。</p>
</li>
<li><p>EXPIRE 指令可以为一个键值对设置一个过期时间，从而避免了数据库唯一索引实现方式中释放锁失败的问题。</p>
</li>
</ul>
<p>除此之外，还可以使用官方提供的 <strong>RedLock</strong> 分布式锁实现：</p>
<ul>
<li><p>尝试从 N 个互相独立 Redis 实例获取锁；</p>
<blockquote>
<p>使用了多个 Redis 实例来实现分布式锁，这是为了保证在发生单点故障时仍然可用。</p>
</blockquote>
</li>
<li><p>计算获取锁消耗的时间，只有时间小于锁的过期时间，并且从大多数（N &#x2F; 2 + 1）实例上获取了锁，才认为获取锁成功；</p>
</li>
<li><p>如果获取锁失败，就到每个实例上释放锁</p>
</li>
</ul>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="Tcp与Udp区别"><a href="#Tcp与Udp区别" class="headerlink" title="Tcp与Udp区别"></a>Tcp与Udp区别</h2><p><img src="http://image.onebug.tech/202203161237066.jpeg" alt="TCP、UDP协议的区别"></p>
<h2 id="Tcp如何保证可靠传输"><a href="#Tcp如何保证可靠传输" class="headerlink" title="Tcp如何保证可靠传输"></a>Tcp如何保证可靠传输</h2><p>TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。</p>
<h2 id="浏览器上输入地址后的整个请求过程"><a href="#浏览器上输入地址后的整个请求过程" class="headerlink" title="浏览器上输入地址后的整个请求过程"></a>浏览器上输入地址后的整个请求过程</h2><ol>
<li>浏览器缓存直接返回，否则</li>
<li>DNS解析域名得到IP：浏览器缓存、hosts文件、本地域名服务器</li>
<li>TCP连接：三次握手</li>
<li>发送HTTP请求（请求方法 请求头 cookie user-agent 等等 请求内容 表单等 )，获取HTTP响应（js、css、html、媒体文件） 【<code>Keep-Alive</code> 复用、TCP四次挥手】，浏览器渲染显示</li>
</ol>
<h2 id="OSI七层、五层模型，每一层的作用"><a href="#OSI七层、五层模型，每一层的作用" class="headerlink" title="OSI七层、五层模型，每一层的作用"></a>OSI七层、五层模型，每一层的作用</h2><p><img src="http://image.onebug.tech/202203161530294.png" alt="osi七层模型"></p>
<h2 id="【-】TCP握手挥手过程及【状态变化】"><a href="#【-】TCP握手挥手过程及【状态变化】" class="headerlink" title="【@】TCP握手挥手过程及【状态变化】"></a>【@】TCP握手挥手过程及【状态变化】</h2><p><img src="http://image.onebug.tech/202203161547968.png" alt="img"></p>
<p><img src="http://image.onebug.tech/202203161546164.jpeg" alt="img"></p>
<h2 id="Tcp流量控制与拥塞控制"><a href="#Tcp流量控制与拥塞控制" class="headerlink" title="Tcp流量控制与拥塞控制"></a>Tcp流量控制与拥塞控制</h2><ul>
<li><p>流量控制是为了控制发送方发送速率，保证接收方来得及接收。拥塞控制是为了降低整个网络的拥塞程度。</p>
</li>
<li><p>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小。TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。</p>
<p><img src="http://image.onebug.tech/202203161642479.png" alt="img"></p>
</li>
</ul>
<h2 id="Http、Https、两者区别"><a href="#Http、Https、两者区别" class="headerlink" title="Http、Https、两者区别"></a>Http、Https、两者区别</h2><p>HTTPS 是基于 HTTP 的，也是用 TCP 作为底层协议，并额外使用 SSL&#x2F;TLS 协议用作加密和安全认证。默认端口号是 443，HTTP默认端口号是80。HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。</p>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h2><p>线程是调度的基本单位，进程是资源管理的基本单位。一般来说，进程之间是独立的，一个进程下会有若干个线程，然后这些线程共享进程资源，并极有可能相互影响。</p>
<p><strong>补充</strong>：<a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017968846697824">协程 - 廖雪峰的官方网站 (liaoxuefeng.com)</a></p>
<h2 id="【-】进程之间通信方式"><a href="#【-】进程之间通信方式" class="headerlink" title="【@】进程之间通信方式"></a>【@】进程之间通信方式</h2><ol>
<li><strong>管道&#x2F;匿名管道(Pipes)</strong> ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。</li>
<li><strong>有名管道(Names Pipes)</strong> : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循**先进先出(first in first out)**。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。【<code>ls | grep xxx</code>】</li>
<li><strong>信号(Signal)</strong> ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件；【<code>kill -9 pid</code>】</li>
<li><strong>消息队列(Message Queuing)</strong> ：消息队列是消息的链表，消息队列有以下优点：可以独立于读写进程存在，不需要进程自己提供同步方法，读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。</li>
<li><strong>信号量(Semaphores)</strong> ：信号量是一个计数器。信号量的意图在于<strong>进程间同步</strong>。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。</li>
<li><strong>共享内存(Shared memory)</strong> ：多个进程可以访问和更新同一块内存空间。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最快的进程间通信方式。</li>
<li><strong>套接字(Sockets)</strong> : 套接字是支持 TCP&#x2F;IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点。</li>
</ol>
<h2 id="CAS操作原理和实现"><a href="#CAS操作原理和实现" class="headerlink" title="CAS操作原理和实现"></a>CAS操作原理和实现</h2><p>CAS （compareAndSwap），中文叫比较交换，是一种无锁原子算法，映射到操作系统就是一条CPU的原子指令，其作用是让CPU先进行比较两个值是否相等，然后原子地更新某个位置的值，其实现方式是基于硬件平台的汇编指令。CAS 是实现自旋锁的基础，CAS 利用 CPU 指令保证了操作的原子性，以达到锁的效果，至于自旋呢，看字面意思也很明白，自己旋转，翻译成人话就是循环，一般是用一个无限循环实现。这样一来，一个无限循环中，执行一个 CAS 操作，当操作成功，返回 true 时，循环结束；当返回 false 时，接着执行循环，继续尝试 CAS 操作，直到返回 true。</p>
<h2 id="死锁的产生条件与解决方案"><a href="#死锁的产生条件与解决方案" class="headerlink" title="死锁的产生条件与解决方案"></a>死锁的产生条件与解决方案</h2><p>产生条件：</p>
<ul>
<li>互斥</li>
<li>不可抢占</li>
<li>申请等待</li>
<li>环</li>
</ul>
<p>解决：</p>
<ul>
<li>鸵鸟</li>
<li>死锁检测【有向图环形检测、银行家算法】与死锁恢复【抢占、回滚、kill】</li>
<li>死锁预防：破坏条件</li>
<li>死锁避免：银行家算法</li>
</ul>
<h1 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h1><h2 id="常见的设计模式与优缺点"><a href="#常见的设计模式与优缺点" class="headerlink" title="常见的设计模式与优缺点"></a>常见的设计模式与优缺点</h2>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>GTEST</title>
    <url>/2022/02/18/%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/GTEST/</url>
    <content><![CDATA[<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p><strong>TODO</strong></p>
<span id="more"></span>

<h1 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h1><p>gtest中，断言的宏根据作用效果可以理解为分为两类：</p>
<ul>
<li><code>ASSERT_*</code> 系列的断言，当检查点失败时，退出当前函数（注意：并非退出当前案例）。</li>
<li><code>_EXPECT_*</code> 系列的断言，当检查点失败时，继续往下执行。</li>
</ul>
<p>根据作用区分，可以分为几大类</p>
<ul>
<li><p>数值类型数据检查：<code>ASSERT_EQ(expected, actual)	</code></p>
</li>
<li><p>布尔值检查：<code>ASSERT_TRUE(condition)</code></p>
</li>
<li><p>字符串检查：<code>ASSERT_STREQ（str1,str2）</code></p>
</li>
<li><p>异常检查：<code>ASSERT_THROW(</code><em>statement</em>, <em>exception_type</em><code>)</code></p>
</li>
<li><p>浮点型检查：<code>ASSERT_NEAR(val1, val2, abs_error)</code></p>
</li>
<li><p>类型检查</p>
</li>
<li><p>…….</p>
</li>
</ul>
<p>GTEST中包含非常丰富的断言，这里不赘述，详细内容请参考<a href="https://google.github.io/googletest/reference/assertions.html">Assertions Reference | GoogleTest</a>。</p>
<blockquote>
<p>如果你对自动输出的出错信息不满意的话，你还可以通过操作符<code>&lt;&lt;</code>将一些自定义的信息输出，通常，这对于调试或是对一些检查点的补充说明来说，非常有用！</p>
<p>EXPECT_EQ(x[i], y[i]) &lt;&lt; “Vectors x and y differ at index “ &lt;&lt; i;</p>
</blockquote>
<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p>gtest提供了多种事件机制，非常方便我们在案例之前或之后做一些操作。</p>
<h2 id="全局事件"><a href="#全局事件" class="headerlink" title="全局事件"></a>全局事件</h2><p>全局的时间在所有案例前后执行。要实现全局事件，必须写一个类，继承<code>testing::Environment</code>类，实现里面的<code>SetUp</code>和<code>TearDown</code>方法。</p>
<ol>
<li><p><code>SetUp()</code>方法在所有案例执行前执行</p>
</li>
<li><p><code>TearDown()</code>方法在所有案例执行后执行</p>
</li>
</ol>
<p>我们还需要告诉gtest添加这个全局事件，我们需要在main函数中通过<code>testing::AddGlobalTestEnvironment</code>方法将事件挂进来，也就是说，我们可以写很多个这样的类，然后将他们的事件都挂上去。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FooEnvironment</span> : <span class="keyword">public</span> testing::Environment</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetUp</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Foo FooEnvironment SetUP&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">TearDown</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Foo FooEnvironment TearDown&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, _TCHAR* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    testing::<span class="built_in">AddGlobalTestEnvironment</span>(<span class="keyword">new</span> FooEnvironment);</span><br><span class="line">    testing::<span class="built_in">InitGoogleTest</span>(&amp;argc, argv);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">RUN_ALL_TESTS</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="TestSuite事件"><a href="#TestSuite事件" class="headerlink" title="TestSuite事件"></a>TestSuite事件</h2><p>我们需要写一个类，继承<code>testing::Test</code>，然后实现<code>SetUpTestCase()</code>和<code>TearDownTestCase()</code>两个静态方法。在编写测试案例时，我们需要使用<code>TEST_F</code>这个宏，第一个参数必须是我们上面<strong>类的名字</strong>，代表一个TestSuite。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FooTest</span> : <span class="keyword">public</span> testing::Test &#123;</span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">SetUpTestCase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    shared_resource_ = <span class="keyword">new</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">TearDownTestCase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> shared_resource_;</span><br><span class="line">    shared_resource_ = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Some expensive resource shared by all tests.</span></span><br><span class="line">  <span class="type">static</span> T* shared_resource_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">TEST_F</span>(FooTest, Test1)</span><br><span class="line"> &#123;</span><br><span class="line">    <span class="comment">// you can refer to shared_resource here </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">TEST_F</span>(FooTest, Test2)</span><br><span class="line"> &#123;</span><br><span class="line">    <span class="comment">// you can refer to shared_resource here </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="TestCase事件"><a href="#TestCase事件" class="headerlink" title="TestCase事件"></a>TestCase事件</h2><p>TestCase事件是挂在每个案例执行前后的，实现方式和上面的几乎一样，不过需要实现的是<code>SetUp</code>方法和<code>TearDown</code>方法。</p>
<h1 id="参数化"><a href="#参数化" class="headerlink" title="参数化"></a>参数化</h1><p>在设计测试案例时，经常需要考虑给被测函数传入不同的值的情况，GTEST提供了一个灵活的参数化测试的方案。如果我们测试一个素数检查函数<code>bool isPrime(int )</code>，我们需要进行以下的步骤：</p>
<ol>
<li>添加一个类，继承<code>testing::TestWithParam&lt;T&gt;</code>，其中T就是你需要参数化的参数类型，比如上面的例子，需要参数化一个<code>int</code>型的参数。</li>
<li>告诉gtest拿到参数的值后，具体做些什么样的测试。我们需要引入一个新的宏<code>TEST_P</code>，关于这个”P”的含义，可以理解为”parameterized” 或者 “pattern”。</li>
<li>告诉gtest你想要测试的参数范围是什么，然后使用<code>INSTANTIATE_TEST_CASE_P</code>宏来告诉gtest你要测试的参数范围。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSTANTIATE_TEST_CASE_P(TrueReturn, IsPrimeParamTest, testing::Values(3, 5, 11, 23, 17));</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第一个参数是测试案例的前缀，可以任意取。</p>
</li>
<li><p>第二个参数是测试案例的名称，需要和之前定义的参数化的类的名称相同，</p>
</li>
<li><p>第三个参数是可以理解为参数生成器，上面的例子使用test::Values表示使用括号内的参数。Google提供了一系列的参数生成的函数：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>Range(begin, end[, step])</td>
<td>范围在begin~end之间，步长为step，不包括end</td>
</tr>
<tr>
<td>Values(v1, v2, …, vN)</td>
<td>v1,v2到vN的值</td>
</tr>
<tr>
<td>ValuesIn(container) and ValuesIn(begin,end)</td>
<td>从一个C类型的数组或是STL容器，或是迭代器中取值</td>
</tr>
<tr>
<td>Bool()</td>
<td>取false 和 true 两个值</td>
</tr>
<tr>
<td>Combine(g1, g2, …, gN)</td>
<td>它将g1,g2,…gN进行排列组合，g1,g2,…gN本身是一个参数生成器，每次分别从g1,g2,..gN中各取出一个值，组合成一个元组(Tuple)作为一个参数</td>
</tr>
</tbody></table>
</li>
</ul>
<p> 综上所述，我们可以完成对素数检查函数的测试：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IsPrimeParamTest</span> : <span class="keyword">public</span>::testing::TestWithParam&lt;<span class="type">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">TEST_P</span>(IsPrimeParamTest, HandleTrueReturn)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n =  <span class="built_in">GetParam</span>();</span><br><span class="line">    <span class="built_in">EXPECT_TRUE</span>(<span class="built_in">IsPrime</span>(n));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">INSTANTIATE_TEST_CASE_P</span>(TrueReturn, IsPrimeParamTest, testing::<span class="built_in">Values</span>(<span class="number">3</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">23</span>, <span class="number">17</span>));</span><br></pre></td></tr></table></figure>

<p>gtest还提供了应付各种不同类型的数据时的方案，以及参数化类型的方案。这里不详细展开。</p>
<h1 id="参数列表"><a href="#参数列表" class="headerlink" title="参数列表"></a>参数列表</h1><table>
<thead>
<tr>
<th><strong>命令行参数</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>–gtest_list_tests</td>
<td>使用这个参数时，将不会执行里面的测试案例，而是输出一个案例的列表。</td>
</tr>
<tr>
<td>–gtest_filter</td>
<td>对执行的测试案例进行过滤，支持通配符</td>
</tr>
<tr>
<td>–gtest_also_run_disabled_tests</td>
<td>执行案例时，同时也执行被置为无效的测试案例。</td>
</tr>
<tr>
<td>–gtest_repeat&#x3D;[COUNT]</td>
<td>设置案例重复运行次数</td>
</tr>
</tbody></table>
<blockquote>
<p>执行案例时，同时也执行被置为无效的测试案例。关于设置测试案例无效的方法为：</p>
<p>在测试案例名称或测试名称中添加DISABLED前缀，比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&gt;<span class="built_in">TEST</span>(FooTest, DISABLED_DoesAbc) &#123;  &#125;</span><br><span class="line">  </span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">DISABLED_BarTest</span> : <span class="keyword">public</span> testing::Test &#123;  &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;<span class="built_in">TEST_F</span>(DISABLED_BarTest, DoesXyz) &#123;  &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>[玩转Google开源C++单元测试框架Google Test系列(gtest)之一 - 初识gtest - CoderZh - 博客园 (cnblogs.com)](<a href="https://www.cnblogs.com/coderzh/archive/2009/04/06/1426758.html">https://www.cnblogs.com/coderzh/archive/2009/04/06/1426758.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>gtest</tag>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker使用大全</title>
    <url>/2022/02/23/%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/docker/</url>
    <content><![CDATA[<h1 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>以Ubuntu为例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get remove docker docker-engine docker.io containerd runc</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg \</span><br><span class="line">    lsb-release</span><br><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</span><br><span class="line"><span class="built_in">echo</span> \</span><br><span class="line">  <span class="string">&quot;deb [arch=<span class="subst">$(dpkg --print-architecture)</span> signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \</span></span><br><span class="line"><span class="string">  <span class="subst">$(lsb_release -cs)</span> stable&quot;</span> | sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install docker-ce docker-ce-cli containerd.io</span><br><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="image"><a href="#image" class="headerlink" title="image"></a>image</h3><p>Docker的镜像可以理解是一个只读的静态模板，类似于我们在装系统的时候用到的.iso文件。</p>
<p>列出所有的镜像：<code>docker images</code>。</p>
<h3 id="container"><a href="#container" class="headerlink" title="container"></a>container</h3><p><strong>container</strong>则相对而言是一个动态的instance，可以理解为我们装好了系统之后的某一台计算机，<strong>可以开机，关机，重启等等，也可以被格式化（删除）</strong>。</p>
<p>列出所有的容器：<code>docker ps -a</code>。</p>
<h3 id="Repository"><a href="#Repository" class="headerlink" title="Repository"></a>Repository</h3><p>我们可以把构建后的镜像上传到服务器，从而可以在任何地方使用到这个镜像。一个Docker Registry中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。我们可以通过<code>&lt;仓库名&gt;:&lt;标签&gt;</code>的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以<code>latest</code>作为默认标签。<br>最常使用的Registry公开服务是官方的<a href="http://hub.docker.com/">Docker Hub</a> ，这也是默认的Registry，并拥有大量的高质量的官方镜像。</p>
<p>登录Registry：<code>docker login xxx</code></p>
<h2 id="基本的使用"><a href="#基本的使用" class="headerlink" title="基本的使用"></a>基本的使用</h2><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><ul>
<li>拉取镜像：<code>docker pull ubuntu</code></li>
<li>推送镜像：<code>docker push username/repository:tag</code></li>
</ul>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><ul>
<li><p>运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run  -d --name <span class="string">&quot;test&quot;</span> -it ubuntu bash</span><br><span class="line"><span class="comment">#-d 后台运行</span></span><br><span class="line">docker <span class="built_in">exec</span> -it <span class="built_in">test</span> bash</span><br><span class="line"><span class="comment">#-i 以交互模式运行容器</span></span><br><span class="line"><span class="comment">#-t 为容器重新分配一个伪输入终端</span></span><br><span class="line"><span class="comment">#在容器内执行/bin/bash命令</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>停止：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker stop <span class="built_in">test</span></span><br><span class="line"><span class="comment">#删除</span></span><br><span class="line"><span class="comment">#docker rm test</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>恢复（物理机关机重启）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker start <span class="built_in">test</span>  </span><br></pre></td></tr></table></figure>
</li>
<li><p>提交当前container为新镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker commit <span class="built_in">test</span>  dev:cpp </span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h1><h2 id="定制镜像"><a href="#定制镜像" class="headerlink" title="定制镜像"></a>定制镜像</h2><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p>镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，这个脚本就是 Dockerfile。Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> debian:stretch</span><br><span class="line"><span class="comment">#FROM 就是指定 基础镜像，因此一个 Dockerfile 中 FROM 是必备的指令，并且必须是第一条指令。</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -x; buildDeps=<span class="string">&#x27;gcc libc6-dev make wget&#x27;</span> \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt-get update \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt-get install -y <span class="variable">$buildDeps</span> \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; wget -O redis.tar.gz <span class="string">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">mkdir</span> -p /usr/src/redis \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; make -C /usr/src/redis \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; make -C /usr/src/redis install \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/* \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">rm</span> redis.tar.gz \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">rm</span> -r /usr/src/redis \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt-get purge -y --auto-remove <span class="variable">$buildDeps</span></span></span><br><span class="line"><span class="comment">#同一目的的所有命令应该归到同一层</span></span><br><span class="line"><span class="comment">#镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</span></span><br></pre></td></tr></table></figure>

<h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>在 <code>Dockerfile</code> 文件所在目录执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build -t redes:v3 . </span><br><span class="line"># . 是在指定上下文的目录，COPY需要用到该设置</span><br></pre></td></tr></table></figure>

<h3 id="Dockerfile指令"><a href="#Dockerfile指令" class="headerlink" title="Dockerfile指令"></a>Dockerfile指令</h3><p><code>Dockerfile</code> 功能很强大，它提供了十多个指令：</p>
<ul>
<li><code>COPY  &lt;源路径&gt;... &lt;目标路径&gt;</code>：指令将从构建上下文目录中 <code>&lt;源路径&gt;</code> 的文件复制到新的一层的镜像内的 <code>&lt;目标路径&gt;</code> 位置</li>
<li><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code>：设置环境变量</li>
<li><code>CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]</code>：<code>CMD</code> 指令就是用于指定默认的容器主进程的启动命令的。容器内没有后台服务的概念，我们应该直接执行可执行文件，并且要求以前台形式运行。</li>
</ul>
<p>其他命令详见<a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile">Dockerfile 指令详解 - Docker —— 从入门到实践 (gitbook.io)</a></p>
<h2 id="VSCode"><a href="#VSCode" class="headerlink" title="VSCode"></a>VSCode</h2><h3 id="noroot运行"><a href="#noroot运行" class="headerlink" title="noroot运行"></a>noroot运行</h3><p>vscode 使用docker必须设置rootless运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dockerd-rootless-setuptool.sh install</span><br></pre></td></tr></table></figure>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li><p>安装Remote - Containers拓展</p>
</li>
<li><p>在远程服务器上启动Container</p>
</li>
<li><p>VSCode连接远程服务器</p>
</li>
<li><p>选择对应Container-&gt;Attach</p>
</li>
<li><p>打开文件夹</p>
</li>
</ul>
<h2 id="高级配置"><a href="#高级配置" class="headerlink" title="高级配置"></a>高级配置</h2><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><h4 id="网络模式"><a href="#网络模式" class="headerlink" title="网络模式"></a>网络模式</h4><p>Docker使用Linux桥接，在宿主机虚拟一个Docker容器网桥(docker0)，Docker启动一个容器时会根据Docker网桥的网段分配给容器一个IP地址，称为Container-IP，同时Docker网桥是每个容器的默认网关。因为在<strong>同一宿主机内的容器都接入同一个网桥</strong>，这样容器之间就能够通过容器的Container-IP直接通信。</p>
<p>除了默认的bridge模式，docker还提供三种网络模式</p>
<table>
<thead>
<tr>
<th>网络模式</th>
<th>配置</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>bridge模式</td>
<td>–net&#x3D;bridge</td>
<td>（<strong>默认</strong>为该模式）此模式会为每一个容器分配、设置IP等，并将容器连接到一个docker0虚拟网桥。<img src="http://image.onebug.tech/202203062318773.png" alt="docker网络模式-bridge"></td>
</tr>
<tr>
<td>host模式</td>
<td>–net&#x3D;host</td>
<td>容器和宿主机共享网络空间。<img src="http://image.onebug.tech/202203062318271.png" alt="docker网络模式-host"></td>
</tr>
<tr>
<td>container模式</td>
<td>–net&#x3D;container:NAME_or_ID</td>
<td>容器和另外一个容器共享网络空间。<img src="http://image.onebug.tech/202203062317644.png" alt="docker网络模式container"></td>
</tr>
<tr>
<td>none模式</td>
<td>–net&#x3D;none</td>
<td>该模式关闭了容器的网络功能。</td>
</tr>
</tbody></table>
<h4 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h4><p>默认的Docker网桥是宿主机虚拟出来的，并不是真实存在的网络设备，外部网络是无法寻址到的，这也意味着外部网络无法通过访问到容器。如果容器希望外部访问能够访问到，可以通过映射容器端口到宿主主机（端口映射），即<code>docker run</code>创建容器时候通过 <code>-p</code> 或 <code>-P</code> 参数来启用，访问容器的时候就通过 [宿主机IP]:[容器端口] 访问容器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -p 8000:80 -it ubuntu /bin/bash</span><br><span class="line"><span class="comment">#将容器的80端口映射到宿主机的8000端口上</span></span><br></pre></td></tr></table></figure>

<h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>Docker容器启动的时候，如果要挂载宿主机的一个目录，可以用<code>-v</code>参数指定，冒号<code>:</code>前面的目录是宿主机目录，后面的目录是容器内目录。这样在容器启动后，容器内会自动创建<code>/project</code>的目录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-v /src/myproject:/project</span><br></pre></td></tr></table></figure>

<h3 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h3><ul>
<li>设置工作目录：<code>-w /project</code></li>
<li>退出时清除自动清理容器内部的文件系统：<code>-rm</code></li>
</ul>
<h2 id="在Docker中使用GPU"><a href="#在Docker中使用GPU" class="headerlink" title="在Docker中使用GPU"></a>在Docker中使用GPU</h2><h3 id="安装nvidia-docker2"><a href="#安装nvidia-docker2" class="headerlink" title="安装nvidia-docker2"></a>安装nvidia-docker2</h3><blockquote>
<p>需要提前在宿主机上安装显卡<a href="https://www.nvidia.com/Download/index.aspx?lang=en-us">驱动</a></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#设置NVIDIA Container Toolkit</span><br><span class="line">distribution=$(. /etc/os-release;echo $ID$VERSION_ID) \</span><br><span class="line">   &amp;&amp; curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | sudo apt-key add - \</span><br><span class="line">   &amp;&amp; curl -s -L https://nvidia.github.io/nvidia-docker/$distribution/nvidia-docker.list | sudo tee /etc/apt/sources.list.d/nvidia-docker.list</span><br><span class="line">#安装nvidia-docker2</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y nvidia-docker2</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>添加<code>--gpus &lt;device id&gt; </code>参数，<code>--gpus all</code>使用所有的GPU。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo docker run --rm --gpus all nvidia/cuda:11.0-base nvidia-smi</span><br></pre></td></tr></table></figure>

<h2 id="GUI程序的运行"><a href="#GUI程序的运行" class="headerlink" title="GUI程序的运行"></a>GUI程序的运行</h2><h3 id="X11"><a href="#X11" class="headerlink" title="X11"></a>X11</h3><p>最简单的方法是暴露宿主机的xhost，这样容器就可以通过对X11的unix套接字的读写间接渲染程序界面。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#调整Xserver权限</span></span><br><span class="line">xhost +<span class="built_in">local</span>:root</span><br><span class="line"><span class="comment">#docker 设置</span></span><br><span class="line">docker run -it \</span><br><span class="line">    --<span class="built_in">env</span>=<span class="string">&quot;DISPLAY&quot;</span> \</span><br><span class="line">    --<span class="built_in">env</span>=<span class="string">&quot;QT_X11_NO_MITSHM=1&quot;</span> \</span><br><span class="line">    --volume=<span class="string">&quot;/tmp/.X11-unix:/tmp/.X11-unix:rw&quot;</span> \</span><br><span class="line">    osrf/ros:indigo-desktop-full \</span><br><span class="line">    rqt</span><br></pre></td></tr></table></figure>

<h3 id="x11docker"><a href="#x11docker" class="headerlink" title="x11docker"></a>x11docker</h3><p>x11docker允许在Linux容器中运行图形化桌面应用程序。</p>
<ul>
<li><p>安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://raw.githubusercontent.com/mviereck/x11docker/master/x11docker | sudo bash -s -- --update</span><br><span class="line">docker pull x11docker/xserver</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x11docker IMAGENAME [COMMAND] </span><br></pre></td></tr></table></figure>

<p>可选参数：</p>
<ul>
<li><code>--desktop</code>提供桌面环境。</li>
<li><code>--gpu</code>用于硬件加速</li>
</ul>
</li>
</ul>
<blockquote>
<p><a href="https://docs.docker.com/engine/install/">Install Docker Engine | Docker Documentation</a></p>
<p><a href="https://yeasy.gitbook.io/docker_practice/">前言 - Docker —— 从入门到实践 (gitbook.io)</a></p>
<p><a href="https://segmentfault.com/a/1190000040335988">docker四种网络模式 - SegmentFault 思否</a></p>
<p><a href="https://github.com/NVIDIA/nvidia-docker">NVIDIA&#x2F;nvidia-docker: Build and run Docker containers leveraging NVIDIA GPUs (github.com)</a></p>
<p><a href="http://wiki.ros.org/docker/Tutorials/GUI">docker&#x2F;Tutorials&#x2F;GUI - ROS Wiki</a></p>
<p><a href="https://github.com/mviereck/x11docker">mviereck&#x2F;x11docker: Run GUI applications and desktops in docker and podman containers. Focus on security. (github.com)</a></p>
</blockquote>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>gpu</tag>
        <tag>gui</tag>
      </tags>
  </entry>
  <entry>
    <title>git备忘录</title>
    <url>/2022/02/19/%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/git/</url>
    <content><![CDATA[<h1 id="Git-LFS"><a href="#Git-LFS" class="headerlink" title="Git LFS"></a>Git LFS</h1><p>Git LFS（Large File Storage，大文件存储）协议，可以把音乐、图片、视频等指定的任意大文件资源存储在Git仓库之外，对于使用者而言，类似在操作一个完整的Git仓库，非常方便。通过将大文件存储在Git原有的数据结构之中，可以减小Git仓库本身的体积，使克隆Git仓库的速度加快，也使得Git不会因为仓库中充满大文件而损失性能。</p>
<span id="more"></span>

<p><img src="http://image.onebug.tech/202202241351274.gif" alt="a diagram showing how Git LFS works"></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s https://packagecloud.io/install/repositories/github/git-lfs/script.deb.sh | sudo bash</span><br><span class="line">sudo apt-get install git-lfs</span><br><span class="line">git lfs install</span><br></pre></td></tr></table></figure>

<h2 id="配置追踪文件"><a href="#配置追踪文件" class="headerlink" title="配置追踪文件"></a>配置追踪文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#追踪所有后缀名为“.mp4”的文件：</span></span><br><span class="line">git lfs track <span class="string">&quot;*.MP4&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看已追踪的文件，已经追踪的文件保存在“.gitattributes”中</span></span><br><span class="line">git lfs track</span><br></pre></td></tr></table></figure>

<h2 id="提交大文件"><a href="#提交大文件" class="headerlink" title="提交大文件"></a>提交大文件</h2><p>提交代码时需要将“.gitattributes”文件也提交到仓库，提交完成后，就可以和原有操作一样使用git的提交功能。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#提交</span></span><br><span class="line">git push origin master</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看 LFS 跟踪的文件列表</span></span><br><span class="line">git lfs ls-files</span><br></pre></td></tr></table></figure>

<h1 id="Gitlab-CI-x2F-CD"><a href="#Gitlab-CI-x2F-CD" class="headerlink" title="Gitlab CI&#x2F;CD"></a>Gitlab CI&#x2F;CD</h1><p>GitLab CI&#x2F;CD 是一个内置在GitLab中的工具，用于通过持续方法进行软件开发：</p>
<ul>
<li>Continuous Integration (CI) 持续集成</li>
<li>Continuous Delivery (CD)   持续交付</li>
<li>Continuous Deployment (CD)  持续部署</li>
</ul>
<p>持续集成的工作原理是将小的代码块推送到Git仓库中托管的应用程序代码库中，并且每次推送时，都要运行一系列脚本来构建、测试和验证代码更改，然后再将其合并到主分支中。</p>
<p>持续交付和部署相当于更进一步的CI，可以在每次推送到仓库默认分支的同时将应用程序部署到生产环境。</p>
<p><img src="http://image.onebug.tech/202202241351844.png" alt="img"></p>
<h2 id="gitlab-ci-yml"><a href="#gitlab-ci-yml" class="headerlink" title=".gitlab-ci.yml"></a>.gitlab-ci.yml</h2><p>了使用GitLab CI&#x2F;CD，你需要一个托管在GitLab上的应用程序代码库，并且在根目录中的.gitlab-ci.yml文件中指定构建、测试和部署的脚本。一旦你已经添加了.gitlab-ci.yml到仓库中，GitLab将检测到该文件，并使用名为GitLab Runner的工具运行你的脚本。该工具的操作与终端类似。这些脚本被分组到jobs，它们共同组成一个pipeline。一个最简单的.gitlab-ci.yml文件可能是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">before_script: </span><br><span class="line">  - apt-get install rubygems ruby-dev -y </span><br><span class="line"></span><br><span class="line">run-test: </span><br><span class="line">  script: </span><br><span class="line">    - ruby --version 6</span><br></pre></td></tr></table></figure>

<p>before_script属性将在运行任何内容之前为你的应用安装依赖，一个名为run-test的job（作业）将打印当前系统的Ruby版本。二者共同构成了在每次推送到仓库的任何分支时都会被触发的Pipeline（管道）。</p>
<h2 id="Runner"><a href="#Runner" class="headerlink" title="Runner"></a>Runner</h2><p>在GitLab中，Runner运行你定义在.gitlab-ci.yml中的作业（job）。一个Runner可以是一个虚拟机、物理机、docker容器，或者一个容器集群。GitLab与Runner之间通过API进行通信，因此只需要Runner所在的机器有网络并且可以访问GitLab服务器即可。在成功配置Runner以后，你应该可以看到你最近的提交的状态 。</p>
<blockquote>
<p><a href="https://support.huaweicloud.com/usermanual-codehub/devcloud_hlp_0960.html">Git LFS使用_代码托管 CodeHub_用户指南_更多Git知识_华为云 (huaweicloud.com)</a></p>
<p><a href="https://www.cnblogs.com/cjsblog/p/12256843.html">GitLab CI&#x2F;CD - 废物大师兄 - 博客园 (cnblogs.com)</a></p>
</blockquote>
<h1 id="Git初始化"><a href="#Git初始化" class="headerlink" title="Git初始化"></a>Git初始化</h1><h2 id="设置用户名"><a href="#设置用户名" class="headerlink" title="设置用户名"></a>设置用户名</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;username&quot;</span></span><br><span class="line">git config --global user.email useremail@xxx.com </span><br></pre></td></tr></table></figure>

<h2 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global https.proxy http://127.0.0.1:1080</span><br><span class="line">git config --global https.proxy https://127.0.0.1:1080</span><br></pre></td></tr></table></figure>

<h2 id="记住github-x2F-gitlab账号密码"><a href="#记住github-x2F-gitlab账号密码" class="headerlink" title="记住github&#x2F;gitlab账号密码"></a>记住github&#x2F;gitlab账号密码</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>git lfs</tag>
        <tag>ci/cd</tag>
      </tags>
  </entry>
  <entry>
    <title>多类型设备时间同步方案</title>
    <url>/2022/02/21/%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/%E5%A4%9A%E8%AE%BE%E5%A4%87%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5/</url>
    <content><![CDATA[<h1 id="PTP"><a href="#PTP" class="headerlink" title="PTP"></a>PTP</h1><h2 id="安装linuxptp"><a href="#安装linuxptp" class="headerlink" title="安装linuxptp"></a>安装linuxptp</h2><h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> http://git.code.sf.net/p/linuxptp/code linuxptp</span><br><span class="line"><span class="built_in">cd</span> linuxptp</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="deb-安装"><a href="#deb-安装" class="headerlink" title="deb 安装"></a>deb 安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install linuxptp</span><br></pre></td></tr></table></figure>

<h2 id="检查网卡状态"><a href="#检查网卡状态" class="headerlink" title="检查网卡状态"></a>检查网卡状态</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ethtool -T enp0s31f6</span><br></pre></td></tr></table></figure>

<p><img src="http://image.onebug.tech/202203062307735.png" alt="image-20220216102002147"></p>
<h2 id="配置PTP时钟"><a href="#配置PTP时钟" class="headerlink" title="配置PTP时钟"></a>配置PTP时钟</h2><h3 id="设备端"><a href="#设备端" class="headerlink" title="设备端"></a>设备端</h3><h4 id="禾赛雷达"><a href="#禾赛雷达" class="headerlink" title="禾赛雷达"></a>禾赛雷达</h4><p><img src="http://image.onebug.tech/image-20220216102230988.png" alt="image-20220216102230988"></p>
<h4 id="Livox"><a href="#Livox" class="headerlink" title="Livox"></a>Livox</h4><p>不需要配置</p>
<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ptp4l -i enp0s31f6 -m</span><br></pre></td></tr></table></figure>

<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>如果网络中出现 <code>Sync Message</code> 数据，说明服务端ptp4l程序的master时钟功能正常运行，如果网络中出现 <code>Delay_Req Message</code> 数据，说明设备端slave时钟功能正常运行。</p>
<p><img src="http://image.onebug.tech/image-20220216103826706.png" alt="image-20220216103826706"></p>
<h1 id="接入NTP"><a href="#接入NTP" class="headerlink" title="接入NTP"></a>接入NTP</h1><h2 id="配置PTP硬件时间"><a href="#配置PTP硬件时间" class="headerlink" title="配置PTP硬件时间"></a>配置PTP硬件时间</h2><p>让PTP硬件时钟和系统时间同步</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo phc2sys -c enp0s31f6 -s CLOCK_REALTIME -O 0 </span><br></pre></td></tr></table></figure>

<h2 id="搭建NTP服务"><a href="#搭建NTP服务" class="headerlink" title="搭建NTP服务"></a>搭建NTP服务</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install ntp</span><br></pre></td></tr></table></figure>

<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/ntp.conf</span><br></pre></td></tr></table></figure>

<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># For more information about this file, see the man pages</span></span><br><span class="line"><span class="comment"># ntp.conf(5), ntp_acc(5), ntp_auth(5), ntp_clock(5), ntp_misc(5), ntp_mon(5).</span></span><br><span class="line"> </span><br><span class="line"><span class="attribute">driftfile</span> /var/lib/ntp/drift  <span class="comment">#默认即可。driftfile用来指定记录本机与上层NTP server之间的频率误差。单位是百万分之一秒。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Permit time synchronization with our time source, but do not</span></span><br><span class="line"><span class="comment"># permit the source to query or modify the service on this system.</span></span><br><span class="line">restrict default nomodify notrap nopeer noquery 　　　　</span><br><span class="line"><span class="comment">#restrict用来管理权限控制。</span></span><br><span class="line"><span class="comment">#格式为 restrict [单个ip|网络|default] parameter　　　　　　</span></span><br><span class="line"><span class="comment">#parameter：　　　　　　　　</span></span><br><span class="line"><span class="comment">#	ignore：拒绝所有的ntp连接　　　　　　　　</span></span><br><span class="line"><span class="comment">#	nomodify：客户端不能使用ntpc和ntpq这两个程序来更改服务器的时间参数，但客户端可以通过此主机来进行网络校时。　　　　　　　　</span></span><br><span class="line"><span class="comment">#	noquery：客户端不能使用ntpc和ntpq等命令来查询时间服务器，等于不提供网络校时服务。　　　　　　　　</span></span><br><span class="line"><span class="comment">#	notrap：不提供trap这个网络时间登陆的功能　　　　　　　　</span></span><br><span class="line"><span class="comment">#	notrust：拒绝没有认证的客户端　　</span></span><br><span class="line"><span class="comment">#	示例：restrict 156.0.26.7  nomodify 9 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Permit all access over the loopback interface.  This could</span></span><br><span class="line"><span class="comment"># be tightened as well, but to do so would effect some of</span></span><br><span class="line"><span class="comment"># the administrative functions.</span></span><br><span class="line">restrict <span class="number">127.0.0.1</span>  <span class="comment">#以下两条默认，放行本机来源</span></span><br><span class="line">restrict ::<span class="number">1</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># Hosts on local network are less restricted.</span></span><br><span class="line">restrict <span class="number">10.0.0.0</span> mask <span class="number">255.0.0.0</span> nomodify notrap</span><br><span class="line">restrict <span class="number">192.168.1.0</span> mask <span class="number">255.255.255.0</span> nomodify notrap</span><br><span class="line"></span><br><span class="line"><span class="comment"># Use public servers from the pool.ntp.org project.</span></span><br><span class="line"><span class="comment"># Please consider joining the pool (http://www.pool.ntp.org/join.html).</span></span><br><span class="line"><span class="comment">#server 0.centos.pool.ntp.org iburst #以下四条为默认，注释掉即可</span></span><br><span class="line"><span class="comment">#server 1.centos.pool.ntp.org iburst</span></span><br><span class="line"><span class="comment">#server 2.centos.pool.ntp.org iburst</span></span><br><span class="line"><span class="comment">#server 3.centos.pool.ntp.org iburst</span></span><br><span class="line"><span class="comment">#server：用来设置上层NTP服务器，说白了就是client向谁请求NTP时间同步。　　　　</span></span><br><span class="line"><span class="comment">#特别注意，在内网环境中由于无法连接到内网，所以没有办法向例如国家授时服务中心210.72.145.44同步时间　　　　</span></span><br><span class="line"><span class="comment">#只能将内网中的某台主机设置为server,用以向其他内网服务器提供NTP服务。</span></span><br><span class="line"></span><br><span class="line">server <span class="number">127.127.1.0</span> prefer </span><br><span class="line"><span class="comment">#以本机时间作为时间服务。内网中这个配置一定要加上，否则会导致NTP服务不可用　#prefer代表这台主机优先级最高。</span></span><br><span class="line"><span class="comment">#broadcast 192.168.1.255 autokey    # broadcast server</span></span><br><span class="line"><span class="comment">#broadcastclient            # broadcast client</span></span><br><span class="line"><span class="comment">#broadcast 224.0.1.1 autokey        # multicast server</span></span><br><span class="line"><span class="comment">#multicastclient 224.0.1.1        # multicast client</span></span><br><span class="line"><span class="comment">#manycastserver 239.255.254.254        # manycast server</span></span><br><span class="line"><span class="comment">#manycastclient 239.255.254.254 autokey # manycast client</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Enable public key cryptography.</span></span><br><span class="line"><span class="comment">#crypto</span></span><br><span class="line"></span><br><span class="line">includefile /etc/ntp/crypto/pw</span><br><span class="line"></span><br><span class="line"><span class="comment"># Key file containing the keys and key identifiers used when operating</span></span><br><span class="line"><span class="comment"># with symmetric key cryptography. </span></span><br><span class="line">keys /etc/ntp/keys <span class="comment">##除了restrict来限制客户端连接外，还可以通过秘钥方式来给客户端认证。</span></span><br><span class="line"><span class="comment"># Specify the key identifiers which are trusted.</span></span><br><span class="line"><span class="comment">#trustedkey 4 8 42</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Specify the key identifier to use with the ntpdc utility.</span></span><br><span class="line"><span class="comment">#requestkey 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Specify the key identifier to use with the ntpq utility.</span></span><br><span class="line"><span class="comment">#controlkey 8</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># Enable writing of statistics records.</span></span><br><span class="line"><span class="comment">#statistics clockstats cryptostats loopstats peerstats</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Disable the monitoring facility to prevent amplification attacks using ntpdc</span></span><br><span class="line"><span class="comment"># monlist command when default restrict does not include the noquery flag. See</span></span><br><span class="line"><span class="comment"># CVE-2013-5211 for more details.</span></span><br><span class="line"><span class="comment"># Note: Monitoring will not be disabled with the limited restriction flag.</span></span><br><span class="line">disable monitor</span><br></pre></td></tr></table></figure>

<h3 id="启动NTP服务"><a href="#启动NTP服务" class="headerlink" title="启动NTP服务"></a>启动NTP服务</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start ntp</span><br></pre></td></tr></table></figure>

<h2 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h2><h3 id="海康威视"><a href="#海康威视" class="headerlink" title="海康威视"></a>海康威视</h3><p><img src="http://image.onebug.tech/image-20220216114540564.png" alt="image-20220216114540564"></p>
<h2 id="验证-1"><a href="#验证-1" class="headerlink" title="验证"></a>验证</h2><p><img src="http://image.onebug.tech/image-20220216120052949.png" alt="image-20220216120052949"></p>
<blockquote>
<p><a href="http://yang.observer/2020/07/11/time-ntp/">计算机的时钟（一）：NTP协议 - Yang Blog</a></p>
<p><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/deployment_guide/ch-configuring_ptp_using_ptp4l">Chapter 23. Configuring PTP Using ptp4l Red Hat Enterprise Linux 6 | Red Hat Customer Portal</a></p>
<p><a href="https://livox-wiki-cn.readthedocs.io/zh_CN/latest/tutorials/timestamp_sychronization.html#id14">5. Livox设备时间同步 — Livox wiki 0.1 文档 (livox-wiki-cn.readthedocs.io)</a></p>
<p><a href="https://www.cnblogs.com/wxxjianchi/p/10531582.html">内网环境搭建NTP服务器 - HowOldAreYou - 博客园 (cnblogs.com)</a></p>
</blockquote>
]]></content>
      <categories>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>gpu</tag>
        <tag>gui</tag>
      </tags>
  </entry>
  <entry>
    <title>顶级域名注册</title>
    <url>/2020/06/24/%E7%BD%91%E7%AB%99/freenom/</url>
    <content><![CDATA[<p>众所周知，<a href="https://freenom.com/">Freenom</a>是地球上唯一一个提供免费顶级域名的商家，不过需要每年续期，每次续期最多一年，而管理界面并不是很人性化。下面介绍如何注册一个免费的顶级域名，使用github action 自动续费，以及托管于cloudflare。</p>
<span id="more"></span>

<h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>注册教程参见<a href="https://zhuanlan.zhihu.com/p/109553641">https://zhuanlan.zhihu.com/p/109553641</a>，需要注意的是：</p>
<ul>
<li>注册过程中你的ip地址要全程保持不变</li>
<li>个人信息可以瞎填，但是<strong>国家</strong>信息尽量与你的ip地址相对应</li>
<li>账号注册成功后，如果在申请顶级域名的过程中出现问题的话，多刷新几次，或者等一天再回来申请，还不成功可以尝试给freenom发封邮件，附上自己的<strong>customer id</strong>（我几乎没遇到问题就是了）</li>
</ul>
<h3 id="使用cloudflare管理域名"><a href="#使用cloudflare管理域名" class="headerlink" title="使用cloudflare管理域名"></a>使用<a href="https://www.cloudflare.com/">cloudflare</a>管理域名</h3><p>直接按照cloudflare的提示进行操作，非常简单，无非就是修改DNS服务器地址。添加域名的时候，如果出现<code>XXX is not a registered domain</code>的错误，要先在freenom管理页面随便添加一条解析记录，然后才能在cloudflare处继续操作。freenom更改DNS服务器一般需要一天时间，这段时间cloudflare上的域名状态会一直显示<code>Pending Nameserver Update</code>，你只需要等待就行。</p>
<p>如果你只需要域名解析服务，注意添加域名解析时不要点亮小云朵，使用<strong>dns only</strong>就可以了。</p>
<p><img src="http://image.onebug.tech/image-20200624103558605.png-d" alt="image-20200624103558605"></p>
<h3 id="使用github-action自动续期"><a href="#使用github-action自动续期" class="headerlink" title="使用github action自动续期"></a>使用<a href="http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html">github action</a>自动续期</h3><ul>
<li><p>fork项目<a href="https://github.com/luolongfei/freenom">https://github.com/luolongfei/freenom</a> </p>
</li>
<li><p>查看<a href="https://github.com/lsqls/freenom#--%E6%9C%AC%E9%A1%B9%E7%9B%AE%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95">项目使用方法</a></p>
</li>
<li><p>设置<strong>Secrets</strong></p>
</li>
<li><p>启用github action</p>
</li>
</ul>
<p>附上一张我的<strong>Secrets</strong>截图 ，我是直接把邮件通知关了<code>MAIL_EBABLE=false</code>（如果你需要这个功能，请自行设置）</p>
<p><img src="http://image.onebug.tech/image-20200624104312825.png-d" alt="image-20200624104312825"></p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>免费的就是最贵的，而且还不能保证稳定。我就遇到域名被污染的情况，最后通过重新注册才解决该问题。域名这玩意并不贵，我的建议是嫌麻烦直接去<a href="https://sg.godaddy.com/zh">godday</a>购买一个首年域名，价格不会超过10RMB。</p>
]]></content>
      <categories>
        <category>网站</category>
      </categories>
      <tags>
        <tag>域名</tag>
        <tag>cloudflare</tag>
      </tags>
  </entry>
  <entry>
    <title>github action 部署爬虫脚本</title>
    <url>/2020/06/28/%E7%BD%91%E7%AB%99/github%20action%20%E9%83%A8%E7%BD%B2%E7%88%AC%E8%99%AB%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<p>很久之前写了一个爬虫脚本，每10分钟获取一次比特币价格，当价格波动较大时，使用邮件通知我进行交易。之前的脚本部署在学校的群晖上，由于会时不时地停电，爬虫脚本运行状态很不稳定，这段时间接触了github action ，感觉正好满足我的需求，于是将爬虫迁移到到GitHub Action上，并弃用原来Python实现的邮件发送功能，改为利用Github Action实现邮件通知。</p>
<p>项目地址：<a href="https://github.com/lsqls/bitcoin">https://github.com/lsqls/bitcoin</a></p>
<span id="more"></span>

<h2 id="编写爬虫脚本"><a href="#编写爬虫脚本" class="headerlink" title="编写爬虫脚本"></a>编写爬虫脚本</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#https://price.btcfans.com/</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">from</span> jinja2 <span class="keyword">import</span> Environment, PackageLoader</span><br><span class="line"><span class="built_in">max</span>=<span class="number">10000</span>;<span class="built_in">min</span>=<span class="number">4000</span></span><br><span class="line"><span class="comment">#获取环境变量中的MAX，MIN值</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;MAX&#x27;</span> <span class="keyword">in</span> os.environ:</span><br><span class="line">    <span class="built_in">max</span>=<span class="built_in">float</span>(os.getenv(<span class="string">&#x27;MAX&#x27;</span>)) </span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;MIN&#x27;</span> <span class="keyword">in</span> os.environ:</span><br><span class="line">    <span class="built_in">min</span>=<span class="built_in">float</span>(os.getenv(<span class="string">&#x27;MIN&#x27;</span>))</span><br><span class="line">sendemail=<span class="literal">False</span>;strategy=<span class="string">&quot;继续持有&quot;</span></span><br><span class="line"><span class="comment">#获取https://price.btcfans.com/上显示的比特币价格</span></span><br><span class="line">url=<span class="string">&#x27;https://price.btcfans.com/&#x27;</span></span><br><span class="line">html = etree.HTML(requests.get(url).text)</span><br><span class="line">price = <span class="built_in">float</span>(html.xpath(<span class="string">&#x27;//li[@id=&quot;coin-bitcoin&quot;]//span[@class=&quot;last-price&quot;]/text()&#x27;</span>)[<span class="number">0</span>].replace(<span class="string">&#x27;,&#x27;</span>,<span class="string">&#x27;&#x27;</span>))</span><br><span class="line"><span class="comment">#根据当前价格选择策略，以及是否发送邮件</span></span><br><span class="line"><span class="keyword">if</span> (price&gt;<span class="built_in">max</span>):</span><br><span class="line">    sendemail=<span class="literal">True</span></span><br><span class="line">    strategy=<span class="string">&quot;卖出&quot;</span></span><br><span class="line"><span class="keyword">if</span> (price&lt;<span class="built_in">min</span>):</span><br><span class="line">    sendemail=<span class="literal">True</span></span><br><span class="line">    strategy=<span class="string">&quot;买入&quot;</span></span><br><span class="line"><span class="comment">#使用jinja2渲染HTML用于发送邮件</span></span><br><span class="line">env = Environment(loader=PackageLoader(<span class="string">&#x27;bitcoin&#x27;</span>, <span class="string">&#x27;&#x27;</span>))</span><br><span class="line">template = env.get_template(<span class="string">&#x27;template.html&#x27;</span>)</span><br><span class="line">template.stream(price=price,<span class="built_in">max</span>=<span class="built_in">max</span>,<span class="built_in">min</span>=<span class="built_in">min</span>,strategy=strategy).dump(<span class="string">&#x27;email.html&#x27;</span>)</span><br><span class="line"><span class="comment">#放弃使用Python脚本发送邮件的方案，使用dawidd6/action-send-mail发送邮件，两者通过环境变量通信</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;::set-env name=sendemail::&#123;&#125;&quot;</span>.<span class="built_in">format</span>(sendemail))</span><br></pre></td></tr></table></figure>

<p>脚本非常简单，可以分为以下几步：</p>
<ul>
<li><p>读取环境变量中的MAX、MIN值。如果不存在，就使用默认值</p>
</li>
<li><p>获取网络上的比特币价格</p>
</li>
<li><p>根据当前比特币价格选择策略</p>
</li>
<li><p>渲染HTML文件用于发送邮件</p>
</li>
<li><p>设置环境变量，邮件发送需要根据这个变量选择是否执行</p>
<p><img src="http://image.onebug.tech/image-20200628210633551.png-d" alt="image-20200628210633551"></p>
<center> 输出HTML的部分截图</center></li>
</ul>
<h2 id="编写workflow文件"><a href="#编写workflow文件" class="headerlink" title="编写workflow文件"></a>编写workflow文件</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&#x27;bitcoin&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line">  <span class="attr">schedule:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">cron:</span> <span class="string">&#x27;*/10 *  * * *&#x27;</span> </span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">GetBtcPrice:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&#x27;Checkout codes&#x27;</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&#x27;Setup python&#x27;</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/setup-python@v1</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">python-version:</span> <span class="string">&#x27;3.x&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&#x27;Install dependencies&#x27;</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">python</span> <span class="string">-m</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">--upgrade</span> <span class="string">requests</span> <span class="string">lxml</span> <span class="string">jinja2</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&#x27;run get price script&#x27;</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="attr">MAX:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.MAX</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">MIN:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.MIN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">python</span> <span class="string">bitcoin.py</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Send</span> <span class="string">mail</span></span><br><span class="line">      <span class="attr">if:</span> <span class="string">$&#123;&#123;</span> <span class="string">env.sendemail</span> <span class="string">==</span> <span class="string">&#x27;True&#x27;</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">dawidd6/action-send-mail@v2</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">server_address:</span> <span class="string">smtp.163.com</span></span><br><span class="line">        <span class="attr">server_port:</span> <span class="number">465</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">$&#123;&#123;secrets.MAIL_USERNAME&#125;&#125;</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">$&#123;&#123;secrets.MAIL_PASSWORD&#125;&#125;</span></span><br><span class="line">        <span class="attr">subject:</span> <span class="string">比特币价格监控</span></span><br><span class="line">        <span class="comment"># Literal body:</span></span><br><span class="line">        <span class="attr">body:</span> <span class="string">file://email.html</span></span><br><span class="line">        <span class="attr">to:</span> <span class="string">$&#123;&#123;secrets.TO&#125;&#125;</span></span><br><span class="line">        <span class="attr">from:</span> <span class="string">$&#123;&#123;secrets.MAIL_USERNAME&#125;&#125;</span> <span class="comment"># &lt;user@example.com&gt;</span></span><br><span class="line">        <span class="comment"># Optional content type (defaults to text/plain):</span></span><br><span class="line">        <span class="attr">content_type:</span> <span class="string">text/html</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>脚本每10分钟执行一次，cron的设置语法和Linux下的crontab一致</p>
</li>
<li><p>在secrets中设置<code>MAX</code>、<code>MIN</code>、<code>MAIL_USERNAME</code>、<code>MAIL_PASSWORD</code>、<code>TO</code>（接收邮箱地址）以保证脚本的正常运行</p>
</li>
<li><p>Fork 的仓库上 GitHub Actions 的定时任务不会自动执行，必须要手动触发一次后才能正常工作，随便改点什么提交就行</p>
<p><img src="http://image.onebug.tech/image-20200628205024464.png-d" alt="image-20200628205024464"></p>
</li>
</ul>
<h2 id="参考文章与项目"><a href="#参考文章与项目" class="headerlink" title="参考文章与项目"></a>参考文章与项目</h2><blockquote>
<p><a href="http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html">http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2019/12/github_actions.html">http://www.ruanyifeng.com/blog/2019/12/github_actions.html</a></p>
<p><a href="https://github.com/Closty/chaoxing/">https://github.com/Closty/chaoxing/</a></p>
<p><a href="https://help.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_idif">https://help.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_idif</a></p>
</blockquote>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>github action</tag>
      </tags>
  </entry>
  <entry>
    <title>博客折腾笔记</title>
    <url>/2020/06/20/%E7%BD%91%E7%AB%99/%E5%8D%9A%E5%AE%A2%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>之前有拿Wordpress搭建过博客，感觉还是太臃肿了，Hexo这种静态博客刚好满足我的需求，记录下折腾博客的过程。</p>
<span id="more"></span>

<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>在云服务商处购买服务器与域名，备案的时候需要服务器，如果打算将博客托管在对象存储或者github pages之类的平台，可以选择不购买服务器，直接到*宝购买服务号即可。</p>
<h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><h3 id="Hexo-的安装"><a href="#Hexo-的安装" class="headerlink" title="Hexo 的安装"></a>Hexo 的安装</h3><ul>
<li>安装<a href="https://nodejs.org/zh-cn/">node.js</a></li>
</ul>
<blockquote>
<p>使用 Node.js 官方安装程序时，请确保勾选 <strong>Add to PATH</strong> 选项（默认已勾选）</p>
</blockquote>
<ul>
<li>安装hexo</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo init blog</span><br><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">npm install</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果你觉得速度慢，可以使用阿里提供的<a href="https://developer.aliyun.com/mirror/NPM?from=tnpm">NPM淘宝镜像</a>，或者<a href="https://stackoverflow.com/questions/7559648/is-there-a-way-to-make-npm-install-the-command-to-work-behind-proxy">使用代理</a></p>
</blockquote>
<ul>
<li><p>修改配置</p>
<p>打开<code>_config.yml</code>，修改<code>title</code>、<code>description</code>、<code>author</code>、<code>language</code>、<code>url</code>字段。</p>
</li>
</ul>
<h3 id="安装-next-主题"><a href="#安装-next-主题" class="headerlink" title="安装 next 主题"></a>安装 next 主题</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span>  blog</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>

<p>在<code>_config.yml</code>中将<code>theme</code>字段值设置为<code>next</code>。</p>
<h3 id="配置-next-主题（可选）"><a href="#配置-next-主题（可选）" class="headerlink" title="配置 next 主题（可选）"></a>配置 next 主题（可选）</h3><p>配置next主题指的是修改<code>next/_config.yml</code>文件，注意区分。</p>
<h4 id="选择-Scheme"><a href="#选择-Scheme" class="headerlink" title="选择 Scheme"></a>选择 Scheme</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">scheme:</span> <span class="string">Muse</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br></pre></td></tr></table></figure>

<h4 id="设置头像"><a href="#设置头像" class="headerlink" title="设置头像"></a>设置头像</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="comment"># Replace the default image and set the url here.</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">http://image.onebug.tech/avatar.png</span></span><br><span class="line">  <span class="comment"># If true, the avatar will be dispalyed in circle.</span></span><br><span class="line">  <span class="attr">rounded:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If true, the avatar will be rotated with the cursor.</span></span><br><span class="line">  <span class="attr">rotated:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h4 id="添加标签页"><a href="#添加标签页" class="headerlink" title="添加标签页"></a>添加标签页</h4><ul>
<li><p>新建标签页</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> your-hexo-site </span><br><span class="line">$ hexo new page tags</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改主题配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="添加分类页"><a href="#添加分类页" class="headerlink" title="添加分类页"></a>添加分类页</h4><ul>
<li><p>新建标签页</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> your-hexo-site </span><br><span class="line">$ hexo new page categories</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改主题配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="侧边栏社交链接"><a href="#侧边栏社交链接" class="headerlink" title="侧边栏社交链接"></a>侧边栏社交链接</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">GitHub:</span> <span class="string">https://github.com/lsqls</span> <span class="string">||</span> <span class="string">fab</span> <span class="string">fa-github</span></span><br><span class="line">  <span class="string">邮箱:</span> <span class="string">mailto:764666894@qq.com</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-envelope</span></span><br></pre></td></tr></table></figure>
<h4 id="设置字体"><a href="#设置字体" class="headerlink" title="设置字体"></a>设置字体</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">font:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 外链字体库地址，例如 //fonts.googleapis.com (默认值)</span></span><br><span class="line">  <span class="attr">host:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 全局字体，应用在 body 元素上</span></span><br><span class="line">  <span class="attr">global:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span> <span class="string">Monda</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 标题字体 (h1, h2, h3, h4, h5, h6)</span></span><br><span class="line">  <span class="attr">headings:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span> <span class="string">Roboto</span> <span class="string">Slab</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 文章字体</span></span><br><span class="line">  <span class="attr">posts:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Logo 字体</span></span><br><span class="line">  <span class="attr">logo:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span> <span class="string">Lobster</span> <span class="string">Two</span></span><br><span class="line">    <span class="attr">size:</span> <span class="number">24</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 代码字体，应用于 code 以及代码块</span></span><br><span class="line">  <span class="attr">codes:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span> <span class="string">PT</span> <span class="string">Mono</span></span><br></pre></td></tr></table></figure>

<h4 id="设置动画效果"><a href="#设置动画效果" class="headerlink" title="设置动画效果"></a>设置动画效果</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">use_motion:</span> <span class="literal">true</span>  <span class="comment"># 开启动画效果</span></span><br><span class="line"><span class="comment"># use_motion: false # 关闭动画效果</span></span><br></pre></td></tr></table></figure>

<h4 id="设置页脚"><a href="#设置页脚" class="headerlink" title="设置页脚"></a>设置页脚</h4><ul>
<li><p>不显示<code>Powered by Hexo &amp; NexT</code>信息</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">powered:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>添加备案号</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">beian:</span></span><br><span class="line"> <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"> <span class="attr">icp:</span> <span class="string">京ICP备17073808-2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>站点建立时间</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">since:</span> <span class="number">2020</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="设置版权信息"><a href="#设置版权信息" class="headerlink" title="设置版权信息"></a>设置版权信息</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Declare license on posts</span></span><br><span class="line"><span class="attr">post_copyright:</span></span><br><span class="line"> <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"> <span class="attr">license:</span> <span class="string">CC</span> <span class="string">BY-NC-SA</span> <span class="number">3.0</span></span><br><span class="line"> <span class="attr">license_url:</span> <span class="string">https://creativecommons.org/licenses/by-nc-sa/3.0/</span></span><br></pre></td></tr></table></figure>

<h4 id="加载进度条"><a href="#加载进度条" class="headerlink" title="加载进度条"></a>加载进度条</h4><ul>
<li><p>安装<code>pace</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/theme-next-pace themes/next/source/lib/pace</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pace:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Themes list:</span></span><br><span class="line">  <span class="comment"># big-counter | bounce | barber-shop | center-atom | center-circle | center-radar | center-simple</span></span><br><span class="line">  <span class="comment"># corner-indicator | fill-left | flat-top | flash | loading-bar | mac-osx | material | minimal</span></span><br><span class="line">  <span class="attr">theme:</span> <span class="string">minimal</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="显示当前浏览进度"><a href="#显示当前浏览进度" class="headerlink" title="显示当前浏览进度"></a>显示当前浏览进度</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">scrollpercent:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h4 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line"> <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h4 id="百度统计"><a href="#百度统计" class="headerlink" title="百度统计"></a>百度统计</h4><p>登录 <a href="http://tongji.baidu.com/">百度统计</a>，定位到站点的代码获取页面，复制 <code>hm.js?</code> 后面那串统计脚本 id，编辑 主题配置文件， 修改字段 <code>baidu_analytics</code>，值设置成你的百度统计脚本 id</p>
<h4 id="文章阅读次数统计"><a href="#文章阅读次数统计" class="headerlink" title="文章阅读次数统计"></a>文章阅读次数统计</h4><p><code>NexT</code>主题已集成了不蒜子的访客人数和文章阅读统计功能。</p>
<p>修改<code>NexT\_config.yml</code>设置<code>enable</code>为<code>true</code>即可。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_visitors:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_visitors_icon:</span> <span class="string">fa</span> <span class="string">fa-user</span></span><br><span class="line">  <span class="attr">total_views:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_views_icon:</span> <span class="string">fa</span> <span class="string">fa-eye</span></span><br><span class="line">  <span class="attr">post_views:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">post_views_icon:</span> <span class="string">fa</span> <span class="string">fa-eye</span></span><br></pre></td></tr></table></figure>

<h4 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h4><p>比较常用的开源项目 CDN 服务商主要有 unpkg、bootcdn、 cdnjs、jsdelivr 和 cloudflare，本站主要使用 jsdelivr 提供的 CDN 加速服务。</p>
<h4 id="评论系统"><a href="#评论系统" class="headerlink" title="评论系统"></a>评论系统</h4><p><a href="https://yueyue200830.github.io/2020/05/17/Hexo-Next%E6%B7%BB%E5%8A%A0Valine%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/">Hexo+Next添加Valine评论系统 | Z Blog (yueyue200830.github.io)</a></p>
<h2 id="博客部署"><a href="#博客部署" class="headerlink" title="博客部署"></a>博客部署</h2><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><ul>
<li>git</li>
<li>nginx</li>
</ul>
<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><h4 id="git服务器"><a href="#git服务器" class="headerlink" title="git服务器"></a>git服务器</h4><ul>
<li><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600/899998870925664">搭建git服务器</a></p>
</li>
<li><p>配置钩子</p>
<p>在 <code>/home/git/lsqls/public.git/hooks</code>  目录下新建一个 <code>post-receive</code> 可执行文件，编辑这个文件，写入如下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">git --work-tree=/var/www/hexoblog/public --git-dir=/home/git/lsqls/public.git checkout -f</span><br></pre></td></tr></table></figure>

<ul>
<li>设置这个文件的可执行权限：<code>chmod +x post-receive</code></li>
<li>更改配置目录的权限：<code>chown -R git:git /var/www/hexoblog/public/</code></li>
<li>注意，<code>/var/www/hexoblog/public</code> 要换成你自己的部署目录</li>
</ul>
<p>可以尝试手动执行脚本，验证是否正常工作。</p>
</li>
</ul>
<h4 id="nginx服务器"><a href="#nginx服务器" class="headerlink" title="nginx服务器"></a>nginx服务器</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/nginx/conf.d/</span><br><span class="line">vi blog.conf</span><br></pre></td></tr></table></figure>

<p><code>blog.conf</code>文件配置，开启缓存。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">server <span class="punctuation">&#123;</span></span><br><span class="line">        listen       <span class="number">80</span>;</span><br><span class="line">        server_name  www.onebug.tech;</span><br><span class="line">        charset utf<span class="number">-8</span>;</span><br><span class="line"></span><br><span class="line">        root   /var/www/hexoblog/public;# 这里是静态文件地址</span><br><span class="line">        index  index.html;</span><br><span class="line">    location ~* ^.+\.(ico|gif|jpg|jpeg|png)$ <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">   		access_log off;</span><br><span class="line">    		expires <span class="number">30</span>d;</span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">	location ~* ^.+\.(css|js|txt|xml|swf|wav)$ <span class="punctuation">&#123;</span></span><br><span class="line">			access_log off;</span><br><span class="line">			expires <span class="number">24</span>h;</span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line">	</span><br><span class="line">	location ~* ^.+\.(html|htm)$ <span class="punctuation">&#123;</span></span><br><span class="line">	 		expires <span class="number">1</span>h;</span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>编辑<code>nginx.conf</code>，开启gzip</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">gzip on;</span><br><span class="line"></span><br><span class="line">#设置允许压缩的页面最小字节数;</span><br><span class="line">gzip_min_length <span class="number">1</span>k;</span><br><span class="line"></span><br><span class="line">#设置压缩缓冲区大小，此处设置为<span class="number">4</span>个<span class="number">16</span>K内存作为压缩结果流缓存</span><br><span class="line">gzip_buffers <span class="number">4</span> <span class="number">16</span>k;</span><br><span class="line"></span><br><span class="line">#压缩版本</span><br><span class="line">gzip_http_version <span class="number">1.1</span>;</span><br><span class="line"></span><br><span class="line">#设置压缩比率，最小为<span class="number">1</span>，处理速度快，传输速度慢；<span class="number">9</span>为最大压缩比，处理速度慢，传输速度快;级别越高，压缩就越小</span><br><span class="line">gzip_comp_level <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">#制定压缩的类型</span><br><span class="line">gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/javascript application/json image/svg+xml application/x-font-ttf font/opentype image/x-icon;</span><br><span class="line"></span><br><span class="line">#配置禁用gzip条件，支持正则。此处表示ie6及以下不启用gzip（因为ie低版本不支持）</span><br><span class="line">gzip_disable <span class="string">&quot;MSIE [1-6]\.&quot;</span>;</span><br><span class="line"></span><br><span class="line">#选择支持vary header；改选项可以让前端的缓存服务器缓存经过gzip压缩的页面; 这个可以不写</span><br><span class="line">gzip_vary on;</span><br></pre></td></tr></table></figure>
<h4 id="七牛云"><a href="#七牛云" class="headerlink" title="七牛云"></a>七牛云</h4><ul>
<li><p>下载qshell：<a href="https://developer.qiniu.com/kodo/1302/qshell#2">命令行工具(qshell)_实用工具_对象存储 - 七牛开发者中心 (qiniu.com)</a></p>
</li>
<li><p>添加账户：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qshell account [&lt;AccessKey&gt; &lt;SecretKey&gt; &lt;Name 任意字符串&gt;] </span><br></pre></td></tr></table></figure>
</li>
<li><p>添加储存空间<code>lbshexoblog</code>，并做一些配置：</p>
<p><img src="http://image.onebug.tech/202203071106734.png" alt="image-20220307110635645"></p>
</li>
<li><p>在<code>hexo</code>目录配置文件 <code>qiniu.conf</code>：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;src_dir&quot;: &quot;D:\\hexoblog\\public&quot;,</span><br><span class="line">   //储存空间名称</span><br><span class="line">  &quot;bucket&quot;: &quot;lbshexoblog&quot;,</span><br><span class="line">  //是否覆盖  </span><br><span class="line">  &quot;overwrite&quot; : true,</span><br><span class="line">  //检查新增文件</span><br><span class="line">  &quot;rescan_local&quot; : <span class="attribute">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加CDN刷新文件列表<code>cdnrefresh.txt</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://www.onebug.tech</span><br></pre></td></tr></table></figure>
</li>
<li><p>上传命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">qshell qupload qiniuyun.conf</span><br><span class="line">qshell cdnrefresh -i cdnrefresh.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>一键部署，修改<code>package.json</code>，今后只需要 <code>npm run publish</code> 就可实现一键打包部署到七牛云</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;:&#123;</span><br><span class="line">    &quot;publish&quot;: &quot;hexo g &amp;&amp; qshell qupload qiniuyun.conf &amp;&amp; qshell cdnrefresh -i cdnrefresh.txt&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h2><p>图床能够很大程度降低响应延迟，本站使用的是七牛云作为图床。可以参考该<a href="https://www.imczw.com/post/tech/hexo-on-oss-all.html">文章</a>搭建。</p>
<h2 id="bugfix"><a href="#bugfix" class="headerlink" title="bugfix"></a>bugfix</h2><h3 id="中文目录不跳转"><a href="#中文目录不跳转" class="headerlink" title="中文目录不跳转"></a>中文目录不跳转</h3><p>hexo更新后遇到中文目录不跳转的问题，修复见<a href="https://github.com/theme-next/hexo-theme-next/pull/1540/files">fix: Chinese TOC cannot jump</a>。直接替换<code>source/js/utils.js</code>。</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>测试</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>腾讯云(DNSPOD)域名DDNS脚本使用</title>
    <url>/2020/06/24/%E7%BD%91%E7%AB%99/%E8%85%BE%E8%AE%AF%E4%BA%91(DNSPOD)%E5%9F%9F%E5%90%8DDDNS%E8%84%9A%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>DDNS（Dynamic Domain Name Server，动态域名服务）是将用户的动态IP地址映射到一个固定的域名解析服务上，用户每次连接网络的时候客户端程序就会通过信息传递把该主机的动态IP地址传送给位于服务商主机上的服务器程序，服务器程序负责提供DNS服务并实现动态域名解析。下面是介绍如何使用脚本实现腾讯云购买域名的DDNS。</p>
<span id="more"></span>

<h2 id="登录DNSPod获取密钥"><a href="#登录DNSPod获取密钥" class="headerlink" title="登录DNSPod获取密钥"></a>登录DNSPod获取密钥</h2><p>访问DNSPod控制台<a href="https://console.dnspod.cn/">https://console.dnspod.cn/</a>，使用你的腾讯云账号登录，如果腾讯云账号绑定微信，直接扫码登录就行。在域名管理添加一条A记录。域名前缀需要设定好，IP可以随意填写。我将域名前缀设置为<code>test</code>，ip设置为<code>1.1.1.1</code>。</p>
<p><img src="http://image.onebug.tech/image-20200624223938388.png-d" alt="image-20200624223938388"></p>
<p>点击个人头像下的密钥管理，创建一个密钥，将<code>ID</code>和<code>token</code>记下。</p>
<p><img src="http://image.onebug.tech/image-20200624224951160.png-d" alt="image-20200624224951160"></p>
<h2 id="设置DDNS脚本"><a href="#设置DDNS脚本" class="headerlink" title="设置DDNS脚本"></a>设置DDNS脚本</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/imki911/ArDNSPod</span><br><span class="line"><span class="built_in">cd</span> ArDNSPod</span><br><span class="line">vi dns.conf</span><br></pre></td></tr></table></figure>

<p><code>dns.conf</code>设置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. Combine your token ID and token together as follows</span></span><br><span class="line"><span class="comment"># 第一个参数是上图的ID，第二个参数是上图的Token</span></span><br><span class="line">arToken=<span class="string">&quot;123425,b28c3344eaeaea9074c123451234512d&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. Place each domain you want to check as follows</span></span><br><span class="line"><span class="comment"># you can have multiple arDdnsCheck blocks</span></span><br><span class="line"><span class="comment"># 第一个参数是你的域名，第二个参数是前面设定的域名前缀</span></span><br><span class="line">arDdnsCheck <span class="string">&quot;yourdomain.com&quot;</span> <span class="string">&quot;test&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="定时运行DDNS脚本"><a href="#定时运行DDNS脚本" class="headerlink" title="定时运行DDNS脚本"></a>定时运行DDNS脚本</h2><p>测试脚本是否能正常运行，<code>./ddnspod.sh</code>，显示以下信息说明脚本正常运行，到DNSPod控制台可以看到前面设置的A记录的IP已经被修改为外网IP。</p>
<p><img src="http://image.onebug.tech/image-20200624225712024.png-d" alt="image-20200624225712024"></p>
<p>利用cron半小时执行一次DDNS脚本，注意脚本要使用绝对路径。群晖可以使用自带的定时程序完成该操作。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crontab -e</span><br><span class="line">*/30 * * * *   bin/bash /home/bzjz/ArDNSPod/ddnspod.sh</span><br></pre></td></tr></table></figure>

<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>将不支持DDNS的域名服务商下的域名接入DNSPod，同样可以实现DDNS。</p>
<p><img src="http://image.onebug.tech/image-20200624232552344.png-d" alt="image-20200624232552344"></p>
]]></content>
      <categories>
        <category>网站</category>
      </categories>
      <tags>
        <tag>域名</tag>
        <tag>ddns</tag>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>navicat for windows 激活</title>
    <url>/2020/08/27/%E8%BD%AF%E4%BB%B6/navicat%E6%BF%80%E6%B4%BB/</url>
    <content><![CDATA[<p>本教程用于激活windows 版本的navicat-premium。</p>
<span id="more"></span>

<h2 id="下载安装navicat"><a href="#下载安装navicat" class="headerlink" title="下载安装navicat"></a>下载安装navicat</h2><p>到官网下载navicat，<a href="https://www.navicat.com.cn/products/navicat-premium">https://www.navicat.com.cn/products/navicat-premium</a>。下载完成后安装。安装过程中请记下navicat的安装目录，后面会用到。</p>
<h2 id="编译激活工具"><a href="#编译激活工具" class="headerlink" title="编译激活工具"></a>编译激活工具</h2><p>激活工具的github项目地址：<a href="https://github.com/HeQuanX/navicat-keygen-tools/tree/windows">https://github.com/HeQuanX/navicat-keygen-tools/tree/windows</a></p>
<h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><ol>
<li><p>请确保你有 <strong>Visual Studio 2019</strong> 或者更高版本。因为这是一个VS2019项目。</p>
</li>
<li><p>请确保你安装了 <code>vcpkg</code> 以及下面几个库：</p>
<ul>
<li><code>capstone[x86]:x64-windows-static</code></li>
<li><code>capstone[x86]:x86-windows-static</code></li>
<li><code>keystone:x64-windows-static</code></li>
<li><code>keystone:x86-windows-static</code></li>
<li><code>openssl-windows:x64-windows-static</code></li>
<li><code>openssl-windows:x86-windows-static</code></li>
<li><code>rapidjson:x64-windows-static</code></li>
<li><code>rapidjson:x86-windows-static</code></li>
</ul>
<p>你可以通过下面的命令来安装它们：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ vcpkg install capstone[x86]:x64-windows-static</span><br><span class="line">$ vcpkg install capstone[x86]:x86-windows-static</span><br><span class="line">$ vcpkg install keystone:x64-windows-static</span><br><span class="line">$ vcpkg install keystone:x86-windows-static</span><br><span class="line">$ vcpkg install openssl-windows:x64-windows-static</span><br><span class="line">$ vcpkg install openssl-windows:x86-windows-static</span><br><span class="line">$ vcpkg install rapidjson:x64-windows-static</span><br><span class="line">$ vcpkg install rapidjson:x86-windows-static</span><br></pre></td></tr></table></figure>
</li>
<li><p>你的 <code>vcpkg</code> 已经和你的 <strong>Visual Studio</strong> 集成了，即你曾成功运行了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ vcpkg integrate install</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><ol>
<li><p>在 <strong>Visual Studio</strong> 打开这个项目。</p>
</li>
<li><p>选择 <code>Release</code> 配置。</p>
</li>
<li><p>选择 <code>Win32</code> 来生成供32位Navicat使用的keygen&#x2F;patcher。</p>
<p>或者选择 <code>x64</code> 来生成供64位Navicat使用的keygen&#x2F;patcher。</p>
</li>
<li><p>选择 <strong>生成 &gt; 生成解决方案</strong>。</p>
</li>
</ol>
<p>生成完成后，你会在 <code>bin/</code> 文件夹下看到编译后的<code>keygen/patcher</code>。</p>
<h3 id="免编译"><a href="#免编译" class="headerlink" title="免编译"></a>免编译</h3><p>如果你懒得编译，可以下载我编译好的程序，<a href="http://file.onebug.tech/?/%E8%BD%AF%E4%BB%B6%E5%88%86%E4%BA%AB/navicat-keygen-for-x64.zip">下载地址</a>。</p>
<h2 id="激活navicat"><a href="#激活navicat" class="headerlink" title="激活navicat"></a>激活navicat</h2><p>在cmd中执行，打开cmd, 进入激活程序的目录，执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">navicat-patcher.exe <span class="string">&quot;C:\Program Files\PremiumSoft\ Premium 15&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>navicat-patcher.exe</code>是编译生成的激活程序，<code>&quot;C:\Program Files\PremiumSoft\Navicat Premium 15&quot;</code>要替换成自己的Navicat Premium的安装路径 。</p>
<p>然后执行命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">navicat-keygen.exe -text .\RegPrivateKey.pem</span><br></pre></td></tr></table></figure>

<p>输入编号选择你下载的Navicat的具体版本，然后选择语言和版本号。剩下的name和organization随便填写。</p>
<p>复制激活工具生成的<code>Serial number</code> ，注意先不要关闭cmd窗口。此时断开网络，打开刚刚安装的Navicat，点击注册，把<code>Serial number</code> 粘贴上去。</p>
<p>再次打开刚刚的cmd窗口，把得到的请求码粘贴上去。按两次回车(产生一个空行)，就会得到一个<code>Activation Code</code>, 把这个码粘贴到需要输入激活码的地方，点击激活即可。</p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>激活工具</tag>
        <tag>navicat</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>用 VSCode + Wsl 搭建 linux 开发环境</title>
    <url>/2020/10/20/%E8%BD%AF%E4%BB%B6/vscode%E4%BD%BF%E7%94%A8wsl/</url>
    <content><![CDATA[<p>使用vscode + Wsl 可以改善C++&#x2F;C的开发体验</p>
<p><img src="https://code.visualstudio.com/assets/docs/remote/wsl/architecture-wsl.png" alt="WSL Architecture"></p>
<span id="more"></span>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><ul>
<li><a href="https://docs.microsoft.com/zh-cn/windows/wsl/install-win10">安装 WSL</a></li>
<li>在 Windows 端(不是在 WSL 中)安装 <a href="https://code.visualstudio.com/">Vs Code</a></li>
</ul>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><ul>
<li><p>安装Vs Code扩展<a href="https://aka.ms/vscode-remote/download/extension">Remote Development extension pack</a></p>
</li>
<li><p>在<strong>WSL端</strong>安装C++&#x2F;C 语言扩展（以下是我个人安装的一些扩展）</p>
<p><img src="http://image.onebug.tech/image-20201021222529606.png-d" alt="image-20201021222529606"></p>
</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="初始化项目文件夹"><a href="#初始化项目文件夹" class="headerlink" title="初始化项目文件夹"></a>初始化项目文件夹</h3><ul>
<li><p>打开vscode</p>
</li>
<li><p><code>F1</code>-&gt;<code>Remote-WSL: New Window</code> ，或者点击左下角的绿色按钮</p>
<p><img src="http://image.onebug.tech/image-20201021222425486.png-d" alt="image-20201021222425486"></p>
</li>
<li><p>新建bash终端，使用<code>mkdir</code>等命令新建项目文件夹</p>
</li>
</ul>
<p><img src="http://image.onebug.tech/image-20201021222133299.png-d" alt="image-20201021222133299"></p>
<ul>
<li>菜单<code>文件</code>-&gt;<code>打开文件夹</code></li>
<li><img src="http://image.onebug.tech/image-20201021222248879.png-d" alt="image-20201021222248879"></li>
</ul>
<h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><ul>
<li><p>新建测试文件<code>test.cpp</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	std::cout&lt;&lt;<span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在安装<code>code runner</code>扩展的前提下，<code>右键</code>- &gt;<code>run code</code>，可以看到，成功运行</p>
</li>
</ul>
<p><img src="http://image.onebug.tech/image-20201021222646711.png-d" alt="image-20201021222646711"></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>vscode</tag>
        <tag>wsl</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>使用ventoy制作多系统启动盘</title>
    <url>/2020/09/22/%E8%BD%AF%E4%BB%B6/ventoy/</url>
    <content><![CDATA[<h2 id="ventoy介绍"><a href="#ventoy介绍" class="headerlink" title="ventoy介绍"></a>ventoy介绍</h2><p>Ventoy是一个制作可启动U盘的开源工具。有了Ventoy你就无需反复地格式化U盘，你<strong>只需要把ISO&#x2F;WIM&#x2F;IMG&#x2F;VHD(x)&#x2F;EFI文件拷贝到U盘</strong>里面就可以启动了，无需其他操作。 你可以一次性拷贝很<strong>多个</strong>不同类型的ISO文件，在启动时Ventoy会显示一个菜单来选择。</p>
<span id="more"></span>

<p><img src="http://image.onebug.tech/screen_uefi.png" alt="img"></p>
<p>ventoy能够无差异支持Legacy BIOS和UEFI模式，并且支持大部分常见操作系统 （Windows&#x2F;WinPE&#x2F;Linux&#x2F;Unix&#x2F;VMware&#x2F;Xen 等等）</p>
<h2 id="制作启动盘"><a href="#制作启动盘" class="headerlink" title="制作启动盘"></a>制作启动盘</h2><p>在<a href="https://www.lanzoux.com/b01bd54gb">这里</a>，下载安装包，例如 ventoy-1.0.15-windows.zip 然后解压开。直接执行 <code>Ventoy2Disk.exe</code> 如下图所示，选择U盘设备，然后点击 Install 按钮即可。</p>
<p><img src="http://image.onebug.tech/ventoy2disk2_cn.png" alt="img"></p>
<blockquote>
<p><strong>选择安装的时候，U盘将会被格式化，里面所有的数据都会丢失！！！</strong></p>
</blockquote>
<h2 id="启动盘的使用"><a href="#启动盘的使用" class="headerlink" title="启动盘的使用"></a>启动盘的使用</h2><p>你只需要把ISO文件拷贝到这里面即可。你可以把ISO文件放在<strong>任意目录以及子目录</strong>下。 Ventoy默认会遍历所有的目录和子目录，找出所有的ISO文件，并按照字母排序之后显示在菜单中。需要注意的是，<strong>ISO文件的全路径中(包括目录、子目录和文件名)不能包含中文或者空格</strong>。</p>
<p>至于如何从u盘启动系统，可以自行搜索关键词<strong>电脑型号+U盘启动</strong>，比如我用的是的华为matebook，就可以搜索<strong>华为matebook u盘启动</strong>。</p>
<p><img src="http://image.onebug.tech/image-20200922141917108.png" alt="image-20200922141917108"></p>
]]></content>
      <categories>
        <category>系统</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>多系统</tag>
        <tag>U盘</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA IO流详解</title>
    <url>/2021/05/06/java/javaIO/Java%20IO%E6%B5%81/</url>
    <content><![CDATA[<h1 id="JAVA-IO流"><a href="#JAVA-IO流" class="headerlink" title="JAVA IO流"></a>JAVA IO流</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h3><p>数据的传输，可以看做是一种数据的流动，按照流动的方向，<strong>以内存为基准</strong>，分为输入Input 和输出Output ，即流向内存是输入流，流出内存的输出流，统称为 IO流。 Java中I&#x2F;O操作主要是指使用java.io包下的内容，进行输入、输出操作。输入也叫做读取数据，输出也叫做作写出数据。</p>
<h3 id="流"><a href="#流" class="headerlink" title="流"></a>流</h3><p>流代表任何有能力产出数据的数据源对象或者是有能力接受数据的接收端对象；流的本质是数据传输，我们根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。流的具体作用是数据源和目的地建立一个输送通道。</p>
<span id="more"></span>

<h4 id="流的分类"><a href="#流的分类" class="headerlink" title="流的分类"></a>流的分类</h4><p><strong>流向</strong></p>
<p>根据数据流向不同分为：</p>
<ul>
<li><p>输入流：读取外部数据（磁盘、网卡等设备的数据）到程序（内存）中。如InputStream，Reader</p>
</li>
<li><p>输出流：把程序（内存）中的内容输出到磁盘、网卡设备中。如OutputStream、Writer</p>
</li>
</ul>
<p><strong>类型</strong></p>
<p>根据处理数据类型的不同分为：</p>
<ul>
<li>字节流：可以用于读写包括二进制文件在内的任何类型文件。</li>
<li>字符流：可以用于读写文本文件</li>
</ul>
<p><strong>功能</strong></p>
<p>根据功能的不同分为：</p>
<ul>
<li>节点流：可以从或向一个特定的地方（节点）读写数据。如FileInputStream，FileReader。</li>
<li>处理流：是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写。如BufferedReader。处理流的构造方法总是要带一个其他的流对象做参数。一个流对象经过其他流的多次包装，称为流的链接。</li>
</ul>
<h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p>Java I&#x2F;O 使用了装饰者模式来实现。以 InputStream 为例：</p>
<ul>
<li>InputStream 是抽象组件；</li>
<li>FileInputStream 是 InputStream 的子类，属于具体组件，提供了字节流的输入操作；</li>
<li>FilterInputStream 属于抽象装饰者，装饰者用于装饰组件，为组件提供额外的功能。例如 BufferedInputStream 为 FileInputStream 提供缓存的功能</li>
</ul>
<p><img src="http://image.onebug.tech/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39373039363934622d646230352d346363652d386432662d3163386230396634643932312e706e67" alt="img"></p>
<p>实例化一个具有缓存功能的字节流对象时，只需要在 FileInputStream 对象上再套一层 BufferedInputStream 对象即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath);</span><br><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">bufferedInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(fileInputStream);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a href="https://www.cnblogs.com/xrq730/p/4908940.html">Java设计模式12：装饰器模式 - 五月的仓颉 - 博客园 (cnblogs.com)</a></p>
</blockquote>
<h3 id="编码与解码"><a href="#编码与解码" class="headerlink" title="编码与解码"></a>编码与解码</h3><p>编码就是把字符转换为字节，而解码是把字节重新组合成字符。如果编码和解码过程使用不同的编码方式，就出现了乱码。</p>
<p>编码与解码的过程需要遵循某种规则，这种规则就是不同的字符编码。我们在刚刚学习编程的时候最早接触就是ASCII码，它主要是用来显示英文和一些符号，到后面还有接触到别的编码规则常用的有：gb2312，gbk，utf-8等。它们分别属于不同的编码集。</p>
<p>我们需要明确的是字符编码和字符集是两个不同层面的概念。</p>
<ul>
<li>encoding是charset encoding的简写，即字符集编码，简称编码。</li>
<li>charset是character set的简写，即字符集。</li>
</ul>
<p>编码是依赖于字符集的，<strong>一个字符集可以有多个编码实现</strong>，就像代码中的接口实现依赖于接口一样。</p>
<p>String 可以看成一个字符序列，可以指定一个编码方式将它编码为字节序列，也可以指定一个编码方式将一个字节序列解码为 String。如果不指定编码解码方式，默认的编码解码方式与平台有关，一般为 UTF-8。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;中文&quot;</span>;</span><br><span class="line"><span class="comment">//编码</span></span><br><span class="line"><span class="type">byte</span>[] bytes = str1.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//解码</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">System.out.println(str2);</span><br></pre></td></tr></table></figure>

<h2 id="JAVA-IO流结构"><a href="#JAVA-IO流结构" class="headerlink" title="JAVA IO流结构"></a>JAVA IO流结构</h2><p>Java IO流中所有的接口和类都放在java.io这个包下。其中最重要的就是5个类和一个接口：</p>
<ul>
<li>File（文件特征与管理）：File类是对文件系统中文件以及文件夹进行封装的对象，可以通过对象的思想来操作文件和文件夹。 File类保存文件或目录的各种元数据信息，包括文件名、文件长度、最后修改时间、是否可读、获取当前文件的路径名，判断指定文件是否存在、获得当前目录中的文件列表，创建、删除文件和目录等方法。 </li>
<li>InputStream（二进制格式操作）：抽象类，基于字节的输入操作，是所有输入流的父类。定义了所有输入流都具有的共同特征。</li>
<li>OutputStream（二进制格式操作）：抽象类。基于字节的输出操作。是所有输出流的父类。定义了所有输出流都具有的共同特征。</li>
<li>Reader（文件格式操作）：抽象类，基于字符的输入操作。</li>
<li>Writer（文件格式操作）：抽象类，基于字符的输出操作。</li>
<li>RandomAccessFile（随机文件操作）：一个独立的类，直接继承至Object.它的功能丰富，可以从文件的任意位置进行存取（输入输出）操作。</li>
<li>Serializable（序列化操作）：是一个空接口，为对象提供标准的序列化与反序列化操作。</li>
</ul>
<p>Java IO流的整体架构图如下：</p>
<p><img src="http://image.onebug.tech/IO%E6%B5%81.png" alt="IO流"></p>
<h2 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h2><p>File类是文件和目录路径名的抽象表示形式，主要用于文件和目录的创建、查找和删除等操作。即Java中把文件或者目录（文件夹）都封装成File对象。也就是说如果我们要去操作硬盘上的文件或者目录只要创建File这个类即可。不过要注意的是File类只是对文件的操作类，只能对文件本身进行操作，不能对文件内容进行操作。</p>
<h3 id="File类常用方法"><a href="#File类常用方法" class="headerlink" title="File类常用方法"></a>File类常用方法</h3><p><strong>获取文件的相关信息</strong></p>
<ul>
<li>String getAbsolutePath() ：获取绝对路径名字符串。</li>
<li>String getName()：获取文件或目录的名称。</li>
<li>String getPath()：获取路径名字符串。</li>
<li>String getParent() ：获取路径名父目录的路径名字符串；如果此路径名没有指定父目录，则返回 null。</li>
<li>Long lastModified()：获取最后一次修改的时间（返回毫秒）。</li>
<li>Long length()：获取文件的长度，如果表示目录则返回值未指定。</li>
</ul>
<p><strong>判断功能</strong></p>
<ul>
<li>Boolean isDirectory()：判断此路径是否为一个目录</li>
<li>Boolean isFile()：判断是否为一个文件</li>
<li>Boolean exists()：判断文件或目录是否存在</li>
<li>Boolean canExecute()：判断文件是否可执行</li>
<li>Boolean canRead()：判断文件是否可读</li>
<li>Boolean canWrite()：判断文件是否可写</li>
<li>Boolean isHidden()：判断是否为隐藏文件</li>
</ul>
<p><strong>新建和删除</strong></p>
<ul>
<li>Boolean createNewFile（）：创建文件，如果文件存在则不创建，返回false，反之返回true。</li>
<li>Boolean mkdir（）：创建文件目录。如果此文件目录存在则不创建，如果此文件目录的上层目录不存在也不创建。</li>
<li>Boolean mkdirs（）： 创建文件目录。如果上层文件目录不存在也会创建。</li>
<li>Boolean delete（）：删除的文件或目录。如果目录下有文件或目录则不会删除。</li>
</ul>
<p><strong>目录下文件的获取</strong></p>
<ul>
<li>String[] list（）：返回一个字符串数组，获取指定目录下的所有文件或者目录名称的数组。</li>
<li>File[] listFiles（）：返回一个抽象路径名数组，获取指定目录下的所有文件或者目录的File数组。</li>
</ul>
<p><strong>重命名文件</strong></p>
<ul>
<li>Boolean renameTo(File dest)：把文件重命名到指定路径。</li>
</ul>
<h3 id="目录递归"><a href="#目录递归" class="headerlink" title="目录递归"></a>目录递归</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归地列出一个目录下所有文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">listAllFiles</span><span class="params">(File dir)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (dir == <span class="literal">null</span> || !dir.exists()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dir.isFile()) &#123;</span><br><span class="line">        System.out.println(dir.getName());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (File file : dir.listFiles()) &#123;</span><br><span class="line">        listAllFiles(file);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字节操作"><a href="#字节操作" class="headerlink" title="字节操作"></a>字节操作</h2><p>无论是文本、图片、音频还是视频，所有的文件都是以二进制（字节）形式存在的，IO流中针对字节的输入输出提供了一系列的流，统称为字节流。字节流是程序中最常用的流。</p>
<h3 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h3><p>InputStream是所有字节输入流的父类，定义了所有字节输入流都具有的共同特征。其内部提供的方法如下（重点关注**read()**方法）：</p>
<table>
<thead>
<tr>
<th align="left">变量和类型</th>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>int</code></td>
<td align="left"><code>available()</code></td>
<td align="left">返回可以从此输入流中无阻塞地读取（或跳过）的字节数的估计值，可以是0，或者在检测到流结束时为0。</td>
</tr>
<tr>
<td align="left"><code>void</code></td>
<td align="left"><code>close()</code></td>
<td align="left">关闭此输入流并释放与该流关联的所有系统资源。</td>
</tr>
<tr>
<td align="left"><code>void</code></td>
<td align="left"><code>mark(int readlimit)</code></td>
<td align="left">标记此输入流中的当前位置。</td>
</tr>
<tr>
<td align="left"><code>boolean</code></td>
<td align="left"><code>markSupported()</code></td>
<td align="left">测试此输入流是否支持 <code>mark</code>和 <code>reset</code>方法。</td>
</tr>
<tr>
<td align="left"><code>static InputStream</code></td>
<td align="left"><code>nullInputStream()</code></td>
<td align="left">返回一个不读取任何字节的新 <code>InputStream</code> 。</td>
</tr>
<tr>
<td align="left"><code>abstract int</code></td>
<td align="left"><code>read()</code></td>
<td align="left">从输入流中读取下一个数据字节，如果没有字节可用，因为已经到达了流的末端，则返回值-1。<strong>这个方法会阻塞，直到输入数据可用</strong>，检测到流的结束，或者抛出一个异常。</td>
</tr>
<tr>
<td align="left"><code>int</code></td>
<td align="left"><code>read(byte[] b)</code></td>
<td align="left">从输入流中读取一些字节数并将它们存储到缓冲区数组 <code>b</code></td>
</tr>
<tr>
<td align="left"><code>int</code></td>
<td align="left"><code>read(byte[] b, int off, int len)</code></td>
<td align="left">从输入流 <code>len</code>最多 <code>len</code>字节的数据读入一个字节数组。</td>
</tr>
<tr>
<td align="left"><code>byte[]</code></td>
<td align="left"><code>readAllBytes()</code></td>
<td align="left">从输入流中读取所有剩余字节。</td>
</tr>
<tr>
<td align="left"><code>int</code></td>
<td align="left"><code>readNBytes(byte[] b, int off, int len)</code></td>
<td align="left">从输入流中读取请求的字节数到给定的字节数组中。</td>
</tr>
<tr>
<td align="left"><code>byte[]</code></td>
<td align="left"><code>readNBytes(int len)</code></td>
<td align="left">从输入流中读取指定的字节数。</td>
</tr>
<tr>
<td align="left"><code>void</code></td>
<td align="left"><code>reset()</code></td>
<td align="left">将此流重新定位到上次在此输入流上调用 <code>mark</code>方法时的位置。</td>
</tr>
<tr>
<td align="left"><code>long</code></td>
<td align="left"><code>skip(long n)</code></td>
<td align="left">跳过并丢弃此输入流中的 <code>n</code>字节数据。</td>
</tr>
<tr>
<td align="left"><code>long</code></td>
<td align="left"><code>transferTo(OutputStream out)</code></td>
<td align="left">从该输入流中读取所有字节，并按读取顺序将字节写入给定的输出流。</td>
</tr>
</tbody></table>
<h3 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h3><p>OutputStream是所有字节输出流的父类，定义了所有字节输出流都具有的共同特征。其内部提供的方法如下（重点关注<strong>write</strong>方法）：</p>
<table>
<thead>
<tr>
<th align="left">变量和类型</th>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>void</code></td>
<td align="left"><code>close()</code></td>
<td align="left">关闭此输出流并释放与此流关联的所有系统资源。</td>
</tr>
<tr>
<td align="left"><code>void</code></td>
<td align="left"><code>flush()</code></td>
<td align="left">刷新此输出流并强制写出任何缓冲的输出字节。</td>
</tr>
<tr>
<td align="left"><code>static OutputStream</code></td>
<td align="left"><code>nullOutputStream()</code></td>
<td align="left">返回一个新的 <code>OutputStream</code> ，它丢弃所有字节。</td>
</tr>
<tr>
<td align="left"><code>void</code></td>
<td align="left"><code>write(byte[] b)</code></td>
<td align="left">将 <code>b.length</code>字节从指定的字节数组写入此输出流。</td>
</tr>
<tr>
<td align="left"><code>void</code></td>
<td align="left"><code>write(byte[] b, int off, int len)</code></td>
<td align="left">将从偏移量 <code>off</code>开始的指定字节数组中的 <code>len</code>字节写入此输出流。</td>
</tr>
<tr>
<td align="left"><code>abstract void</code></td>
<td align="left"><code>write(int b)</code></td>
<td align="left">将指定的字节写入此输出流。</td>
</tr>
</tbody></table>
<h3 id="文件复制"><a href="#文件复制" class="headerlink" title="文件复制"></a>文件复制</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyFile</span><span class="params">(String src, String dist)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(src);</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dist);</span><br><span class="line"></span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">20</span> * <span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read() 最多读取 buffer.length 个字节</span></span><br><span class="line">    <span class="comment">// 返回的是实际读取的个数</span></span><br><span class="line">    <span class="comment">// 返回 -1 的时候表示读到 eof，即文件尾</span></span><br><span class="line">    <span class="keyword">while</span> ((cnt = in.read(buffer, <span class="number">0</span>, buffer.length)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        out.write(buffer, <span class="number">0</span>, cnt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    in.close();</span><br><span class="line">    out.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符操作"><a href="#字符操作" class="headerlink" title="字符操作"></a>字符操作</h2><h3 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h3><p> Reader是所有字符输入流的父类，定义了所有字符输入流都具有的共同特征。其内部提供的方法如下：</p>
<table>
<thead>
<tr>
<th align="left">变量和类型</th>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>abstract void</code></td>
<td align="left"><code>close()</code></td>
<td align="left">关闭流并释放与其关联的所有系统资源。</td>
</tr>
<tr>
<td align="left"><code>void</code></td>
<td align="left"><code>mark(int readAheadLimit)</code></td>
<td align="left">标记流中的当前位置。</td>
</tr>
<tr>
<td align="left"><code>boolean</code></td>
<td align="left"><code>markSupported()</code></td>
<td align="left">判断此流是否支持mark（）操作。</td>
</tr>
<tr>
<td align="left"><code>static Reader</code></td>
<td align="left"><code>nullReader()</code></td>
<td align="left">返回不读取任何字符的新 <code>Reader</code> 。</td>
</tr>
<tr>
<td align="left"><code>int</code></td>
<td align="left"><code>read()</code></td>
<td align="left">读一个字符。</td>
</tr>
<tr>
<td align="left"><code>int</code></td>
<td align="left"><code>read(char[] cbuf)</code></td>
<td align="left">将字符读入数组。</td>
</tr>
<tr>
<td align="left"><code>abstract int</code></td>
<td align="left"><code>read(char[] cbuf, int off, int len)</code></td>
<td align="left">将字符读入数组的一部分。</td>
</tr>
<tr>
<td align="left"><code>int</code></td>
<td align="left"><code>read(CharBuffer target)</code></td>
<td align="left">尝试将字符读入指定的字符缓冲区。</td>
</tr>
<tr>
<td align="left"><code>boolean</code></td>
<td align="left"><code>ready()</code></td>
<td align="left">判断此流是否可以读取。</td>
</tr>
<tr>
<td align="left"><code>void</code></td>
<td align="left"><code>reset()</code></td>
<td align="left">重置流。</td>
</tr>
<tr>
<td align="left"><code>long</code></td>
<td align="left"><code>skip(long n)</code></td>
<td align="left">跳过字符。</td>
</tr>
<tr>
<td align="left"><code>long</code></td>
<td align="left"><code>transferTo(Writer out)</code></td>
<td align="left">读取此阅读器中的所有字符，并按照读取的顺序将字符写入给定的编写器。</td>
</tr>
</tbody></table>
<h3 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h3><p> Reader是所有字符输出流的父类，定义了所有字符输出流都具有的共同特征。其内部提供的方法如下：</p>
<table>
<thead>
<tr>
<th align="left">变量和类型</th>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>Writer</code></td>
<td align="left"><code>append(char c)</code></td>
<td align="left">将指定的字符追加到此writer。</td>
</tr>
<tr>
<td align="left"><code>Writer</code></td>
<td align="left"><code>append(CharSequence csq)</code></td>
<td align="left">将指定的字符序列追加到此writer。</td>
</tr>
<tr>
<td align="left"><code>Writer</code></td>
<td align="left"><code>append(CharSequence csq, int start, int end)</code></td>
<td align="left">将指定字符序列的子序列追加到此writer。</td>
</tr>
<tr>
<td align="left"><code>abstract void</code></td>
<td align="left"><code>close()</code></td>
<td align="left">关闭流，先冲洗它。</td>
</tr>
<tr>
<td align="left"><code>abstract void</code></td>
<td align="left"><code>flush()</code></td>
<td align="left">刷新流。</td>
</tr>
<tr>
<td align="left"><code>static Writer</code></td>
<td align="left"><code>nullWriter()</code></td>
<td align="left">返回一个新的 <code>Writer</code> ，它丢弃所有字符。</td>
</tr>
<tr>
<td align="left"><code>void</code></td>
<td align="left"><code>write(char[] cbuf)</code></td>
<td align="left">写一个字符数组。</td>
</tr>
<tr>
<td align="left"><code>abstract void</code></td>
<td align="left"><code>write(char[] cbuf, int off, int len)</code></td>
<td align="left">写一个字符数组的一部分。</td>
</tr>
<tr>
<td align="left"><code>void</code></td>
<td align="left"><code>write(int c)</code></td>
<td align="left">写一个字符。</td>
</tr>
<tr>
<td align="left"><code>void</code></td>
<td align="left"><code>write(String str)</code></td>
<td align="left">写一个字符串。</td>
</tr>
<tr>
<td align="left"><code>void</code></td>
<td align="left"><code>write(String str, int off, int len)</code></td>
<td align="left">写一个字符串的一部分。</td>
</tr>
</tbody></table>
<h3 id="实现逐行输出文本文件的内容"><a href="#实现逐行输出文本文件的内容" class="headerlink" title="实现逐行输出文本文件的内容"></a>实现逐行输出文本文件的内容</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readFileContent</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">FileReader</span> <span class="variable">fileReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(filePath);</span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(fileReader);</span><br><span class="line"></span><br><span class="line">    String line;</span><br><span class="line">    <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.println(line);</span><br><span class="line">    &#125;</span><br><span class="line">    bufferedReader.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对象操作"><a href="#对象操作" class="headerlink" title="对象操作"></a>对象操作</h2><h3 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h3><p>序列化就是将一个对象转换成字节序列，方便存储和传输。</p>
<ul>
<li>序列化：ObjectOutputStream.writeObject()</li>
<li>反序列化：ObjectInputStream.readObject()</li>
</ul>
<p>不会对静态变量进行序列化，因为序列化只是保存对象的状态，静态变量属于类的状态。</p>
<h3 id="transient"><a href="#transient" class="headerlink" title="transient"></a>transient</h3><p>transient 关键字可以使一些属性不会被序列化。</p>
<p>ArrayList 中存储数据的数组 elementData 是用 transient 修饰的，因为这个数组是动态扩展的，并不是所有的空间都被使用，因此就不需要所有的内容都被序列化。通过重写序列化和反序列化方法，使得可以只序列化数组中有内容的那部分数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;</span><br></pre></td></tr></table></figure>

<h3 id="Serializable示例"><a href="#Serializable示例" class="headerlink" title="Serializable示例"></a>Serializable示例</h3><p>序列化的类需要实现 Serializable 接口，它只是一个标准，没有任何方法需要实现，但是如果不去实现它的话而进行序列化，会抛出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">A</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>(<span class="number">123</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">objectFile</span> <span class="operator">=</span> <span class="string">&quot;file/a1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(objectFile));</span><br><span class="line">    objectOutputStream.writeObject(a1);</span><br><span class="line">    objectOutputStream.close();</span><br><span class="line"></span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(objectFile));</span><br><span class="line">    <span class="type">A</span> <span class="variable">a2</span> <span class="operator">=</span> (A) objectInputStream.readObject();</span><br><span class="line">    objectInputStream.close();</span><br><span class="line">    System.out.println(a2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> String y;</span><br><span class="line"></span><br><span class="line">    A(<span class="type">int</span> x, String y) &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;x = &quot;</span> + x + <span class="string">&quot;  &quot;</span> + <span class="string">&quot;y = &quot;</span> + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h2><p>缓冲流也叫高效流，是处理流的一种，即是作用在流上的流。其目的就是加快读取和写入数据的速度。</p>
<p>缓冲流本身并没有IO功能，只是在别的流上加上缓冲效果从而提高了效率。当对文件或其他目标频繁读写或操作效率低，效能差时。这时使用缓冲流能够更高效的读写信息。因为缓冲流先将数据缓存起来，然后一起写入或读取出来。所以说，缓冲流还是很重要的，在IO操作时加上缓冲流提升性能。</p>
<p> Java IO流中对应的缓冲流有以下四个：</p>
<ul>
<li><p>字节缓冲流：BufferedInputStream、BufferedOutputStream</p>
</li>
<li><p>字符缓冲流：BufferedReader、BufferedWriter</p>
</li>
</ul>
<p>实例化一个具有缓存功能的字节流对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath);</span><br><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">bufferedInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(fileInputStream);</span><br></pre></td></tr></table></figure>

<h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><p>转换流也是一种处理流，它提供了字节流和字符流之间的转换。在Java IO流中提供了两个转换流：InputStreamReader 和 OutputStreamWriter，这两个类都属于字符流。其中InputStreamReader将字节输入流转为字符输入流，继承自Reader。OutputStreamWriter是将字符输出流转为字节输出流，继承自Writer。</p>
<p>转换流的原理是：<strong>字符流 &#x3D; 字节流 + 编码表</strong>。在转换流中选择正确的编码非常的重要，因为指定了编码，它所对应的字符集自然就指定了，否则很容易出现乱码，所以编码才是我们最终要关心的。</p>
<p><img src="https://img2020.cnblogs.com/blog/1745215/202103/1745215-20210328205030750-1032064608.png" alt="img"></p>
<h3 id="InputStreamReader"><a href="#InputStreamReader" class="headerlink" title="InputStreamReader"></a>InputStreamReader</h3><p>InputStreamReader是字节流到字符流的桥梁：它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。</p>
<p>构造方法：</p>
<ul>
<li>InputStreamReader(InputStream in)：创建一个默认字符集字符输入流。</li>
<li>InputStreamReader(InputStream in, String charsetName)：创建一个指定字符集的字符流。</li>
</ul>
<h3 id="OutputStreamWriter"><a href="#OutputStreamWriter" class="headerlink" title="OutputStreamWriter"></a>OutputStreamWriter</h3><p>OutputStreamWriter是字符流通向字节流的桥梁：用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。</p>
<p>构造方法：</p>
<ul>
<li>OutputStreamWriter(OutputStream in): 创建一个使用默认字符集的字符流。</li>
<li>OutputStreamWriter(OutputStream in, String charsetName): 创建一个指定字符集的字符流。</li>
</ul>
<h3 id="转换文件编码"><a href="#转换文件编码" class="headerlink" title="转换文件编码"></a>转换文件编码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将读入UTF-8文件转换为GBK</span></span><br><span class="line"><span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;utf8.txt&quot;</span>),<span class="string">&quot;UTF-8&quot;</span>);;</span><br><span class="line"><span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;gbk.txt&quot;</span>),<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="type">char</span>[] buffer = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">while</span> ((len=isr.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">	osw.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>javaio</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>IO</tag>
        <tag>网络编程</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux IO 模式</title>
    <url>/2021/05/07/java/javaIO/Linux%20IO%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="Linux-IO模式"><a href="#Linux-IO模式" class="headerlink" title="Linux IO模式"></a>Linux IO模式</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="用户空间与内核空间"><a href="#用户空间与内核空间" class="headerlink" title="用户空间与内核空间"></a>用户空间与内核空间</h3><p>现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对Linux操作系统而言，将最高的1G字节（从虚拟地址<code>0xC0000000</code>到<code>0xFFFFFFFF</code>），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址<code>0x00000000</code>到<code>0xBFFFFFFF</code>），供各个进程使用，称为用户空间。</p>
<p>每个进程可以通过系统调用进入内核，因此，Linux内核由系统内的所有进程共享。于是，从具体进程的角度来看，每个进程可以拥有4G字节的虚拟空间。</p>
<p><img src="http://image.onebug.tech/29f80b4c7e9aa6f9dd77da9721433cf5.png" alt="Linux 内核空间与用户空间_程序地带"></p>
<span id="more"></span>

<h3 id="文件描述符fd"><a href="#文件描述符fd" class="headerlink" title="文件描述符fd"></a>文件描述符fd</h3><p>文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。</p>
<p>文件描述符在形式上是一个非负整数。实际上，它是<strong>一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表</strong>。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p>
<blockquote>
<p>Socket：正如应用程序使用文件描述符访问文件一样，应用程序也使用套接字描述符(socket descriptors )访问套接字。<strong>套接字描述符在 UNIX 系统中作为文件描述符实现</strong>，这也符合UNIX系统“一切皆文件”的设计思想。</p>
</blockquote>
<h3 id="缓存-I-x2F-O"><a href="#缓存-I-x2F-O" class="headerlink" title="缓存 I&#x2F;O"></a>缓存 I&#x2F;O</h3><p>缓存 IO 又被称作标准 IO，大多数文件系统的默认 IO 操作都是缓存 IO。在 Linux 的缓存 IO 机制中，操作系统会将 IO 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。</p>
<p><img src="http://image.onebug.tech/image-20210507184156017.png" alt="image-20210507184156017"></p>
<h2 id="Linux-IO-模式"><a href="#Linux-IO-模式" class="headerlink" title="Linux IO 模式"></a>Linux IO 模式</h2><p>对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生时，它会经历<strong>两个阶段</strong>：</p>
<ol>
<li><strong>等待数据准备 (Waiting for the data to be ready)</strong></li>
<li><strong>将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)</strong></li>
</ol>
<p>在整个请求过程中，数据输入至buffer需要时间，而从buffer复制数据至进程也需要时间。因此根据在这两段时间内等待方式的不同，I&#x2F;O动作可以分为以下五种模式：</p>
<ul>
<li>阻塞 I&#x2F;O（blocking IO）</li>
<li>非阻塞 I&#x2F;O（nonblocking IO）</li>
<li>I&#x2F;O 多路复用（ IO multiplexing）</li>
<li>信号驱动 I&#x2F;O（ signal driven IO）</li>
<li>异步 I&#x2F;O（asynchronous IO）</li>
</ul>
<blockquote>
<p>由于signal driven IO在实际中并不常用，这里不做介绍。</p>
</blockquote>
<p>在数据传输的过程中，避免数据在操作系统内核地址空间的缓冲区和用户应用程序地址空间的缓冲区之间进行拷贝。有的时候，应用程序在数据进行传输的过程中不需要对数据进行访问，那么，将数据从 Linux 的页缓存拷贝到用户进程的缓冲区中就可以完全避免，传输的数据在页缓存中就可以得到处理。在某些特殊的情况下，这种零拷贝技术可以获得较好的性能。Linux 中提供类似的系统调用主要有 <code>mmap()</code>，<code>sendfile()</code> 以及 <code>splice()</code>。</p>
<p>如果使用<code>mmap()</code>，磁盘上的数据会通过 <code>DMA</code>被拷贝的内核缓冲区，接着操作系统会把这段内核缓冲区与应用程序共享，这样就不需要把内核缓冲区的内容往用户空间拷贝。应用程序调用 <code>write()</code>时，操作系统直接将内核缓冲区的内容拷贝到 <code>socket</code>缓冲区中，这一切都发生在内核态，最后， <code>socket</code>缓冲区再把数据发到网卡去。相对于<code>read()</code>很明显减少了一次拷贝，当拷贝数据量很大时，无疑提升了效率。</p>
<p><img src="http://image.onebug.tech/image-20210507184628247.png" alt="image-20210507184628247"></p>
<h3 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a>阻塞IO</h3><p>在Linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样：</p>
<p><img src="http://image.onebug.tech/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f313439323932383431363831325f342e706e67" alt="img"></p>
<p>当用户进程调用了<code>recvfrom</code>这个系统调用，kernel就开始了IO的第一个阶段：准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的，而在用户进程这边，整个进程会被阻塞。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除阻塞的状态，重新运行起来。</p>
<p>所以，所以，阻塞IO的特点就是<strong>在IO执行的两个阶段都被block了。</strong></p>
<h3 id="非阻塞-I-x2F-O"><a href="#非阻塞-I-x2F-O" class="headerlink" title="非阻塞 I&#x2F;O"></a>非阻塞 I&#x2F;O</h3><p>Linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子</p>
<p><img src="http://image.onebug.tech/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f313439323932393030303336315f352e706e67" alt="img"></p>
<p>当用户进程调用<code>recvfrom</code>时，系统不会阻塞用户进程，而是立刻返回一个<code>ewouldblock</code>错误，从用户进程角度讲 ，并不需要等待，而是马上就得到了一个结果。用户进程判断标志是<code>ewouldblock</code>时，就知道数据还没准备好，于是它就可以去做其他的事了，于是它可以再次发送<code>recvfrom</code>，一旦内核中的数据准备好了。并且又再次收到了用户进程的系统，那么它马上就将数据拷贝到了用户内存，然后返回。</p>
<p>当一个应用程序在一个循环里对一个非阻塞调用<code>recvfrom</code>，我们称为轮询。应用程序不断轮询内核，看看是否已经准备好了某些操作。这通常是浪费CPU时间，但这种模式偶尔会遇到。</p>
<h3 id="I-x2F-O-复用"><a href="#I-x2F-O-复用" class="headerlink" title="I&#x2F;O 复用"></a>I&#x2F;O 复用</h3><p>IO multiplexing就是我们说的select，poll，epoll，有时候也称这种IO方式为事件驱动IO（event driven IO）。select&#x2F;epoll的好处就在于单个进程就可以同时处理多个网络连接的IO。当某个socket有数据到达了，就通知用户进程。</p>
<p><img src="http://image.onebug.tech/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f313439323932393434343831385f362e706e67" alt="img"></p>
<p>当用户进程调用了select，那么整个进程会被阻塞，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</p>
<p>这个图和阻塞IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要进行两次系统调用 (select 和 <code>recvfrom</code>)，而阻塞IO只进行一次系统调用 (<code>recvfrom</code>)。但是，用select的优势在于它可以同时处理多个连接。</p>
<p>所以处理的连接数不是很高的话，使用【select&#x2F;epoll】的服务器不一定比使用【多线程 + 阻塞IO】的web server性能更好，可能延迟还更大。</p>
<p>在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。</p>
<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>基本原理：select 函数监视的文件描述符分3类，分别是<code>writefds</code>、<code>readfds</code>、和<code>exceptfds</code>。调用后select函数会阻塞，直到有描述符就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以通过<strong>遍历</strong><code>fdset</code>，来找到就绪的描述符。</p>
<p>缺点:</p>
<ul>
<li>select最大的缺陷就是<strong>单个进程所打开的FD是有一定限制的</strong>，它由<code>FDSETSIZE</code>设置，32位机默认是1024个，64位机默认是2048。 一般来说这个数目和系统内存关系很大</li>
<li>对socket进行扫描时是<strong>线性扫描，效率较低</strong>。 当套接字比较多的时候，每次select()都要通过遍历<code>FDSETSIZE</code>个Socket来完成调度，不管哪个Socket是活跃的，都遍历一遍。这会浪费很多CPU时间。</li>
<li>需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时<strong>复制开销大</strong>。</li>
</ul>
<h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>poll本质上和select基本没有区别。特点是<strong>没有最大连接数的限制，原因是它是基于链表来存储的</strong>，但是线性遍历和复制开销大的缺点仍然存在。poll还有一个特点是“水平触发”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。</p>
<p>事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，如果采用线性遍历方式，随着监视的描述符数量的增长，其效率也会线性下降。</p>
<blockquote>
<p>水平触发模式（level trigger）：当检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用会再次响应应用程序并通知此事件。<br>边缘触发模式（edge trigger）：当检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用时，不会再次响应应用程序并通知此事件。</p>
</blockquote>
<h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p>epoll是在Linux 2.6内核中提出的，是之前的select和poll的增强版本。相对于select和poll来说，epoll更加灵活：</p>
<ul>
<li><p>没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）</p>
</li>
<li><p>效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。 只有活跃可用的FD才会调用callback函数；即epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关</p>
</li>
<li><p>内存拷贝，利用<code>mmap()</code>文件映射内存加速与内核空间的消息传递，减少了无用的复制</p>
</li>
<li><p>epoll支持水平触发和边缘触发</p>
</li>
</ul>
<blockquote>
<p>JDK1.5_update10版本使用epoll替代了传统的select&#x2F;poll，极大的提升了NIO通信的性能。</p>
</blockquote>
<h3 id="异步I-x2F-O"><a href="#异步I-x2F-O" class="headerlink" title="异步I&#x2F;O"></a>异步I&#x2F;O</h3><p>应用进程执行 <code>aio_read</code> 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。</p>
<p>异步 I&#x2F;O 与信号驱动 I&#x2F;O 的区别在于，异步 I&#x2F;O 的信号是通知应用进程 I&#x2F;O 完成，而信号驱动 I&#x2F;O 的信号是通知应用进程可以开始 I&#x2F;O。</p>
<p><img src="http://image.onebug.tech/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f313439323933303234333238365f382e706e67" alt="img"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>同步 I&#x2F;O：将数据从内核缓冲区复制到应用进程缓冲区的阶段（第二阶段），应用进程会阻塞。</li>
<li>异步 I&#x2F;O：第二阶段应用进程不会阻塞。</li>
</ul>
<p>同步 I&#x2F;O 包括阻塞式 I&#x2F;O、非阻塞式 I&#x2F;O、I&#x2F;O 复用和信号驱动 I&#x2F;O ，它们的主要区别在第一个阶段。</p>
<p>非阻塞式 I&#x2F;O 、信号驱动 I&#x2F;O 和异步 I&#x2F;O 在第一阶段不会阻塞。</p>
<p>从同步、异步，以及阻塞、非阻塞两个维度来划分来看，IO模式可以分为：</p>
<p><img src="http://image.onebug.tech/image-20210507185322599.png" alt="image-20210507185322599"></p>
]]></content>
      <categories>
        <category>javaio</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>java</tag>
        <tag>IO</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA NIO</title>
    <url>/2021/05/08/java/javaIO/java%20NIO%E4%B8%8ESelector/</url>
    <content><![CDATA[<h1 id="JAVA-NIO"><a href="#JAVA-NIO" class="headerlink" title="JAVA NIO"></a>JAVA NIO</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java NIO 由以下几个核心部分组成：</p>
<ul>
<li>Channels</li>
<li>Buffers</li>
<li>Selectors</li>
</ul>
<p>虽然Java NIO 中除此之外还有很多类和组件，但在我看来，Channel，Buffer 和 Selector 构成了核心的API。其它组件，如Pipe和FileLock，只不过是与三个核心组件共同使用的工具类。</p>
<p>基本上，所有的 IO 在NIO 中都从一个Channel 开始。Channel，国内大多翻译成“通道”，有点像流。 不同的是，数据可以从Channel读到Buffer中，也可以从Buffer 写到Channel中。</p>
<p>Selector允许单线程处理多个 Channel。如果你的应用打开了多个连接（通道），但每个连接的流量都很低，使用Selector就会很方便。</p>
<span id="more"></span>

<h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><p><strong>发送给一个通道的所有数据都必须首先放到缓冲区中，同样地，从通道中读取的任何数据都要先读到缓冲区中</strong>。也就是说，不会直接对通道进行读写数据，而是要先经过缓冲区。缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问该块内存。</p>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>Java NIO 有以下Buffer类型</p>
<ul>
<li>ByteBuffer</li>
<li>MappedByteBuffer</li>
<li>CharBuffer</li>
<li>DoubleBuffer</li>
<li>FloatBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>ShortBuffer</li>
</ul>
<p>这些Buffer类型代表了不同的数据类型。换句话说，就是可以通过char，short，int，long，float 或 double类型来操作缓冲区中的字节。</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p><strong>基本用法</strong></p>
<p>使用Buffer读写数据一般遵循以下四个步骤：</p>
<ol>
<li><p>写入数据到Buffer</p>
</li>
<li><p>调用<code>flip()</code>方法，从写模式切换到读模式，在读模式下，可以读取之前写入到buffer的所有数据。</p>
</li>
<li><p>从Buffer中读取数据</p>
</li>
<li><p>调用<code>clear()</code>方法或者<code>compact()</code>方法，清空缓冲区</p>
<blockquote>
<p>clear()方法会清空整个缓冲区。compact()方法只会清除已经读过的数据。任何未读的数据都被移到缓冲区的起始处，新写入的数据将放到缓冲区未读数据的后面。</p>
</blockquote>
</li>
</ol>
<p><strong>Buffer的分配</strong></p>
<p>要想获得一个Buffer对象首先要进行分配。 每一个Buffer类都有一个allocate方法。下面是一个分配48字节capacity的ByteBuffer的例子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">48</span>);</span><br></pre></td></tr></table></figure>

<p><strong>向Buffer中写入数据</strong></p>
<p>写数据到Buffer有两种方式：</p>
<ul>
<li><p>从Channel写到Buffer。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">bytesRead</span> <span class="operator">=</span> inChannel.read(buf); <span class="comment">//read into buffer.</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过Buffer的put()方法写到Buffer里，put方法有很多版本，允许你以不同的方式把数据写入到Buffer中。例如， 写到一个指定的位置，或者把一个字节数组写入到Buffer。 更多Buffer实现的细节参考JavaDoc。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">buf.put(<span class="number">127</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>读取数据</strong></p>
<p>从Buffer中读取数据有两种方式：</p>
<ul>
<li>从Buffer读取数据到Channel。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//read from buffer into channel.</span></span><br><span class="line"><span class="type">int</span> <span class="variable">bytesWritten</span> <span class="operator">=</span> inChannel.write(buf);</span><br></pre></td></tr></table></figure>

<ul>
<li>使用get()方法从Buffer中读取数据，get方法有很多版本，允许你以不同的方式从Buffer中读取数据。例如，从指定position读取，或者从Buffer中读取数据到字节数组。更多Buffer实现的细节参考JavaDoc。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">aByte</span> <span class="operator">=</span> buf.get();</span><br></pre></td></tr></table></figure>

<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>Buffer简单地理解为一组基本数据类型的元素列表，它通过几个变量来保存这个数据的当前位置状态：</p>
<table>
<thead>
<tr>
<th><strong>索引</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>capacity</td>
<td>缓冲区数组的总长度</td>
</tr>
<tr>
<td>position</td>
<td>下一个要操作的数据元素的位置</td>
</tr>
<tr>
<td>limit</td>
<td>缓冲区数组中不可操作的下一个元素的位置：limit&lt;&#x3D;capacity</td>
</tr>
</tbody></table>
<p>状态变量的改变过程举例：</p>
<p>① 通过<code>ByteBuffer.allocate(8)</code>新建一个大小为 8 个字节的缓冲区，此时 position 为 0，而 limit &#x3D; capacity &#x3D; 8。capacity 变量不会改变，下面的讨论会忽略它。</p>
<p><img src="http://image.onebug.tech/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f31626561333938662d313761372d346636372d613930622d3965326432343365616139612e706e67" alt="img"></p>
<p>② 从输入通道中读取 5 个字节数据写入缓冲区中，此时 position 为 5，limit 保持不变。</p>
<p><img src="http://image.onebug.tech/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38303830346635322d383831352d343039362d623530362d3438656566336565643563362e706e67" alt="img"></p>
<p>③ 在将缓冲区的数据写到输出通道之前，需要先调用 flip() 方法，这个方法将 limit 设置为当前 position，并将 position 设置为 0。</p>
<p><img src="http://image.onebug.tech/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39353265303662642d356136352d346361622d383265342d6464313533363436326633382e706e67" alt="img"></p>
<p>④ 从缓冲区中取 4 个字节到输出缓冲中，此时 position 设为 4。</p>
<p><img src="http://image.onebug.tech/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f62356264636265322d623935382d346165662d393135312d3661643936336362323862342e706e67" alt="img"></p>
<p>⑤ 最后需要调用 clear() 方法来清空缓冲区，此时 position 和 limit 都被设置为最初位置。</p>
<p><img src="http://image.onebug.tech/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36376266353438372d633435642d343962362d623963302d6130353864386336383930322e706e67" alt="img"></p>
<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>Java NIO的通道类似流，但又有些不同：</p>
<ul>
<li>既可以从通道中读取数据，又可以写数据到通道。但流的读写通常是单向的。</li>
<li>通道可以异步地读写。</li>
<li>通道中的数据总是要先读到一个Buffer，或者总是要从一个Buffer中写入。</li>
</ul>
<p>正如上面所说，从通道读取数据到缓冲区，从缓冲区写入数据到通道。如下图所示：</p>
<p><img src="http://image.onebug.tech/overview-channels-buffers.png" alt="img"></p>
<p>这些是Java NIO中最重要的通道的实现：</p>
<ul>
<li>FileChannel 从文件中读写数据</li>
<li>DatagramChannel 能通过UDP读写网络中的数据</li>
<li>SocketChannel  能通过TCP读写网络中的数据</li>
<li>ServerSocketChannel 可以监听新进来的TCP连接，像Web服务器那样。对每一个新进来的连接都会创建一个SocketChannel</li>
</ul>
<h3 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h3><p>Java NIO中的FileChannel是一个连接到文件的通道。可以通过文件通道读写文件。FileChannel无法设置为非阻塞模式，它总是运行在阻塞模式下。</p>
<p><strong>打开</strong></p>
<p>在使用FileChannel之前，必须先打开它。但是，我们无法直接打开一个FileChannel，需要通过使用一个InputStream、OutputStream或RandomAccessFile来获取一个FileChannel实例。下面是通过RandomAccessFile打开FileChannel的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RandomAccessFile aFile = new RandomAccessFile(&quot;data/nio-data.txt&quot;, &quot;rw&quot;);</span><br><span class="line">FileChannel inChannel = aFile.getChannel();</span><br></pre></td></tr></table></figure>

<p><strong>读取</strong></p>
<p>打开FileChannel后，调用多个read()方法之一从FileChannel中读取数据。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">bytesRead</span> <span class="operator">=</span> inChannel.read(buf);</span><br></pre></td></tr></table></figure>

<p>首先，分配一个Buffer。从FileChannel中读取的数据将被读到Buffer中。然后，调用<code>FileChannel.read()</code>方法。该方法将数据从FileChannel读取到Buffer中。<strong>read()方法返回的int值表示了有多少字节被读到了Buffer中</strong>。如果返回**-1，表示到了文件末尾**。</p>
<p><strong>写入</strong></p>
<p>使用<code>FileChannel.write()</code>方法向FileChannel写数据，该方法的参数是一个Buffer：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">newData</span> <span class="operator">=</span> <span class="string">&quot;New String to write to file...&quot;</span> + System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">buf.clear();</span><br><span class="line">buf.put(newData.getBytes());</span><br><span class="line"></span><br><span class="line">buf.flip();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(buf.hasRemaining()) &#123;</span><br><span class="line">	channel.write(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意<code>FileChannel.write()</code>是在while循环中调用的。因为无法保证write()方法一次能向FileChannel写入多少字节，因此需要重复调用write()方法，直到Buffer中已经没有尚未写入通道的字节。</p>
<p><strong>读文件示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">nioReadFile</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="type">RandomAccessFile</span> <span class="variable">file</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">try</span>&#123;</span><br><span class="line">           aFile = <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;test.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">           <span class="type">FileChannel</span> <span class="variable">fileChannel</span> <span class="operator">=</span> aFile.getChannel();</span><br><span class="line">           <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">           <span class="type">int</span> <span class="variable">bytesRead</span> <span class="operator">=</span> fileChannel.read(buf);</span><br><span class="line">           System.out.println(bytesRead);</span><br><span class="line">           <span class="keyword">while</span>(bytesRead != -<span class="number">1</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               buf.flip();</span><br><span class="line">               <span class="keyword">while</span>(buf.hasRemaining())</span><br><span class="line">               &#123;</span><br><span class="line">                   System.out.print((<span class="type">char</span>)buf.get());</span><br><span class="line">               &#125;</span><br><span class="line">               buf.compact();</span><br><span class="line">               bytesRead = fileChannel.read(buf);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">           <span class="keyword">try</span>&#123;</span><br><span class="line">               <span class="keyword">if</span>(aFile != <span class="literal">null</span>)&#123;</span><br><span class="line">                   aFile.close();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h3><p>Java NIO中的SocketChannel是一个连接到TCP网络套接字的通道。</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p><strong>打开</strong></p>
<p>可以通过以下2种方式创建SocketChannel：</p>
<ul>
<li><p>打开一个SocketChannel并连接到互联网上的某台服务器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">socketChannel.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8081</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>一个新连接到达ServerSocketChannel时，会创建一个SocketChannel。</p>
</li>
</ul>
<p><strong>从 SocketChannel 读取数据</strong></p>
<p>要从SocketChannel中读取数据，和FileChannel一样，需要结合Buffer使用，调用read()的方法。以下是例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">bytesRead</span> <span class="operator">=</span> socketChannel.read(buf);</span><br></pre></td></tr></table></figure>

<p><strong>写入 SocketChannel</strong></p>
<p>写数据到SocketChannel用的是<code>SocketChannel.write()</code>方法，该方法以一个Buffer作为参数。示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">newData</span> <span class="operator">=</span> <span class="string">&quot;New String to write to file...&quot;</span> + System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">buf.clear();</span><br><span class="line">buf.put(newData.getBytes());</span><br><span class="line"></span><br><span class="line">buf.flip();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(buf.hasRemaining()) &#123;</span><br><span class="line">    channel.write(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关闭</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">socketChannel.close();</span><br></pre></td></tr></table></figure>

<h4 id="非阻塞模式"><a href="#非阻塞模式" class="headerlink" title="非阻塞模式"></a>非阻塞模式</h4><p>NIO的强大功能部分来自于Channel的非阻塞特性，套接字的某些操作可能会无限期地阻塞。例如，对accept()方法的调用可能会因为等待一个客户端连接而阻塞；对read()方法的调用可能会因为没有数据可读而阻塞，直到连接的另一端传来新的数据。总的来说，创建&#x2F;接收连接或读写数据等I&#x2F;O调用，都可能无限期地阻塞等待，直到底层的网络实现发生了什么。慢速的，有损耗的网络，或仅仅是简单的网络故障都可能导致任意时间的延迟。然而不幸的是，在调用一个方法之前无法知道其是否阻塞。NIO的channel抽象的一个重要特征就是可以通过配置它的阻塞行为，以实现非阻塞式的信道。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">channel.configureBlocking(false)</span><br></pre></td></tr></table></figure>

<p>在非阻塞式信道上调用一个方法总是会立即返回。这种调用的返回值指示了所请求的操作完成的程度：</p>
<ul>
<li>非阻塞模式下，write()方法在尚未写出任何内容时可能就返回了。所以需要在循环中调用write()。</li>
<li>非阻塞模式下,read()方法在尚未读取到任何数据时可能就返回了。所以需要关注它的int返回值，它会告诉你读取了多少字节。</li>
<li>在非阻塞模式下，调用connect()，该方法可能在连接建立之前就返回了。为了确定连接是否建立，可以调用<code>finishConnect()</code>的方法。</li>
</ul>
<p>非阻塞模式与选择器搭配会工作的更好，通过将一或多个SocketChannel注册到Selector，可以询问选择器哪个通道已经准备好了读取，写入等。</p>
<p><strong>NIO客户端</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">client</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">       <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">try</span></span><br><span class="line">       &#123;</span><br><span class="line">           socketChannel = SocketChannel.open();</span><br><span class="line">           socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">           socketChannel.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;10.10.195.115&quot;</span>,<span class="number">8080</span>));</span><br><span class="line">           <span class="keyword">if</span>(socketChannel.finishConnect())</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">               <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">               &#123;</span><br><span class="line">                   TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                   <span class="type">String</span> <span class="variable">info</span> <span class="operator">=</span> <span class="string">&quot;I&#x27;m &quot;</span>+i+++<span class="string">&quot;-th information from client&quot;</span>;</span><br><span class="line">                   buffer.clear();</span><br><span class="line">                   buffer.put(info.getBytes());</span><br><span class="line">                   buffer.flip();</span><br><span class="line">                   <span class="keyword">while</span>(buffer.hasRemaining())&#123;</span><br><span class="line">                       System.out.println(buffer);</span><br><span class="line">                       socketChannel.write(buffer);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">catch</span> (IOException | InterruptedException e)</span><br><span class="line">       &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">finally</span>&#123;</span><br><span class="line">           <span class="keyword">try</span>&#123;</span><br><span class="line">               <span class="keyword">if</span>(socketChannel!=<span class="literal">null</span>)&#123;</span><br><span class="line">                   socketChannel.close();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="ServerSocketChannel"><a href="#ServerSocketChannel" class="headerlink" title="ServerSocketChannel"></a>ServerSocketChannel</h3><p>Java NIO中的 ServerSocketChannel 是一个可以监听新进来的TCP连接的通道, 就像标准IO中的ServerSocket一样。</p>
<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p><strong>打开 ServerSocketChannel</strong></p>
<p>通过调用 <code>ServerSocketChannel.open()</code> 方法来打开ServerSocketChannel.如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">serverSocketChannel.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">9999</span>));</span><br></pre></td></tr></table></figure>

<p><strong>监听连接</strong></p>
<p>通过 <code>ServerSocketChannel.accept()</code> 方法监听新进来的连接。当 accept()方法返回的时候,它返回一个包含新进来的连接的 SocketChannel。因此, accept()方法会一直阻塞到有新连接到达。</p>
<p>通常不会仅仅只监听一个连接,在while循环中调用 accept()方法. 如下面的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span></span><br><span class="line">            serverSocketChannel.accept();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//do something with socketChannel...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ServerSocketChannel可以设置成非阻塞模式。在非阻塞模式下，accept() 方法会立刻返回，如果还没有新进来的连接,返回的将是null。 因此，需要检查返回的SocketChannel是否是null.如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">serverSocketChannel.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">9999</span>));</span><br><span class="line">serverSocketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span></span><br><span class="line">            serverSocketChannel.accept();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(socketChannel != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//do something with socketChannel...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关闭 ServerSocketChannel</strong></p>
<p>通过调用<code>ServerSocketChannel.close()</code> 方法来关闭</p>
<h2 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h2><p>对于操作系统来说，线程之间上下文切换的开销很大，而且每个线程都要占用系统的一些资源（如内存）。Selector（选择器）能够检测一到多个NIO通道，并能够知晓通道是否为诸如读写事件做好准备的组件。一个单独的线程可以管理多个channel，从而管理多个网络连接。Selector类可以用于避免使用阻塞式客户端中很浪费资源的“忙等”方法。</p>
<p><img src="http://image.onebug.tech/overview-selectors.png" alt="img"></p>
<h3 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h3><p><strong>创建</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br></pre></td></tr></table></figure>

<p><strong>向Selector注册通道</strong><br>为了将Channel和Selector配合使用，必须将channel注册到selector上。通过<code>SelectableChannel.register()</code>方法来实现，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"><span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> channel.register(selector,Selectionkey.OP_READ);</span><br></pre></td></tr></table></figure>

<p>与Selector一起使用时，Channel必须处于非阻塞模式下。这意味着不能将FileChannel与Selector一起使用，因为FileChannel不能切换到非阻塞模式。而套接字通道都可以。</p>
<p>注意register()方法的第二个参数。这是一个“interest集合”，意思是在通过Selector监听Channel时对什么事件感兴趣。通道触发了一个事件意思是该事件已经就绪，可以监听四种不同类型的事件：</p>
<ul>
<li><code>SelectionKey.OP_CONNECT</code> ： 某个channel成功连接到另一个服务器称为“连接就绪”</li>
<li><code>SelectionKey.OP_ACCEPT</code>：一个ServerSocketchannel准备好接收新进入的连接称为“接收就绪”。</li>
<li><code>SelectionKey.OP_READ</code>：一个有数据可读的通道可以说是“读就绪”。</li>
<li><code>SelectionKey.OP_WRITE</code>：等待写数据的通道可以说是“写就绪”。</li>
</ul>
<p>如果你对不止一种事件感兴趣，那么可以用“位或”操作符将常量连接起来，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">interestSet</span> <span class="operator">=</span> SelectionKey.OP_READ | SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure>

<p><strong>通过Selector选择通道</strong></p>
<p>一旦向Selector注册了一或多个通道，就可以调用几个重载的select()方法。这些方法返回你所感兴趣的事件（如连接、接受、读或写）已经准备就绪的那些通道。换句话说，如果你对“读就绪”的通道感兴趣，select()方法会返回读事件已经就绪的那些通道。</p>
<ul>
<li>int select()：阻塞到至少有一个通道在你注册的事件上就绪了。</li>
<li>int select(long timeout)：和select()一样，除了最长会阻塞timeout毫秒(参数)。</li>
<li>int selectNow()：不会阻塞，不管什么通道就绪都立刻返回</li>
</ul>
<p><strong>获取已选择键值</strong></p>
<p>一旦调用了select()方法，并且返回值表明有一个或更多个通道就绪了，然后可以通过调用selector的<code>selectedKeys()</code>方法，访问“已选择键集（selected key set）”中的就绪通道。如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Set</span> <span class="variable">selectedKeys</span> <span class="operator">=</span> selector.selectedKeys();</span><br></pre></td></tr></table></figure>

<p>当像Selector注册Channel时，<code>Channel.register()</code>方法会返回一个SelectionKey 对象。这个对象代表了注册到该Selector的通道（token）。可以通过SelectionKey的selectedKeySet()方法访问这些对象。</p>
<p>可以遍历这个已选择的键集合来访问就绪的通道。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Set</span> <span class="variable">selectedKeys</span> <span class="operator">=</span> selector.selectedKeys();</span><br><span class="line"><span class="type">Iterator</span> <span class="variable">keyIterator</span> <span class="operator">=</span> selectedKeys.iterator();</span><br><span class="line"><span class="keyword">while</span>(keyIterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> keyIterator.next();</span><br><span class="line">    <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was accepted by a ServerSocketChannel.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was established with a remote server.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for reading</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for writing</span></span><br><span class="line">    &#125;</span><br><span class="line">    keyIterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个循环遍历已选择键集中的每个键，并检测各个键所对应的通道的就绪事件。注意每次迭代末尾的<code>keyIterator.remove()</code>调用。Selector不会自己从已选择键集中移除SelectionKey实例。必须在处理完通道时自己移除，否则下次该通道变成就绪时，Selector会再次将其放入已选择键集中。</p>
<h3 id="SelectionKey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a>SelectionKey</h3><p>当向Selector注册Channel时，register()方法会返回一个SelectionKey对象，代表SelectableChannel与Selector的注册的token。这个对象包含了一些属性：</p>
<ul>
<li>interest集合</li>
<li>ready集合</li>
<li>Channel</li>
<li>Selector</li>
<li>附加的对象（可选）</li>
</ul>
<p><strong>interest</strong></p>
<p>interest集合是你所选择的感兴趣的事件集合。可以通过SelectionKey读写interest集合，像这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">interestSet</span> <span class="operator">=</span> selectionKey.interestOps();</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isInterestedInConnect</span> <span class="operator">=</span> interestSet &amp; SelectionKey.OP_CONNECT;</span><br></pre></td></tr></table></figure>

<p><strong>ready集合</strong></p>
<p>ready 集合是通道已经准备就绪的操作的集合。在一次选择(Selection)之后，你会首先访问这个ready set。Selection将在下一小节进行解释。可以这样访问ready集合：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int readySet = selectionKey.readyOps();</span><br></pre></td></tr></table></figure>

<p>可以用像检测interest集合那样的方法，来检测channel中什么事件或操作已经就绪。但是，也可以使用以下四个方法，它们都会返回一个布尔类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">selectionKey.isAcceptable();</span><br><span class="line">selectionKey.isConnectable();</span><br><span class="line">selectionKey.isReadable();</span><br><span class="line">selectionKey.isWritable();</span><br></pre></td></tr></table></figure>

<p><strong>Channel、Selector</strong></p>
<p>从SelectionKey访问对应的Channel和Selector很简单。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Channel</span>  <span class="variable">channel</span>  <span class="operator">=</span> selectionKey.channel();</span><br><span class="line"><span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> selectionKey.selector();</span><br></pre></td></tr></table></figure>

<p><strong>附加对象</strong></p>
<p>可以将一个对象或者更多信息附着到SelectionKey上，这样就能方便的识别某个给定的通道。例如，可以附加 与通道一起使用的Buffer，或是包含聚集数据的某个对象。使用方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">selectionKey.attach(theObject);</span><br><span class="line"><span class="type">Object</span> <span class="variable">attachedObj</span> <span class="operator">=</span> selectionKey.attachment();</span><br></pre></td></tr></table></figure>

<p>还可以在用register()方法向Selector注册Channel的时候附加对象。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> channel.register(selector, SelectionKey.OP_READ, theObject);</span><br></pre></td></tr></table></figure>

<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerConnect</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> BUF_SIZE=<span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">8080</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TIMEOUT</span> <span class="operator">=</span> <span class="number">3000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        selector();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleAccept</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">ssChannel</span> <span class="operator">=</span> (ServerSocketChannel)key.channel();</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> ssChannel.accept();</span><br><span class="line">        sc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        sc.register(key.selector(), SelectionKey.OP_READ,ByteBuffer.allocateDirect(BUF_SIZE));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleRead</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> (SocketChannel)key.channel();</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuffer)key.attachment();</span><br><span class="line">        <span class="type">long</span> <span class="variable">bytesRead</span> <span class="operator">=</span> sc.read(buf);</span><br><span class="line">        <span class="keyword">while</span>(bytesRead&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            buf.flip();</span><br><span class="line">            <span class="keyword">while</span>(buf.hasRemaining())&#123;</span><br><span class="line">                System.out.print((<span class="type">char</span>)buf.get());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            buf.clear();</span><br><span class="line">            bytesRead = sc.read(buf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(bytesRead == -<span class="number">1</span>)&#123;</span><br><span class="line">            sc.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleWrite</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuffer)key.attachment();</span><br><span class="line">        buf.flip();</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">        <span class="keyword">while</span>(buf.hasRemaining())&#123;</span><br><span class="line">            sc.write(buf);</span><br><span class="line">        &#125;</span><br><span class="line">        buf.compact();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selector</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            ssc= ServerSocketChannel.open();</span><br><span class="line">            ssc.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(PORT));</span><br><span class="line">            ssc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(selector.select(TIMEOUT) == <span class="number">0</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;==&quot;</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();</span><br><span class="line">                <span class="keyword">while</span>(iter.hasNext())&#123;</span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                    <span class="keyword">if</span>(key.isAcceptable())&#123;</span><br><span class="line">                        handleAccept(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">                        handleRead(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(key.isWritable() &amp;&amp; key.isValid())&#123;</span><br><span class="line">                        handleWrite(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(key.isConnectable())&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;isConnectable = true&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    iter.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(selector!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    selector.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(ssc!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    ssc.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>javaio</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>网络编程</tag>
        <tag>NIO</tag>
        <tag>Selector</tag>
      </tags>
  </entry>
  <entry>
    <title>java UDP网络编程</title>
    <url>/2021/05/08/java/javaIO/java%20UDP/</url>
    <content><![CDATA[<h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><p>在 TCP&#x2F;IP 协议的传输层除了一个 TCP 协议之外，还有一个 UDP 协议。UDP 协议是用户数据报协议的简称，也用于网络数据的传输。虽然 UDP 协议是一种不太可靠的协议，但有时在需要较快地接收数据并且可以忍受较小错误的情况下，UDP 就会表现出更大的优势。</p>
<p>下面是在 <a href="http://c.biancheng.net/java/">Java</a> 中使用 UDP 协议发送数据的步骤。</p>
<ol>
<li>使用 DatagramSocket() 创建一个数据包套接字。</li>
<li>使用 DatagramPacket() 创建要发送的数据包。</li>
<li>使用 DatagramSocket 类的 send() 方法发送数据包。</li>
</ol>
<p>接收 UDP 数据包的步骤如下：</p>
<ul>
<li>使用 DatagramSocket 创建数据包套接字，并将其绑定到指定的端口。</li>
<li>使用 DatagramPacket 创建字节数组来接收数据包。</li>
<li>使用 DatagramPacket 类的 receive() 方法接收 UDP 包。</li>
</ul>
<span id="more"></span>

<h2 id="DatagramPacket-类"><a href="#DatagramPacket-类" class="headerlink" title="DatagramPacket 类"></a>DatagramPacket 类</h2><p>java.net 包中的 DatagramPacket 类用来表示数据报包，数据报包用来实现无连接包投递服务。每条报文仅根据该包中包含的信息从一台机器路由到另一台机器。从一台机器发送到另一台机器的多个包可能选择不同的路由，也可能按不同的顺序到达。</p>
<table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>DatagramPacket(byte[] buf,int length)</td>
<td>构造 DatagramPacket，用来接收长度为 length 的数据包。</td>
</tr>
<tr>
<td>DatagramPacket(byte[] buf,int offset, int length)</td>
<td>构造 DatagramPacket，用来接收长度为 length 的包，在缓 冲区中指定了偏移量。</td>
</tr>
<tr>
<td>DatagramPacket(byte[] buf,int length, InetAddress address,int port)</td>
<td>构造 DatagramPacket，用来将长度为 length 的包发送到指定主机上的指定端口。</td>
</tr>
<tr>
<td>DatagramPacket(byte[] buf,int length, SocketAddress address)</td>
<td>构造数据报包，用来将长度为 length 的包发送到指定主机上 的指定端口。</td>
</tr>
<tr>
<td>DatagramPacket(byte[] buf,int offset, int length,InetAddress address,int port)</td>
<td>构造 DatagramPacket，用来将长度为 length 偏移量为 offset 的包发送到指定主机上的指定端口。</td>
</tr>
<tr>
<td>DatagramPacket(byte[] buf,int offset, int length,SocketAddress address)</td>
<td>构造数据报包，用来将长度为 length、偏移量为 offset 的包发 送到指定主机上的指定端口。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>InetAddress getAddress()</td>
<td>返回某台机器的 IP 地址，此数据报将要发往该机器或者 从该机器接收。</td>
</tr>
<tr>
<td>byte[] getData()</td>
<td>返回数据缓冲区。</td>
</tr>
<tr>
<td>int getLength()</td>
<td>返回将要发送或者接收的数据的长度。</td>
</tr>
<tr>
<td>int getOffset()</td>
<td>返回将要发送或者接收的数据的偏移量。</td>
</tr>
<tr>
<td>int getPort()</td>
<td>返回某台远程主机的端口号，此数据报将要发往该主机或 者从该主机接收。</td>
</tr>
<tr>
<td>getSocketAddress()</td>
<td>获取要将此包发送或者发出此数据报的远程主机的 SocketAddress（通常为 IP地址+端口号）。</td>
</tr>
<tr>
<td>void setAddress(InetAddress addr)</td>
<td>设置要将此数据报发往的目的机器的IP地址。</td>
</tr>
<tr>
<td>void setData(byte[] buf)</td>
<td>为此包设置数据缓冲区。</td>
</tr>
<tr>
<td>void setData(byte[] buf,int offset, int length)</td>
<td>为此包设置数据缓冲区。</td>
</tr>
<tr>
<td>void setLength(int length)</td>
<td>为此包设置长度。</td>
</tr>
<tr>
<td>void setPort(int port)</td>
<td>设置要将此数据报发往的远程主机的端口号。</td>
</tr>
<tr>
<td>void setSocketAddress(SocketAddress address)</td>
<td>设置要将此数据报发往的远程主机的 SocketAddress（通常为 IP地址+端口号）。</td>
</tr>
</tbody></table>
<h2 id="DatagramSocket-类"><a href="#DatagramSocket-类" class="headerlink" title="DatagramSocket 类"></a>DatagramSocket 类</h2><p>DatagramSocket 类用于表示发送和接收数据报包的套接字。数据报包套接字是包投递服务的发送或接收点。每个在数据报包套接字上发送或接收的包都是单独编址和路由的。从一台机器发送到另一台机器的多个包可能选择不同的路由，也可能按不同的顺序到达。</p>
<table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>DatagramSocket()</td>
<td>构造数据报包套接字并将其绑定到本地主机上任何可用的端口。</td>
</tr>
<tr>
<td>DatagramSocket(int port)</td>
<td>创建数据报包套接字并将其绑定到本地主机上的指定端口。</td>
</tr>
<tr>
<td>DatagramSocket(int port,InetAddressaddr)</td>
<td>创建数据报包套接字，将其绑定到指定的本地地址。</td>
</tr>
<tr>
<td>DatagramSocket(SocketAddress,bindaddr)</td>
<td>创建数据报包套接字，将其绑定到指定的本地套接字地址。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void bind(SocketAddress addr)</td>
<td>将此 DatagramSocket 绑定到特定的地址和端口。</td>
</tr>
<tr>
<td>void close()</td>
<td>关闭此数据报包套接字。</td>
</tr>
<tr>
<td>void connect(InetAddress address,int port)</td>
<td>将套接字连接到此套接字的远程地址。</td>
</tr>
<tr>
<td>void connect(SocketAddress addr)</td>
<td>将此套接子连接到远程套接子地址（IP地址+端口号）。</td>
</tr>
<tr>
<td>void disconnect()</td>
<td>断开套接字的连接。</td>
</tr>
<tr>
<td>InetAddress getInetAddress()</td>
<td>返回此套接字连接的地址。</td>
</tr>
<tr>
<td>InetAddress getLocalAddress()</td>
<td>获取套接字绑定的本地地址。</td>
</tr>
<tr>
<td>int getLocalPort()</td>
<td>返回此套接字绑定的本地主机上的端口号。</td>
</tr>
<tr>
<td>int getPort()</td>
<td>返回此套接字的端口。</td>
</tr>
</tbody></table>
<h2 id="例"><a href="#例" class="headerlink" title="例"></a>例</h2><p>编写 UDP 程序，要求客户端程序可以向服务器端发送多条数据，服务器端程序可以接收客户端发送的多条数据并将其信息输出在控制台，主要步骤如下所示。</p>
<p><strong>客户端</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            DatagramSocket udpScoket=<span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line">            InetAddress serverAddress=InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">            <span class="type">int</span> serverPort=<span class="number">8082</span>;</span><br><span class="line"></span><br><span class="line">            DatagramPacket udPacket=<span class="literal">null</span>;</span><br><span class="line">            String[] messages=&#123;<span class="string">&quot;YOLO&quot;</span>,<span class="string">&quot;HELLO&quot;</span>,<span class="string">&quot;JUST DO IT&quot;</span>&#125;;</span><br><span class="line">            <span class="keyword">for</span> (String message:messages)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">byte</span>[] data=message.getBytes();</span><br><span class="line">                udPacket=<span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(data,data.length,serverAddress,serverPort);</span><br><span class="line">                udpScoket.send(udPacket);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            udpScoket.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(IOException | InterruptedException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>服务器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            DatagramSocket ds=<span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">8082</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;UDP服务器已启动。。。&quot;</span>);</span><br><span class="line">            DatagramPacket dpReceive;</span><br><span class="line">            <span class="type">byte</span>[] b=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span>(ds.isClosed()==<span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dpReceive=<span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(b, b.length);</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ds.receive(dpReceive);</span><br><span class="line">                    <span class="type">byte</span>[] Data=dpReceive.getData();</span><br><span class="line">                    <span class="type">int</span> len=Data.length;</span><br><span class="line">                    System.out.println(<span class="string">&quot;UDP客户端&quot;</span>+dpReceive.getSocketAddress()+<span class="string">&quot;发送的内容是：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(Data, <span class="number">0</span>, len).trim());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span>(IOException e)</span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(SocketException e1)</span><br><span class="line">        &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UDP服务器已启动。。。</span><br><span class="line">UDP客户端/127.0.0.1:64656发送的内容是：YOLO                             </span><br><span class="line">UDP客户端/127.0.0.1:64656发送的内容是：HELLO                                             </span><br><span class="line">UDP客户端/127.0.0.1:64656发送的内容是：JUST DO IT                                             </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>javaio</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>IO</tag>
        <tag>网络编程</tag>
        <tag>UDP</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Socket 编程</title>
    <url>/2021/05/07/java/javaIO/socket%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="Java-Socket-编程"><a href="#Java-Socket-编程" class="headerlink" title="Java Socket 编程"></a>Java Socket 编程</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>首先需要了解两个类：Socket和SocketServer。</p>
<h3 id="SocketServer"><a href="#SocketServer" class="headerlink" title="SocketServer"></a>SocketServer</h3><p>SocketServer实现了服务器套接字。 服务器套接字会等待通过网络进入的请求。 用户可以根据该请求执行某些操作，然后将结果返回给请求者（也可以选择不返回）。</p>
<span id="more"></span>

<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ServerSocket</span> <span class="params">(<span class="type">int</span> port, <span class="type">int</span> backlog,InetAddress bindAddr)</span></span><br></pre></td></tr></table></figure>

<p>创建具有<strong>指定端口</strong>的服务器，监听backlog和要<strong>绑定</strong>的本地IP地址。</p>
<p><strong>参数</strong></p>
<ul>
<li><code>port</code> - 绑定的本地端口号。 端口号<code>0</code>表示从临时端口范围自动分配端口号，可以通过调用<code>getLocalPort</code>来查看此端口号。</li>
<li><code>backlog</code> - 传入连接指示（连接请求）的最大队列长度，如果队列已满时连接指示到达，则拒绝连接。</li>
<li><code>bindAddr</code> - 服务器将绑定到的本地<code>InetAddress</code>， 如果<code>bindAddr</code>为null，它将默认接受任何&#x2F;所有本地地址上的连接。</li>
</ul>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ul>
<li><p><code>accept()</code>侦听对此套接字的连接并接受它。 该方法将阻塞，直到建立连接，成功建立连接后会返回一个<strong>新的Socket</strong>。</p>
</li>
<li><p><code>close()</code>关闭此套接字</p>
</li>
</ul>
<h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>该类实现客户端套接字（一般简称为“套接字”）。 套接字是两台机器之间通信的端点。</p>
<h4 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Socket</span><span class="params">(String host,<span class="type">int</span> port)</span> <span class="keyword">throws</span> UnknownHostException,IOException</span><br></pre></td></tr></table></figure>

<p>创建流套接字并将其<strong>连接</strong>到指定主机上的指定端口号。</p>
<h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h4><ul>
<li><p><code>getInputStream()</code>返回此套接字的输入流，注意关闭返回的<code>InputStream</code>将关闭关联的套接字。</p>
</li>
<li><p><code>getOutputStream()</code>返回此套接字的输出流，关闭返回的<code>OutputStream</code>将关闭关联的套接字。</p>
</li>
<li><p><code>close()</code>关闭此套接字，关闭此套接字也将关闭套接字<code>InputStream</code>和<code>OutputStream</code> 。一旦套接字关闭，进一步的网络连接就需要创建一个新的套接字。</p>
</li>
<li><p><code>shutdownInput()</code>将此套接字的输入流设置为“流结束”。 发送到套接字输入流端的任何数据都会被确认，然后以静默方式丢弃。套接字输入流<code>read</code>方法将返回<code>-1</code> （流结束）。</p>
</li>
<li><p><code>shutdownOutput()</code>禁用此套接字的输出流。 对于TCP套接字，将发送任何先前写入的数据，然后发送TCP的正常<strong>连接终止序列</strong>。 </p>
</li>
<li><p><code>isConnected()</code>返回套接字的连接状态。</p>
</li>
<li><p><code>setOption(SocketOption&lt;T&gt; name, T value)</code>设置套接字选项的值。</p>
</li>
</ul>
<h3 id="通信基本示例"><a href="#通信基本示例" class="headerlink" title="通信基本示例"></a>通信基本示例</h3><p><strong>服务端</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建具有指定端口的服务器套接字</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">8081</span>;</span><br><span class="line">        <span class="comment">//注意指定编码格式，发送方和接收方一定要统一，建议使用UTF-8</span></span><br><span class="line">        <span class="keyword">final</span> String CHARSET=<span class="string">&quot;UTF-8&quot;</span>;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(PORT);</span><br><span class="line">        SocketAddress serverAddress=server.getLocalSocketAddress();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// accept() 会阻塞进程，直到建立新连接，成功建立连接后会返回一个新的Socket。</span></span><br><span class="line">        log.info(<span class="string">&quot;Waiting for new connection(Listening on : &#123;&#125;)&quot;</span>,serverAddress);</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> server.accept();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 建立好连接后，从socket中获取输入、输出流、客户端信息</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        OutputStream outputStream=socket.getOutputStream();</span><br><span class="line">        SocketAddress clientAddress=socket.getRemoteSocketAddress();</span><br><span class="line">        log.info(<span class="string">&quot;There is a new  connection &#123;&#125;&quot;</span>,socket);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//建立缓冲区用于读取或写入</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        log.info(<span class="string">&quot;Waiting for message from client &#123;&#125; &quot;</span>,clientAddress);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//read()会阻塞进程，直到有输入，返回-1代表流结束</span></span><br><span class="line">        <span class="keyword">while</span> ((len = inputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//注意指定编码格式，发送方和接收方一定要统一，建议使用UTF-8</span></span><br><span class="line">            sb.append(<span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="number">0</span>, len,CHARSET));</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;Get a message &#x27;&#123;&#125;&#x27; from client &#123;&#125;&quot;</span> ,sb,socket.getRemoteSocketAddress());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭连接和服务器</span></span><br><span class="line">        inputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">13</span>:<span class="number">49</span>:<span class="number">01.451</span> [main] INFO cn.lbs.socket.base.SocketServer - Waiting <span class="keyword">for</span> <span class="keyword">new</span> <span class="title class_">connection</span>(Listening on : <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">8081</span>)</span><br><span class="line"><span class="number">13</span>:<span class="number">49</span>:<span class="number">06.413</span> [main] INFO cn.lbs.socket.base.SocketServer - There is a <span class="keyword">new</span>  <span class="title class_">connection</span> Socket[addr=/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>,port=<span class="number">4463</span>,localport=<span class="number">8081</span>]</span><br><span class="line"><span class="number">13</span>:<span class="number">49</span>:<span class="number">06.413</span> [main] INFO cn.lbs.socket.base.SocketServer - Waiting <span class="keyword">for</span> message from client /<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">4463</span> </span><br><span class="line"><span class="number">13</span>:<span class="number">49</span>:<span class="number">06.427</span> [main] INFO cn.lbs.socket.base.SocketServer - Get a message <span class="string">&#x27;Hello World&#x27;</span> from client /<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">4463</span></span><br></pre></td></tr></table></figure>

<p><strong>客户端</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 设置连接的服务端IP地址和端口</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HOST</span> <span class="operator">=</span> <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">8081</span>;</span><br><span class="line">        <span class="comment">//注意指定编码格式，发送方和接收方一定要统一，建议使用UTF-8</span></span><br><span class="line">        <span class="keyword">final</span> String CHARSET=<span class="string">&quot;UTF-8&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 与服务端建立连接</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(HOST, PORT);</span><br><span class="line">        <span class="comment">// 建立连接后获得输出、输出流、连接信息</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        InputStream inputStream=socket.getInputStream();</span><br><span class="line">        SocketAddress   localAddress=socket.getLocalSocketAddress();</span><br><span class="line">        SocketAddress remoteAddress=socket.getRemoteSocketAddress();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;The client &#123;&#125; successfully connects to the server &#123;&#125;&quot;</span>,localAddress,remoteAddress);</span><br><span class="line"></span><br><span class="line">        String message=<span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">        log.info(<span class="string">&quot;The client &#123;&#125; sends a message &#x27;&#123;&#125;&#x27; to the server &quot;</span>,localAddress,message);</span><br><span class="line">        socket.getOutputStream().write(message.getBytes(CHARSET));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭连接</span></span><br><span class="line">        outputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">13</span>:<span class="number">49</span>:<span class="number">06.416</span> [main] INFO cn.lbs.socket.base.SocketClient - The client /<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">4463</span> successfully connects to the server /<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8081</span></span><br><span class="line"><span class="number">13</span>:<span class="number">49</span>:<span class="number">06.426</span> [main] INFO cn.lbs.socket.base.SocketClient - The client /<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">4463</span> sends a message <span class="string">&#x27;Hello World&#x27;</span> to the server</span><br></pre></td></tr></table></figure>



<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><h3 id="双向通信基础"><a href="#双向通信基础" class="headerlink" title="双向通信基础"></a>双向通信基础</h3><p><strong>服务端</strong></p>
<p>当读取完客户端的消息后，打开输出流，将指定消息发送回客户端。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建具有指定端口的服务器套接字</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">8081</span>;</span><br><span class="line">        <span class="comment">//注意指定编码格式，发送方和接收方一定要统一，建议使用UTF-8</span></span><br><span class="line">        <span class="keyword">final</span> String CHARSET=<span class="string">&quot;UTF-8&quot;</span>;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(PORT);</span><br><span class="line">        SocketAddress serverAddress=server.getLocalSocketAddress();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// accept() 会阻塞进程，直到建立新连接，成功建立连接后会返回一个新的Socket。</span></span><br><span class="line">        log.info(<span class="string">&quot;Waiting for new connection(Listening on : &#123;&#125;)&quot;</span>,serverAddress);</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> server.accept();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 建立好连接后，从socket中获取输入、输出流、客户端信息</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        OutputStream outputStream=socket.getOutputStream();</span><br><span class="line">        SocketAddress clientAddress=socket.getRemoteSocketAddress();</span><br><span class="line">        log.info(<span class="string">&quot;There is a new  connection &#123;&#125;&quot;</span>,socket);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//建立缓冲区用于读取或写入</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        log.info(<span class="string">&quot;Waiting for message from client &#123;&#125; &quot;</span>,clientAddress);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//read()会阻塞进程，直到有输入，返回-1代表流结束</span></span><br><span class="line">        <span class="keyword">while</span> ((len = inputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//注意指定编码格式，发送方和接收方一定要统一，建议使用UTF-8</span></span><br><span class="line">            sb.append(<span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="number">0</span>, len,CHARSET));</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;Get a message &#x27;&#123;&#125;&#x27; from client &#123;&#125;&quot;</span> ,sb,socket.getRemoteSocketAddress());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        String respStr= <span class="string">&quot;Hello,I get the message&quot;</span>;</span><br><span class="line">        log.info(<span class="string">&quot;Response message &#x27;&#123;&#125;&#x27; to Client &#123;&#125; &quot;</span>,respStr,clientAddress);</span><br><span class="line">        outputStream.write(respStr.getBytes(CHARSET));</span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭连接和服务器</span></span><br><span class="line">        inputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">13:58:51.050 [main] INFO cn.lbs.socket.base.SocketServer - Waiting <span class="keyword">for</span> new connection(Listening on : 0.0.0.0/0.0.0.0:8081)</span><br><span class="line">13:58:58.706 [main] INFO cn.lbs.socket.base.SocketServer - There is a new  connection Socket[addr=/127.0.0.1,port=4554,localport=8081]</span><br><span class="line">13:58:58.706 [main] INFO cn.lbs.socket.base.SocketServer - Waiting <span class="keyword">for</span> message from client /127.0.0.1:4554 </span><br><span class="line">13:58:58.719 [main] INFO cn.lbs.socket.base.SocketServer - Get a message <span class="string">&#x27;Hello World&#x27;</span> from client /127.0.0.1:4554</span><br><span class="line">13:58:58.719 [main] INFO cn.lbs.socket.base.SocketServer - Response message <span class="string">&#x27;Hello,I get the message&#x27;</span> to Client /127.0.0.1:4554 </span><br></pre></td></tr></table></figure>

<p><strong>客户端</strong></p>
<p>客户端也有相应的变化，在发送完消息时，调用关闭输出流方法，然后打开输出流，等候服务端的消息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 设置连接的服务端IP地址和端口</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HOST</span> <span class="operator">=</span> <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">8081</span>;</span><br><span class="line">        <span class="comment">//注意指定编码格式，发送方和接收方一定要统一，建议使用UTF-8</span></span><br><span class="line">        <span class="keyword">final</span> String CHARSET=<span class="string">&quot;UTF-8&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 与服务端建立连接</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(HOST, PORT);</span><br><span class="line">        <span class="comment">// 建立连接后获得输出、输出流、连接信息</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        InputStream inputStream=socket.getInputStream();</span><br><span class="line">        SocketAddress   localAddress=socket.getLocalSocketAddress();</span><br><span class="line">        SocketAddress remoteAddress=socket.getRemoteSocketAddress();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;The client &#123;&#125; successfully connects to the server &#123;&#125;&quot;</span>,localAddress,remoteAddress);</span><br><span class="line"></span><br><span class="line">        String message=<span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">        log.info(<span class="string">&quot;The client &#123;&#125; sends a message &#x27;&#123;&#125;&#x27; to the server &quot;</span>,localAddress,message);</span><br><span class="line">        outputStream.write(message.getBytes(CHARSET));</span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//建立缓冲区用于读取或写入</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="comment">//获取响应</span></span><br><span class="line">        log.info(<span class="string">&quot;Client &#123;&#125; is  waiting for Response&quot;</span>,localAddress);</span><br><span class="line">        <span class="comment">//read()会阻塞进程，直到有输入，返回-1代表流结束</span></span><br><span class="line">        <span class="keyword">while</span> ((len = inputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//注意指定编码格式，发送方和接收方一定要统一，建议使用UTF-8</span></span><br><span class="line">            sb.append(<span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="number">0</span>, len,CHARSET));</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;Get response message &#x27;&#123;&#125;&#x27; from Server&quot;</span> , sb);</span><br><span class="line">        <span class="comment">//关闭连接</span></span><br><span class="line">        outputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">13:58:58.708 [main] INFO cn.lbs.socket.base.SocketClient - The client /127.0.0.1:4554 successfully connects to the server /127.0.0.1:8081</span><br><span class="line">13:58:58.719 [main] INFO cn.lbs.socket.base.SocketClient - The client /127.0.0.1:4554 sends a message <span class="string">&#x27;Hello World&#x27;</span> to the server </span><br><span class="line">13:58:58.719 [main] INFO cn.lbs.socket.base.SocketClient - Client /127.0.0.1:4554 is  waiting <span class="keyword">for</span> Response</span><br><span class="line">13:58:58.720 [main] INFO cn.lbs.socket.base.SocketClient - Get response message <span class="string">&#x27;Hello,I get the message&#x27;</span> from Server</span><br></pre></td></tr></table></figure>

<h3 id="发送完成告知机制"><a href="#发送完成告知机制" class="headerlink" title="发送完成告知机制"></a>发送完成告知机制</h3><h4 id="关闭Socket连接"><a href="#关闭Socket连接" class="headerlink" title="关闭Socket连接"></a>关闭Socket连接</h4><p>当Socket关闭的时候，服务端就会收到响应的关闭信号，那么服务端也就知道流已经关闭了，这个时候读取操作完成，就可以继续后续工作。但是客户端Socket关闭后，将不能接受服务端发送的消息，也不能再次发送消息。如果客户端想再次发送消息，需要重现创建Socket连接</p>
<h4 id="关闭输出流"><a href="#关闭输出流" class="headerlink" title="关闭输出流"></a>关闭输出流</h4><p>调用Socket的<code>shutdownOutput()</code>方法（不是关闭输出流<code>close()</code>，因为关闭输出流会直接关闭Socket连接），底层会告知服务端我这边已经写完了，那么服务端收到消息后，就能知道已经读取完消息，如果服务端有要返回给客户的消息那么就可以通过服务端的输出流发送给客户端。这种方式通过关闭客户端的输出流，告知服务端已经写完了，虽然可以读到服务端发送的消息，但是是不能再次发送消息给服务端，如果再次发送，需要重新建立Socket连接。</p>
<h4 id="约定符号"><a href="#约定符号" class="headerlink" title="约定符号"></a>约定符号</h4><p>就是双方约定一个字符或者一个短语，来当做消息发送完成的标识，通常这么做就需要改造读取方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> server.accept();</span><br><span class="line"><span class="comment">// 建立好连接后，从socket中获取输入流，并建立缓冲区进行读取</span></span><br><span class="line">BufferedReader read=<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream(),<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">String line;</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="keyword">while</span> ((line = read.readLine()) != <span class="literal">null</span> &amp;&amp; <span class="string">&quot;end&quot;</span>.equals(line)) &#123;</span><br><span class="line">  <span class="comment">//注意指定编码格式，发送方和接收方一定要统一，建议使用UTF-8</span></span><br><span class="line">  sb.append(line);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>优点：不需要关闭流，当发送完一条消息后可以再次发送新的命令消息</p>
</li>
<li><p>缺点：需要额外的约定结束标志，太简单的容易出现在要发送的消息中，误被结束，太复杂的不好处理，还占带宽</p>
</li>
</ul>
<h4 id="指定长度"><a href="#指定长度" class="headerlink" title="指定长度"></a>指定长度</h4><p><strong>先指定后续命令的长度</strong>，然后读取指定长度的内容做为客户端发送的消息。一般，如果用作命令发送，两个字节就够了，4个字节基本就能满足所有要求。</p>
<p><strong>服务端</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 监听指定的端口</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">8081</span>;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(port);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// server将一直等待连接的到来</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Waiting for new connection(Listening Port:&quot;</span>+server.getLocalPort()+<span class="string">&quot;)&quot;</span>);</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> server.accept();</span><br><span class="line">        System.out.println(<span class="string">&quot;There is a new connection &quot;</span>+socket);</span><br><span class="line">        <span class="comment">// 建立好连接后，从socket中获取输入流，并建立缓冲区进行读取</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] receivebytes,sendBytes;</span><br><span class="line">        <span class="comment">// 因为可以复用Socket且能判断长度，所以可以一个Socket用到底</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println();</span><br><span class="line">            System.out.println(<span class="string">&quot;Waiting for Message&quot;</span>);</span><br><span class="line">            <span class="comment">// 首先读取两个字节表示的长度,read()方法会阻塞进程</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> inputStream.read();</span><br><span class="line">            <span class="comment">//如果读取的值为-1 说明到了流的末尾，Socket已经被关闭了，此时将不能再去读取</span></span><br><span class="line">            <span class="keyword">if</span>(first==-<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Close connection&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> inputStream.read();</span><br><span class="line">            <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> (first &lt;&lt; <span class="number">8</span>) + second;</span><br><span class="line">            <span class="comment">// 然后构造一个指定长的byte数组</span></span><br><span class="line">            receivebytes = <span class="keyword">new</span> <span class="title class_">byte</span>[length];</span><br><span class="line">            <span class="comment">// 然后读取指定长度的消息即可</span></span><br><span class="line">            inputStream.read(receivebytes);</span><br><span class="line">            String recStr=<span class="keyword">new</span> <span class="title class_">String</span>(receivebytes, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Get message from client: &quot;</span> + recStr);</span><br><span class="line"></span><br><span class="line">            String respStr=<span class="string">&quot;Hello Client,I get the message:&quot;</span>+recStr;</span><br><span class="line">            System.out.println(<span class="string">&quot;Response message &#123;&quot;</span>+respStr+<span class="string">&quot;&#125; to Client&quot;</span>);</span><br><span class="line">            <span class="comment">//首先需要计算得知消息的长度</span></span><br><span class="line">            sendBytes = respStr.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            <span class="comment">//然后将消息的长度优先发送出去</span></span><br><span class="line">            outputStream.write(sendBytes.length &gt;&gt;<span class="number">8</span>);</span><br><span class="line">            outputStream.write(sendBytes.length);</span><br><span class="line">            <span class="comment">//然后将消息再次发送出去</span></span><br><span class="line">            outputStream.write(sendBytes);</span><br><span class="line">            outputStream.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        inputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">14:03:20.550 [main] INFO cn.lbs.socket.communication.SocketServer - Waiting <span class="keyword">for</span> new connection(Listening on : 0.0.0.0/0.0.0.0:8081)</span><br><span class="line">14:03:23.534 [main] INFO cn.lbs.socket.communication.SocketServer - There is a new  connection Socket[addr=/127.0.0.1,port=4602,localport=8081]</span><br><span class="line">14:03:23.535 [main] INFO cn.lbs.socket.communication.SocketServer - Waiting <span class="keyword">for</span> message from client /127.0.0.1:4602 </span><br><span class="line">14:03:23.546 [main] INFO cn.lbs.socket.communication.SocketServer - Get  message <span class="string">&#x27;Hello World&#x27;</span> from client /127.0.0.1:4602</span><br><span class="line">14:03:23.546 [main] INFO cn.lbs.socket.communication.SocketServer - Response message <span class="string">&#x27;Hello,I get the message&#x27;</span> to Client /127.0.0.1:4602 </span><br><span class="line">14:03:23.547 [main] INFO cn.lbs.socket.communication.SocketServer - Waiting <span class="keyword">for</span> message from client /127.0.0.1:4602 </span><br><span class="line">14:03:23.547 [main] INFO cn.lbs.socket.communication.SocketServer - Get  message <span class="string">&#x27;你好，世界&#x27;</span> from client /127.0.0.1:4602</span><br><span class="line">14:03:23.547 [main] INFO cn.lbs.socket.communication.SocketServer - Response message <span class="string">&#x27;Hello,I get the message&#x27;</span> to Client /127.0.0.1:4602 </span><br><span class="line">14:03:23.547 [main] INFO cn.lbs.socket.communication.SocketServer - Waiting <span class="keyword">for</span> message from client /127.0.0.1:4602 </span><br><span class="line">14:03:23.547 [main] INFO cn.lbs.socket.communication.SocketServer - Get  message <span class="string">&#x27;YOLO&#x27;</span> from client /127.0.0.1:4602</span><br><span class="line">14:03:23.547 [main] INFO cn.lbs.socket.communication.SocketServer - Response message <span class="string">&#x27;Hello,I get the message&#x27;</span> to Client /127.0.0.1:4602 </span><br><span class="line">14:03:23.547 [main] INFO cn.lbs.socket.communication.SocketServer - Waiting <span class="keyword">for</span> message from client /127.0.0.1:4602 </span><br></pre></td></tr></table></figure>

<p><strong>客户端</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 要连接的服务端IP地址和端口</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">host</span> <span class="operator">=</span> <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">8081</span>;</span><br><span class="line">        <span class="comment">// 与服务端建立连接</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(host, port);</span><br><span class="line">        System.out.println(<span class="string">&quot;Connect to &quot;</span>+socket.getRemoteSocketAddress()+<span class="string">&quot; Success&quot;</span>);</span><br><span class="line">        <span class="comment">// 建立连接后获得输出流</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        String[] messages = &#123;<span class="string">&quot;Hello World&quot;</span>,<span class="string">&quot;你好，世界&quot;</span>,<span class="string">&quot;YOLO&quot;</span>&#125;;</span><br><span class="line">        <span class="type">byte</span>[] receivebytes,sendBytes;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(String message:messages)&#123;</span><br><span class="line">            System.out.println();</span><br><span class="line">            System.out.println(<span class="string">&quot;Send &#123;&quot;</span>+message+<span class="string">&quot;&#125;to Server&quot;</span>);</span><br><span class="line">            <span class="comment">//首先需要计算得知消息的长度</span></span><br><span class="line">            sendBytes = message.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            <span class="comment">//然后将消息的长度优先发送出去</span></span><br><span class="line">            outputStream.write(sendBytes.length &gt;&gt;<span class="number">8</span>);</span><br><span class="line">            outputStream.write(sendBytes.length);</span><br><span class="line">            <span class="comment">//然后将消息再次发送出去</span></span><br><span class="line">            outputStream.write(sendBytes);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;Waiting for Response&quot;</span>);</span><br><span class="line">            <span class="comment">// 首先读取两个字节表示的长度,read()方法会阻塞进程</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> inputStream.read();</span><br><span class="line">            <span class="comment">//如果读取的值为-1 说明到了流的末尾，Socket已经被关闭了，此时将不能再去读取</span></span><br><span class="line">            <span class="keyword">if</span>(first==-<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Close connection&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> inputStream.read();</span><br><span class="line">            <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> (first &lt;&lt; <span class="number">8</span>) + second;</span><br><span class="line">            <span class="comment">// 然后构造一个指定长的byte数组</span></span><br><span class="line">            receivebytes = <span class="keyword">new</span> <span class="title class_">byte</span>[length];</span><br><span class="line">            <span class="comment">// 然后读取指定长度的消息即可</span></span><br><span class="line">            inputStream.read(receivebytes);</span><br><span class="line">            System.out.println(<span class="string">&quot;Get Response from Server: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(receivebytes, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">13:41:06.058 [main] INFO cn.lbs.socket.communication.SocketClient - The client /127.0.0.1:4364 successfully connects to the server /127.0.0.1:8081</span><br><span class="line">13:41:06.065 [main] INFO cn.lbs.socket.communication.SocketClient - The client /127.0.0.1:4364 sends a message <span class="string">&#x27;Hello World&#x27;</span> to the server </span><br><span class="line">13:41:06.065 [main] INFO cn.lbs.socket.communication.SocketClient - Client /127.0.0.1:4364 is  waiting <span class="keyword">for</span> Response</span><br><span class="line">13:41:06.068 [main] INFO cn.lbs.socket.communication.SocketClient - Get response message <span class="string">&#x27;Hello (/127.0.0.1:4364),I get the message&#x27;</span> from Server</span><br><span class="line">13:41:06.068 [main] INFO cn.lbs.socket.communication.SocketClient - The client /127.0.0.1:4364 sends a message <span class="string">&#x27;你好，世界&#x27;</span> to the server </span><br><span class="line">13:41:06.069 [main] INFO cn.lbs.socket.communication.SocketClient - Client /127.0.0.1:4364 is  waiting <span class="keyword">for</span> Response</span><br><span class="line">13:41:06.069 [main] INFO cn.lbs.socket.communication.SocketClient - Get response message <span class="string">&#x27;Hello (/127.0.0.1:4364),I get the message&#x27;</span> from Server</span><br><span class="line">13:41:06.069 [main] INFO cn.lbs.socket.communication.SocketClient - The client /127.0.0.1:4364 sends a message <span class="string">&#x27;YOLO&#x27;</span> to the server </span><br><span class="line">13:41:06.069 [main] INFO cn.lbs.socket.communication.SocketClient - Client /127.0.0.1:4364 is  waiting <span class="keyword">for</span> Response</span><br><span class="line">13:41:06.069 [main] INFO cn.lbs.socket.communication.SocketClient - Get response message <span class="string">&#x27;Hello (/127.0.0.1:4364),I get the message&#x27;</span> from Server</span><br></pre></td></tr></table></figure>

<h2 id="服务端并发"><a href="#服务端并发" class="headerlink" title="服务端并发"></a>服务端并发</h2><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><p>在实际生产中，创建的线程会交给线程池来处理，这样可以达到线程复用的效果，也可以防止短时间内高并发，<code>new Thread</code>短时间创建大量线程，导致资源耗尽，服务挂掉</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="comment">//注意指定编码格式，发送方和接收方一定要统一，建议使用UTF-8</span></span><br><span class="line">    <span class="keyword">final</span> String CHARSET=<span class="string">&quot;UTF-8&quot;</span>;</span><br><span class="line">    ExecutorService threadPool;</span><br><span class="line">    ServerSocket serverSocket;</span><br><span class="line">    SocketAddress serverAddress;</span><br><span class="line"></span><br><span class="line">    Server(<span class="type">int</span> port) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">         threadPool = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">// 创建具有指定端口的服务器套接字</span></span><br><span class="line">        serverSocket = <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(port);</span><br><span class="line">        serverAddress= serverSocket.getLocalSocketAddress();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// accept() 会阻塞进程，直到建立新连接，成功建立连接后会返回一个新的Socket。</span></span><br><span class="line">            log.info(<span class="string">&quot;Waiting for new connection(Listening on : &#123;&#125;)&quot;</span>, serverAddress);</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">            log.info(<span class="string">&quot;There is a new  connection &#123;&#125;&quot;</span>, socket);</span><br><span class="line">            threadPool.submit(<span class="keyword">new</span> <span class="title class_">SocketTask</span>(socket));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Server</span>(<span class="number">8081</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SocketTask</span>  <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="comment">//注意指定编码格式，发送方和接收方一定要统一，建议使用UTF-8</span></span><br><span class="line">    <span class="keyword">final</span> String CHARSET=<span class="string">&quot;UTF-8&quot;</span>;</span><br><span class="line">    Socket socket;</span><br><span class="line">    SocketTask(Socket socket)&#123;</span><br><span class="line">        <span class="built_in">this</span>.socket=socket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 建立好连接后，从socket中获取输入、输出流、客户端信息</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">            <span class="type">SocketAddress</span> <span class="variable">clientAddress</span> <span class="operator">=</span> socket.getRemoteSocketAddress();</span><br><span class="line">            <span class="comment">//建立缓冲区用于读取或写入</span></span><br><span class="line">            <span class="type">byte</span>[] receiveBytes, sendBytes;</span><br><span class="line">            <span class="comment">// 因为可以复用Socket且能判断长度，所以可以一个Socket用到底</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;Waiting for message from client &#123;&#125; &quot;</span>, clientAddress);</span><br><span class="line">                <span class="comment">// 首先读取两个字节表示的长度,read()方法会阻塞进程</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">firstByte</span> <span class="operator">=</span> inputStream.read();</span><br><span class="line">                <span class="comment">//如果读取的值为-1 说明到了流的末尾，Socket已经被关闭了，此时将不能再去读取</span></span><br><span class="line">                <span class="keyword">if</span> (firstByte == -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">secondByte</span> <span class="operator">=</span> inputStream.read();</span><br><span class="line">                <span class="type">int</span> <span class="variable">messageLen</span> <span class="operator">=</span> (firstByte &lt;&lt; <span class="number">8</span>) + secondByte;</span><br><span class="line">                <span class="comment">// 然后构造一个指定长的byte数组</span></span><br><span class="line">                receiveBytes = <span class="keyword">new</span> <span class="title class_">byte</span>[messageLen];</span><br><span class="line">                <span class="comment">// 然后读取指定长度的消息即可</span></span><br><span class="line">                inputStream.read(receiveBytes);</span><br><span class="line">                log.info(<span class="string">&quot;Get  message &#x27;&#123;&#125;&#x27; from client &#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>(receiveBytes, CHARSET), clientAddress);</span><br><span class="line">                <span class="type">String</span> <span class="variable">respStr</span> <span class="operator">=</span> <span class="string">&quot;Hello,I get the message&quot;</span>;</span><br><span class="line">                log.info(<span class="string">&quot;Response message &#x27;&#123;&#125;&#x27; to Client &#123;&#125; &quot;</span>, respStr, clientAddress);</span><br><span class="line">                <span class="comment">//首先需要计算得知消息的长度</span></span><br><span class="line">                sendBytes = respStr.getBytes(CHARSET);</span><br><span class="line">                <span class="comment">//然后将消息的长度优先发送出去</span></span><br><span class="line">                outputStream.write(sendBytes.length &gt;&gt; <span class="number">8</span>);</span><br><span class="line">                outputStream.write(sendBytes.length);</span><br><span class="line">                <span class="comment">//然后将消息再次发送出去</span></span><br><span class="line">                outputStream.write(sendBytes);</span><br><span class="line">                outputStream.flush();</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(<span class="string">&quot;关闭连接&#123;&#125;&quot;</span>,socket);</span><br><span class="line">            socket.shutdownOutput();</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>并发模拟</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiClient</span> &#123;</span><br><span class="line">    <span class="comment">// 设置连接的服务端IP地址和端口</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HOST</span> <span class="operator">=</span> <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">8081</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> CLIENTSNUM=<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ExecutorService threadPool= Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;CLIENTSNUM;i++)&#123;</span><br><span class="line">            threadPool.submit(<span class="keyword">new</span> <span class="title class_">ClientTask</span>(HOST,PORT));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClientTask</span> <span class="keyword">implements</span>  <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="comment">//注意指定编码格式，发送方和接收方一定要统一，建议使用UTF-8</span></span><br><span class="line">    <span class="keyword">final</span> String CHARSET=<span class="string">&quot;UTF-8&quot;</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> MESSAGENUM=<span class="number">100</span>;</span><br><span class="line">    Socket socket ;</span><br><span class="line"></span><br><span class="line">    OutputStream outputStream;</span><br><span class="line">    InputStream inputStream;</span><br><span class="line">    SocketAddress   localAddress;</span><br><span class="line">    SocketAddress remoteAddress;</span><br><span class="line"></span><br><span class="line">    ClientTask(String host,<span class="type">int</span> port) <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 与服务端建立连接</span></span><br><span class="line">        <span class="comment">// 建立连接后获得输出、输出流、连接信息</span></span><br><span class="line">        socket=<span class="keyword">new</span> <span class="title class_">Socket</span>(host,port);</span><br><span class="line">        outputStream = socket.getOutputStream();</span><br><span class="line">        inputStream=socket.getInputStream();</span><br><span class="line">        localAddress=socket.getLocalSocketAddress();</span><br><span class="line">        remoteAddress=socket.getRemoteSocketAddress();</span><br><span class="line">        log.info(<span class="string">&quot;The client &#123;&#125; successfully connects to the server &#123;&#125;&quot;</span>,localAddress,remoteAddress);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String[] messages = &#123;<span class="string">&quot;Hello World&quot;</span>,<span class="string">&quot;你好，世界&quot;</span>,<span class="string">&quot;YOLO&quot;</span>&#125;;</span><br><span class="line">            <span class="type">byte</span>[] receiveBytes,sendBytes;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;MESSAGENUM;i++) &#123;</span><br><span class="line">                String message=RandomStringUtils.random(<span class="number">10</span>, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">                inputStream = socket.getInputStream();</span><br><span class="line">                outputStream = socket.getOutputStream();</span><br><span class="line">                log.info(<span class="string">&quot;The client &#123;&#125; sends a message &#x27;&#123;&#125;&#x27; to the server &quot;</span>, localAddress, message);</span><br><span class="line">                <span class="comment">//首先需要计算得知消息的长度</span></span><br><span class="line">                sendBytes = message.getBytes(CHARSET);</span><br><span class="line">                <span class="comment">//然后将消息的长度优先发送出去</span></span><br><span class="line">                outputStream.write(sendBytes.length &gt;&gt; <span class="number">8</span>);</span><br><span class="line">                outputStream.write(sendBytes.length);</span><br><span class="line">                <span class="comment">//然后将消息再次发送出去</span></span><br><span class="line">                outputStream.write(sendBytes);</span><br><span class="line">                outputStream.flush();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">//获取响应</span></span><br><span class="line">                log.info(<span class="string">&quot;Client &#123;&#125; is  waiting for Response&quot;</span>, localAddress);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 首先读取两个字节表示的长度,read()方法会阻塞进程</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">firstByte</span> <span class="operator">=</span> inputStream.read();</span><br><span class="line">                <span class="comment">//如果读取的值为-1 说明到了流的末尾，Socket已经被关闭了，此时将不能再去读取</span></span><br><span class="line">                <span class="keyword">if</span> (firstByte == -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">secondByte</span> <span class="operator">=</span> inputStream.read();</span><br><span class="line">                <span class="type">int</span> <span class="variable">messageLen</span> <span class="operator">=</span> (firstByte &lt;&lt; <span class="number">8</span>) + secondByte;</span><br><span class="line">                <span class="comment">// 然后构造一个指定长的byte数组</span></span><br><span class="line">                receiveBytes = <span class="keyword">new</span> <span class="title class_">byte</span>[messageLen];</span><br><span class="line">                <span class="comment">// 然后读取指定长度的消息即可</span></span><br><span class="line">                inputStream.read(receiveBytes);</span><br><span class="line">                log.info(<span class="string">&quot;Get response message &#x27;&#123;&#125;&#x27; from Server&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>(receiveBytes, CHARSET));</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(<span class="string">&quot;关闭连接&#123;&#125;&quot;</span>,socket);</span><br><span class="line">            socket.shutdownOutput();</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="SocketOptions"><a href="#SocketOptions" class="headerlink" title="SocketOptions"></a>SocketOptions</h3><ul>
<li>int TCP_NODELAY &#x3D; 0x0001：对此连接禁用 Nagle 算法。</li>
<li>int SO_BINDADDR &#x3D; 0x000F：此选项为 TCP 或 UDP 套接字在 IP 地址头中设置服务类型或流量类字段。</li>
<li>int SO_REUSEADDR &#x3D; 0x04：设置套接字的 SO_REUSEADDR。</li>
<li>int SO_BROADCAST &#x3D; 0x0020：此选项启用和禁用发送广播消息的处理能力。</li>
<li>int IP_MULTICAST_IF &#x3D; 0x10：设置用于发送多播包的传出接口。</li>
<li>int IP_MULTICAST_IF2 &#x3D; 0x1f：设置用于发送多播包的传出接口。</li>
<li>int IP_MULTICAST_LOOP &#x3D; 0x12：此选项启用或禁用多播数据报的本地回送。</li>
<li>int IP_TOS &#x3D; 0x3：此选项为 TCP 或 UDP 套接字在 IP 地址头中设置服务类型或流量类字段。</li>
<li>int SO_LINGER &#x3D; 0x0080：指定关闭时逗留的超时值。</li>
<li>int <strong>SO_TIMEOUT</strong> &#x3D; 0x1006：设置阻塞 Socket 操作的超时值： ServerSocket.accept(); SocketInputStream.read(); DatagramSocket.receive(); 选项必须在进入阻塞操作前设置才能生效。</li>
<li>int SO_SNDBUF &#x3D; 0x1001：设置传出网络 I&#x2F;O 的平台所使用的基础缓冲区大小的提示。</li>
<li>int SO_RCVBUF &#x3D; 0x1002：设置传入网络 I&#x2F;O 的平台所使用基础缓冲区的大小的提示。</li>
<li>int <strong>SO_KEEPALIVE</strong> &#x3D; 0x0008：为 TCP 套接字设置 keepalive 选项时，对于构建长时间连接的Socket还是配置上SO_KEEPALIVE比较好</li>
<li>int SO_OOBINLINE &#x3D; 0x1003：置 OOBINLINE 选项时，在套接字上接收的所有 TCP 紧急数据都将通过套接字输入流接收。</li>
</ul>
<h3 id="Socket与操作系统"><a href="#Socket与操作系统" class="headerlink" title="Socket与操作系统"></a>Socket与操作系统</h3><p>Socket实际上是归属于应用层，使用的是运输层的TCP。在三次握手操作后，系统才会将Socket连接交给应用层，ServerSocket 才知道有一个连接过来了。那么系统当接收到一个TCP连接请求后，如果上层还没有接受它（假如SocketServer循环处理Socket，一次一个），那么系统将缓存这个连接请求，缓存是有限制的，当超过指定数量后，系统将会拒绝连接。</p>
<p>换句话说，<strong>系统接收TCP连接请求放入缓存队列，而SocketServer从缓存队列获取Socket。</strong></p>
<p>客户端为了让服务端知道自己已经发送完消息，可以选择关闭输出流**<code>socket.shutdownOutput()</code>，这个操作对应着四次挥手的第一次**，这些都由操作系统去执行，只是Socket隐藏底层逻辑的种种细节。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://www.apiref.com/java11-zh/java.base/java/net/ServerSocket.html">ServerSocket - Java 11中文版 - API参考文档 (apiref.com)</a></p>
<p><a href="https://www.apiref.com/java11-zh/java.base/java/net/Socket.html">Socket - Java 11中文版 - API参考文档 (apiref.com)</a></p>
<p><a href="https://www.apiref.com/java11-zh/java.base/java/net/InetAddress.html">InetAddress - Java 11中文版 - API参考文档 (apiref.com)</a></p>
<p><a href="https://www.cnblogs.com/yiwangzhibujian/p/7107785.html">【Socket】Java Socket编程基础及深入讲解 - 已往之不谏 - 博客园 (cnblogs.com)</a></p>
</blockquote>
]]></content>
      <categories>
        <category>javaio</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>IO</tag>
        <tag>网络编程</tag>
        <tag>笔记</tag>
        <tag>socket</tag>
        <tag>tcp</tag>
      </tags>
  </entry>
  <entry>
    <title>【转】零拷贝技术</title>
    <url>/2021/05/07/java/javaIO/zeroCopy/</url>
    <content><![CDATA[<h1 id="【转】零拷贝技术详解"><a href="#【转】零拷贝技术详解" class="headerlink" title="【转】零拷贝技术详解"></a>【转】<a href="https://mp.weixin.qq.com/s?__biz=MzU0MzQ5MDA0Mw==&mid=2247483913&idx=1&sn=2da53737b8e8908cf3efdae9621c9698&chksm=fb0be89dcc7c618b0d5a1ba8ac654295454cfc2fa81fbae5a6de49bf0a91a305ca707e9864fc&scene=21#wechat_redirect">零拷贝技术详解</a></h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>考虑这样一种常用的情形：你需要将静态内容（类似图片、文件）展示给用户。那么这个情形就意味着你需要先将静态内容从磁盘中拷贝出来放到一个内存buf中，然后将这个buf通过socket传输给用户，进而用户或者静态内容的展示。这看起来再正常不过了，但是实际上这是很低效的流程，我们把上面的这种情形抽象成下面的过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">read(file, tmp_buf, len);</span><br><span class="line">write(socket, tmp_buf, len);</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>首先调用<code>read</code>将静态内容，这里假设为文件A，读取到<code>tmp_buf</code>, 然后调用<code>write</code>将<code>tmp_buf</code>写入到socket中，如图：</p>
<p><img src="http://image.onebug.tech/640" alt="图片"></p>
<p>在这个过程中文件A的经历了<strong>4次cop</strong>y的过程：</p>
<ol>
<li>首先，调用<code>read</code>时，文件A拷贝到了kernel模式；</li>
<li>之后，CPU控制将kernel模式数据copy到user模式下；</li>
<li>调用<code>write</code>时，先将user模式下的内容copy到kernel模式下的socket的buffer中；</li>
<li>最后将kernel模式下的socket buffer的数据copy到网卡设备中传送；</li>
</ol>
<p>从上面的过程可以看出，数据白白从kernel模式到user模式走了一圈，浪费了2次copy(第一次，从kernel模式拷贝到user模式；第二次从user模式再拷贝回kernel模式，即上面4次过程的第2和3步骤。)。而且上面的过程中kernel和user模式的<strong>上下文的切换也是4次</strong>。</p>
<p>幸运的是，你可以用一种叫做Zero-Copy的技术来去掉这些无谓的copy。应用程序用Zero-Copy来请求kernel直接把disk的data传输给socket，而不是通过应用程序传输。Zero-Copy大大提高了应用程序的性能，并且减少了kernel和user模式上下文的切换。</p>
<hr>
<h2 id="详述"><a href="#详述" class="headerlink" title="详述"></a>详述</h2><p>Zero-Copy技术省去了将操作系统的read buffer拷贝到程序的buffer，以及从程序buffer拷贝到socket buffer的步骤，直接将read buffer拷贝到socket buffer。Java <code>NIO</code>中的<code>FileChannal.transferTo()</code>方法就是这样的实现，这个实现是依赖于操作系统底层的<code>sendFile()</code>实现的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">long</span> transferTo​(<span class="type">long</span> position, <span class="type">long</span> count, WritableByteChannel target)</span><br></pre></td></tr></table></figure>

<p>他底层的调用时系统调用<code>sendFile()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">ssize_t <span class="title function_">sendfile</span><span class="params">(<span class="type">int</span> out_fd, <span class="type">int</span> in_fd, off_t *offset, size_t count)</span>;</span><br></pre></td></tr></table></figure>

<p>下图展示了在<code>transferTo()</code>之后的数据流向：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/HV4yTI6PjbKgic1MvAjpofibyQwiauK9swkLT7QYEgjoSWgksiaPm1m7mHlicH0YquHnicwnBcsJpyUJOcH3EuvWyVWA/640?tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>下图展示了在使用<code>transferTo()</code>之后的上下文切换：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/HV4yTI6PjbKgic1MvAjpofibyQwiauK9swkxXxl8mCQDdzXJKmZJogZthpx2g5wEJrFZSib6cJFEFqNcCqws3bgUcg/640?tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>使用了Zero-Copy技术之后，整个过程如下：</p>
<ol>
<li><code>transferTo()</code>方法使得文件A的内容直接拷贝到一个read buffer（kernel buffer）中；</li>
<li>然后数据(kernel buffer)拷贝到socket buffer中。</li>
<li>最后将socket buffer中的数据拷贝到网卡设备（protocol engine）中传输；</li>
</ol>
<p>这显然是一个伟大的进步：这里把<strong>上下文的切换次数从4次减少到2次，同时也把数据copy的次数从4次降低到了3次。</strong></p>
<p>但是这是Zero-Copy么，答案是否定的。</p>
<hr>
<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>Linux 2.1内核开始引入了<code>sendfile</code>函数（上一节有提到）,用于将文件通过socket传送。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sendfile(socket, file, len);</span><br></pre></td></tr></table></figure>

<p>该函数通过一次系统调用完成了文件的传送，减少了原来read&#x2F;write方式的模式切换。此外更是减少了数据的copy， <code>sendfile</code>的详细过程如图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/HV4yTI6PjbKgic1MvAjpofibyQwiauK9swklziaq26RXuQ5OhkostSBhs3uNxbtJYnalq4CfAGtWqfbBjXoT1SELrA/640?tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>通过<code>sendfile</code>传送文件只需要一次系统调用，当调用<code>sendfile</code>时：</p>
<ol>
<li>首先（通过DMA）将数据从磁盘读取到kernel buffer中；</li>
<li>然后将kernel buffer拷贝到socket buffer中；</li>
<li>最后将socket buffer中的数据copy到网卡设备（protocol engine）中发送；</li>
</ol>
<p>这个过程就是第二节（详述）中的那个步骤。</p>
<p><code>sendfile</code>与read&#x2F;write模式相比，少了一次copy。但是从上述过程中也可以发现从kernel buffer中将数据copy到socket buffer是没有必要的。</p>
<p>Linux 2.4 内核对<code>sendfile</code>做了改进，如图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/HV4yTI6PjbKgic1MvAjpofibyQwiauK9swk48yndvPialCSfyx5pMzpeicmzNXGugFUJfYR3oPuPr2egIZ3Vz5WJ2EA/640?tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>改进后的处理过程如下：</p>
<ol>
<li>将文件拷贝到kernel buffer中；</li>
<li>向socket buffer中追加当前要发生的数据在kernel buffer中的<strong>位置和偏移量</strong>；</li>
<li>根据socket buffer中的位置和偏移量直接将kernel buffer的数据copy到网卡设备（protocol engine）中；</li>
</ol>
<p>经过上述过程，<strong>数据只经过了2次copy就从磁盘传送出去了。这个才是真正的Zero-Copy</strong>(这里的零拷贝是针对kernel来讲的，数据在kernel模式下是Zero-Copy)。</p>
<p>正是Linux 2.4的内核做了改进，Java中的<code>TransferTo()</code>实现了Zero-Copy,如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/HV4yTI6PjbKgic1MvAjpofibyQwiauK9swkIr4RdZunnVfczbFdpJT1bFQRBdicslA4bW92FJBvtiacojo6KgBDial6A/640?tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>Zero-Copy技术的使用场景有很多，比如Kafka, 又或者是Netty等，可以大大提升程序的性能。</p>
<blockquote>
<p>转载：<a href="https://mp.weixin.qq.com/s?__biz=MzU0MzQ5MDA0Mw==&mid=2247483913&idx=1&sn=2da53737b8e8908cf3efdae9621c9698&chksm=fb0be89dcc7c618b0d5a1ba8ac654295454cfc2fa81fbae5a6de49bf0a91a305ca707e9864fc&scene=21#wechat_redirect">什么是Zero-Copy？ (qq.com)</a></p>
</blockquote>
]]></content>
      <categories>
        <category>javaio</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>IO</tag>
        <tag>socket</tag>
        <tag>零拷贝技术</tag>
      </tags>
  </entry>
  <entry>
    <title>AQS-组件</title>
    <url>/2021/04/19/java/java%E5%B9%B6%E5%8F%91/ch10AQS%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="AQS组件"><a href="#AQS组件" class="headerlink" title="AQS组件"></a>AQS组件</h1><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>CountDownLatch中count down是倒数的意思，latch则是门闩的含义。整体含义可以理解为<strong>倒数的门栓</strong>，似乎有一点【三二一，芝麻开门 】的感觉。CountDownLatch的作用也是如此，在构造CountDownLatch的时候需要传入一个整数n，在这个整数“倒数”到0之前，主线程需要等待在门口，而这个“倒数”过程则是由各个执行线程驱动的，每个线程执行完一个任务“倒数”一次。<strong>总结来说，CountDownLatch的作用就是等待其他的线程都执行完任务，必要时可以对各个任务的执行结果进行汇总，然后主线程才继续往下执行。</strong></p>
<span id="more"></span>

<p><img src="http://image.onebug.tech/image-20210504092638245.png" alt="image-20210504092638245"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadNum</span> <span class="operator">=</span> i;</span><br><span class="line">    exec.execute(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test(threadNum);  <span class="comment">//需要被等待的线程执行的方法</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;exception&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">countDownLatch.await();</span><br><span class="line"><span class="comment">//countDownLatch.await(10, TimeUnit.MILLISECONDS);</span></span><br><span class="line"><span class="comment">//await还可以设置等待的时间（参数1：等待的时间长度; 参数2：等待的时间单位）</span></span><br><span class="line">log.info(<span class="string">&quot;analyze here&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>信号量在操作系统中是很重要的概念，Java并发库里的Semaphore就可以很轻松的完成类似操作系统信号量的控制。它可以很容易<strong>控制系统中某个资源被同时访问的线程个数</strong>。Semaphore常用来做流量分流，特别是对公共资源有限的场景，比如数据库连接。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、普通调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">     semaphore.acquire(); <span class="comment">// 获取一个许可</span></span><br><span class="line">     test();<span class="comment">//需要并发控制的内容</span></span><br><span class="line">     semaphore.release(); <span class="comment">// 释放一个许可</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">     log.error(<span class="string">&quot;exception&quot;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 2、同时获取多个许可，同时释放多个许可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">     semaphore.acquire(<span class="number">2</span>);</span><br><span class="line">     test();</span><br><span class="line">     semaphore.release(<span class="number">2</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">     log.error(<span class="string">&quot;exception&quot;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 3、尝试获取许可，获取不到不执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (semaphore.tryAcquire()) &#123;</span><br><span class="line">        test(threadNum);</span><br><span class="line">        semaphore.release();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">     log.error(<span class="string">&quot;exception&quot;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 4、尝试获取许可一段时间，获取不到不执行</span></span><br><span class="line"><span class="comment"> * 参数1：等待时间长度  参数2：等待时间单位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (semaphore.tryAcquire(<span class="number">5000</span>, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">        test(threadNum);</span><br><span class="line">        semaphore.release(); </span><br><span class="line">     &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">     log.error(<span class="string">&quot;exception&quot;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>CyclicBarrier也叫同步屏障，<strong>可以让一组线程达到一个屏障时被阻塞，直到最后一个线程达到屏障时，所以被阻塞的线程才能继续执行</strong>。CyclicBarrier好比一扇门，默认情况下关闭状态，堵住了线程执行的道路，直到所有线程都就位，门才打开，让所有线程一起通过。</p>
<p><img src="http://image.onebug.tech/image-20210504092709136.png" alt="image-20210504092709136"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//想象一个场景，运动会男子100米决赛，5名选手。每个运动员都就位后才开始。</span></span><br><span class="line"><span class="comment">//公共线程循环调用方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadNum</span> <span class="operator">=</span> i;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        executor.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                race(threadNum);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;exception&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    executor.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用方法1：每个线程都持续等待</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">race</span><span class="params">(<span class="type">int</span> threadNum)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    log.info(<span class="string">&quot;&#123;&#125; is ready&quot;</span>, threadNum);</span><br><span class="line">    barrier.await();</span><br><span class="line">    log.info(<span class="string">&quot;&#123;&#125; continue&quot;</span>, threadNum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用方法2：每个线程只等待一段时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">race</span><span class="params">(<span class="type">int</span> threadNum)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        barrier.await(<span class="number">2000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException | TimeoutException e) &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;BarrierException&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用方法3：在初始化的时候设置runnable，当线程达到屏障时优先执行runnable</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">5</span>, () -&gt; &#123;</span><br><span class="line">    log.info(<span class="string">&quot;callback is running&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>与CountDownLatch区别</strong></p>
<ul>
<li>计数器可重复用</li>
<li>描述一个或多个线程等待其他线程的关系&#x2F;多个线程相互等待</li>
</ul>
<h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><p>通常创建一个线程有2种方式，一种是直接继承Thread，另外一种就是实现Runnable接口。这2种方式都有一个缺陷就是：<strong>在执行完任务之后无法获取执行结果</strong>。如果需要获取执行结果，就必须通过共享变量或者使用线程通信的方式来达到效果，这样使用起来就比较麻烦。而自从Java 1.5开始，就提供了Callable和Future，通过它们可以在任务执行完毕之后得到任务执行结果。</p>
<p><strong>Callable与Runnable</strong></p>
<p>先说一下<code>java.lang.Runnable</code>吧，它是一个接口，在它里面只声明了一个run()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于run()方法返回值为void类型，所以在执行完任务之后无法返回任何结果。</p>
<p>Callable位于<code>java.util.concurrent</code>包下，它也是一个接口，在它里面也只声明了一个方法，只不过这个方法叫做call()：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这是一个泛型接口，call()函数返回的类型就是传递进来的V类型。</p>
<p>那么怎么使用Callable呢？一般情况下是配合ExecutorService来使用的，在ExecutorService接口中声明了若干个submit方法的重载版本：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>;</span><br><span class="line">&lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Runnable task, T result)</span>;</span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></figure>

<p><strong>Future</strong></p>
<p>Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。</p>
<p>Future类位于<code>java.util.concurrent</code>包下，它是一个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Future</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span>;</span><br><span class="line">    V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line">    V <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说Future提供了三种功能：</p>
<ul>
<li>判断任务是否完成；</li>
<li>能够中断任务；</li>
<li>能够获取任务执行结果。</li>
</ul>
<p>因为Future只是一个接口，所以是无法直接用来创建对象使用的，因此就有了下面的FutureTask。</p>
<p><strong>FutureTask</strong></p>
<p>FutureTask类实现了RunnableFuture接口，RunnableFuture继承了Runnable接口和Future接口，而FutureTask实现了RunnableFuture接口。所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。</p>
<p><strong>使用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTaskExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;String&gt;(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                log.info(<span class="string">&quot;do something in callable&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Done&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line">        log.info(<span class="string">&quot;do something in main&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> futureTask.get();</span><br><span class="line">        log.info(<span class="string">&quot;result：&#123;&#125;&quot;</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ForkJoin"><a href="#ForkJoin" class="headerlink" title="ForkJoin"></a>ForkJoin</h2><p>ForkJoin是Java7提供的一个并行执行任务的框架，是把大任务分割成若干个小任务，待小任务完成后将结果汇总成大任务结果的框架。主要采用的是<strong>工作窃取算法</strong>，工作窃取算法是指某个线程从其他队列里窃取任务来执行。</p>
<p><img src="http://image.onebug.tech/image-20210504092914046.png" alt="image-20210504092914046"></p>
<p>在窃取过程中两个线程会访问同一个队列，为了减少窃取任务线程和被窃取任务线程之间的竞争，通常我们会使用<strong>双端队列</strong>来实现工作窃取算法。被窃取任务的线程永远从队列的头部拿取任务，窃取任务的线程从队列尾部拿取任务。</p>
<p><strong>局限性</strong></p>
<ul>
<li>任务只能使用fork和join作为同步机制，如果使用了其他同步机制，当他们在同步操作时，工作线程就不能执行其他任务了。比如在fork框架使任务进入了睡眠，那么在睡眠期间内在执行这个任务的线程将不会执行其他任务了</li>
<li>所拆分的任务不应该去执行IO操作，如读和写数据文件。</li>
<li>任务不能抛出检查异常。必须通过必要的代码来处理他们。</li>
</ul>
<p><strong>使用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//模拟加和运算</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForkJoinTaskExample</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threshold</span> <span class="operator">=</span> <span class="number">2</span>;<span class="comment">//设定不大于两个数相加就直接for循环，不适用框架</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ForkJoinTaskExample</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//如果任务足够小就计算任务</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">canCompute</span> <span class="operator">=</span> (end - start) &lt;= threshold;</span><br><span class="line">        <span class="keyword">if</span> (canCompute) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果任务大于阈值，就分裂成两个子任务计算（分裂算法，可依情况调优）</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">ForkJoinTaskExample</span> <span class="variable">leftTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinTaskExample</span>(start, middle);</span><br><span class="line">            <span class="type">ForkJoinTaskExample</span> <span class="variable">rightTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinTaskExample</span>(middle + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行子任务</span></span><br><span class="line">            leftTask.fork();</span><br><span class="line">            rightTask.fork();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 等待任务执行结束合并其结果</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">leftResult</span> <span class="operator">=</span> leftTask.join();</span><br><span class="line">            <span class="type">int</span> <span class="variable">rightResult</span> <span class="operator">=</span> rightTask.join();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 合并子任务</span></span><br><span class="line">            sum = leftResult + rightResult;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">forkjoinPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成一个计算任务，计算1+2+3+4...100</span></span><br><span class="line">        <span class="type">ForkJoinTaskExample</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinTaskExample</span>(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行一个任务</span></span><br><span class="line">        Future&lt;Integer&gt; result = forkjoinPool.submit(task);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;result:&#123;&#125;&quot;</span>, result.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;exception&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><p>BlockingQueue接口表示一个线程安全的队列，可以放入并获取实例。BlockingQueue通常用于使线程产生对象，而另一线程则使用该对象。主要应用场景就是：生产者消费者模型。</p>
<p><img src="http://image.onebug.tech/1992310-df4b4820c16642be.png" alt="img"></p>
<p>生产线程将持续生产新对象并将它们插入队列，直到队列达到它可以包含的上限。换句话说，这是极限。如果阻塞队列达到其上限，则会在尝试插入新对象时阻塞生产线程。在消耗线程将对象带出队列之前，它一直处于阻塞状态。消费线程不断将对象从阻塞队列中取出，并对其进行处理。如果消费线程试图将对象从空队列中取出，则消费线程将被阻塞，直到生成的线程将对象放入队列。</p>
<p><strong>方法</strong></p>
<p>BlockingQueue有4种不同的方法来插入、删除和检查队列中的元素。每一组方法的行为都是不同的，以防被请求的操作不能立即执行。下面是这些方法的一个表：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">Throws Exception</th>
<th align="center">Special Value</th>
<th align="center">Blocks</th>
<th align="center">Times out</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Insert</td>
<td align="center">add(o)</td>
<td align="center">offer(o)</td>
<td align="center">put(o)</td>
<td align="center">offer(o, timeout, timeunit)</td>
</tr>
<tr>
<td align="center">Remove</td>
<td align="center">remove(o)</td>
<td align="center">poll()</td>
<td align="center">take()</td>
<td align="center">poll(timeout, timeunit)</td>
</tr>
<tr>
<td align="center">Examine</td>
<td align="center">element()</td>
<td align="center">peek()</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<blockquote>
<ul>
<li>Throws Exception: 如果尝试的操作不可能立即发生，则抛出一个异常。</li>
<li>Special Value  ：如果尝试的操作不能立即执行，则会返回一个特殊值（通常为true &#x2F; false）。</li>
<li>Blocks：如果尝试的操作不可能立即执行，那么该方法将阻塞。</li>
<li>Times out：如果尝试的操作不可能立即执行，则该方法调用将阻塞，但不会超过给定的超时。<br> 返回一个特殊值，告诉操作是否成功（通常为true &#x2F; false）。</li>
</ul>
</blockquote>
<p><strong>实现</strong></p>
<p>由于BlockingQueue是一个接口，因此您需要使用它的一个实现来使用它。java.util.concurrent包具有以下BlockingQueue接口（在Java 6中）的实现：</p>
<ul>
<li>ArrayBlockingQueue</li>
<li>DelayQueue</li>
<li>LinkedBlockingQueue]</li>
<li>PriorityBlockingQueue</li>
<li>SynchronousQueue</li>
</ul>
<p><strong>使用</strong></p>
<p>该示例使用BlockingQueue接口的ArrayBlockingQueue实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//BlockingQueueExample类在不同的线程中启动生产者和消费者。生产者将字符串插入共享BlockingQueue中，消费者将它们取出。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockingQueueExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">BlockingQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Producer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(queue);</span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(queue);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(producer).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(consumer).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这是生产者类。注意它在每个put（）调用之间的使用sleep。这将导致消费者在等待队列中的对象时阻塞。</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">BlockingQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(BlockingQueue queue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            queue.put(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            log.info(<span class="string">&quot;put 1&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            queue.put(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">            log.info(<span class="string">&quot;put 2&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            queue.put(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">            log.info(<span class="string">&quot;put 3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这是消费者类。它只是从队列中取出对象，并将它们打印到System.out。</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">BlockingQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(BlockingQueue queue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;take &#123;&#125;&quot;</span>,queue.take());</span><br><span class="line">            log.info(<span class="string">&quot;take &#123;&#125;&quot;</span>,queue.take());</span><br><span class="line">            log.info(<span class="string">&quot;take &#123;&#125;&quot;</span>,queue.take());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">19</span>:<span class="number">15</span>:<span class="number">27.756</span> [Thread-<span class="number">0</span>] INFO com.mmall.concurrency.example.aqs.Producer - put <span class="number">1</span></span><br><span class="line"><span class="number">19</span>:<span class="number">15</span>:<span class="number">27.756</span> [Thread-<span class="number">1</span>] INFO com.mmall.concurrency.example.aqs.Consumer - take <span class="number">1</span></span><br><span class="line"><span class="number">19</span>:<span class="number">15</span>:<span class="number">28.776</span> [Thread-<span class="number">0</span>] INFO com.mmall.concurrency.example.aqs.Producer - put <span class="number">2</span></span><br><span class="line"><span class="number">19</span>:<span class="number">15</span>:<span class="number">28.776</span> [Thread-<span class="number">1</span>] INFO com.mmall.concurrency.example.aqs.Consumer - take <span class="number">2</span></span><br><span class="line"><span class="number">19</span>:<span class="number">15</span>:<span class="number">29.790</span> [Thread-<span class="number">0</span>] INFO com.mmall.concurrency.example.aqs.Producer - put <span class="number">3</span></span><br><span class="line"><span class="number">19</span>:<span class="number">15</span>:<span class="number">29.790</span> [Thread-<span class="number">1</span>] INFO com.mmall.concurrency.example.aqs.Consumer - take <span class="number">3</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java高并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>笔记</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池</title>
    <url>/2021/04/20/java/java%E5%B9%B6%E5%8F%91/ch11%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="线程池与new-Thread"><a href="#线程池与new-Thread" class="headerlink" title="线程池与new Thread"></a>线程池与new Thread</h2><h3 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h3><ul>
<li>重用存在的线程，减少对象创建、消亡的开销，性能好</li>
<li>可有效控制最大并发线程数，提高系统资源利用率，同时可以避免过多资源竞争，避免阻塞。</li>
<li>提供定时执行、定期执行、单线程、并发数控制等功能。</li>
</ul>
<span id="more"></span>

<h3 id="new-Thread的弊端"><a href="#new-Thread的弊端" class="headerlink" title="new Thread的弊端"></a>new Thread的弊端</h3><ul>
<li>每次new Thread 新建对象，性能差</li>
<li>线程缺乏统一管理，可能无限制的新建线程，相互竞争，可能占用过多的系统资源导致死机或者OOM（out of memory 内存溢出），这种问题的原因不是因为单纯的new一个Thread，而是可能因为程序的bug或者设计上的缺陷导致不断new Thread造成的。</li>
<li>缺少更多功能，如更多执行、定期执行、线程中断。</li>
</ul>
<h2 id="线程池的结构"><a href="#线程池的结构" class="headerlink" title="线程池的结构"></a>线程池的结构</h2><p><img src="http://image.onebug.tech/image-20210504093153759.png" alt="image-20210504093153759"></p>
<p>在线程池的类图中，我们最常使用的是最下边的Executors，用它来创建线程池使用线程。那么在上边的类图中，包含了一个Executor框架，它是一个根据一组执行策略的调用调度执行和控制异步任务的框架，目的是提供一种将任务提交与任务如何运行分离开的机制。它包含了三个executor接口：</p>
<ul>
<li>Executor：运行新任务的简单接口</li>
<li>ExecutorService：扩展了Executor，添加了用来管理执行器生命周期和任务生命周期的方法</li>
<li>ScheduleExcutorService：扩展了ExecutorService，支持Future和定期执行任务</li>
</ul>
<h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p><img src="http://image.onebug.tech/20170914114339689" alt="这里写图片描述"></p>
<ol>
<li>线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。</li>
<li>当调用 execute() 方法添加一个任务时，线程池会做如下判断：</li>
</ol>
<ul>
<li>如果正在运行的线程数量小于 <code>corePoolSize</code>，那么马上创建线程运行这个任务；</li>
<li>如果正在运行的线程数量大于或等于 <code>corePoolSize</code>，那么将这个任务放入队列。</li>
<li>如果这时候队列满了，而且正在运行的线程数量小于 <code>maximumPoolSize</code>，那么还是要创建线程运行这个任务；</li>
<li>如果队列满了，而且正在运行的线程数量大于或等于 <code>maximumPoolSize</code>，那么线程池会抛出异常，告诉调用者“我不能再接受任务了”。</li>
</ul>
<ol start="3">
<li>当一个线程完成任务时，它会从队列中取下一个任务来执行。</li>
<li>当一个线程无事可做，超过一定的时间（<code>keepAliveTime</code>）时，线程池会判断，如果当前运行的线程数大于 <code>corePoolSize</code>，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 <code>corePoolSize</code> 的大小。</li>
</ol>
<h3 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a>配置项</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates a new &#123;<span class="doctag">@code</span> ThreadPoolExecutor&#125; with the given initial</span></span><br><span class="line"><span class="comment">    * parameters.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> corePoolSize the number of threads to keep in the pool, even</span></span><br><span class="line"><span class="comment">    *        if they are idle, unless &#123;<span class="doctag">@code</span> allowCoreThreadTimeOut&#125; is set</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> maximumPoolSize the maximum number of threads to allow in the</span></span><br><span class="line"><span class="comment">    *        pool</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> keepAliveTime when the number of threads is greater than</span></span><br><span class="line"><span class="comment">    *        the core, this is the maximum time that excess idle threads</span></span><br><span class="line"><span class="comment">    *        will wait for new tasks before terminating.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> unit the time unit for the &#123;<span class="doctag">@code</span> keepAliveTime&#125; argument</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> workQueue the queue to use for holding tasks before they are</span></span><br><span class="line"><span class="comment">    *        executed.  This queue will hold only the &#123;<span class="doctag">@code</span> Runnable&#125;</span></span><br><span class="line"><span class="comment">    *        tasks submitted by the &#123;<span class="doctag">@code</span> execute&#125; method.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> threadFactory the factory to use when the executor</span></span><br><span class="line"><span class="comment">    *        creates a new thread</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> handler the handler to use when execution is blocked</span></span><br><span class="line"><span class="comment">    *        because the thread bounds and queue capacities are reached</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IllegalArgumentException if one of the following holds:&lt;br&gt;</span></span><br><span class="line"><span class="comment">    *         &#123;<span class="doctag">@code</span> corePoolSize &lt; 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment">    *         &#123;<span class="doctag">@code</span> keepAliveTime &lt; 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment">    *         &#123;<span class="doctag">@code</span> maximumPoolSize &lt;= 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment">    *         &#123;<span class="doctag">@code</span> maximumPoolSize &lt; corePoolSize&#125;</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> workQueue&#125;</span></span><br><span class="line"><span class="comment">    *         or &#123;<span class="doctag">@code</span> threadFactory&#125; or &#123;<span class="doctag">@code</span> handler&#125; is null</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                             <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                             <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                             TimeUnit unit,</span></span><br><span class="line"><span class="params">                             BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                             ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                             RejectedExecutionHandler handler)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">           maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">           maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">           keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">       <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">       <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">       <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">       <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">       <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">       <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">       <span class="built_in">this</span>.handler = handler;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>corePoolSize</code>：指定了线程池中的线程数量，它的数量决定了添加的任务是开辟新的线程去执行，还是放到<code>workQueue</code>任务队列中去</li>
<li><code>maximumPoolSize</code>：指定了线程池中的最大线程数量，这个参数会根据你使用的<code>workQueue</code>任务队列的类型，决定线程池会开辟的最大线程数量；</li>
<li><code>keepAliveTime</code>：当线程数大于核心数时，多余的闲置线程在会在多长时间内被销毁</li>
<li><code>unit</code>:<code>keepAliveTime</code>的单位</li>
<li><code>workQueue</code>：任务队列，被添加到线程池中，但尚未被执行的任务；它一般分为直接提交队列、有界任务队列、无界任务队列、优先任务队列几种；</li>
<li><code>threadFactory</code>:线程工厂，用于创建线程，一般用默认即可；</li>
<li><code>handler</code>:拒绝策略；当任务太多来不及处理时，如何拒绝任务；</li>
</ul>
<h3 id="线程池的阻塞队列"><a href="#线程池的阻塞队列" class="headerlink" title="线程池的阻塞队列"></a>线程池的阻塞队列</h3><p>通道，有以下一些阻塞队列可供选择：</p>
<ul>
<li><code>ArrayBlockingQueue</code>是一个有边界的阻塞队列，它的内部实现是一个数组。有边界的意思是它的容量是有限的，我们必须在其初始化的时候指定它的容量大小，容量大小一旦指定就不可改变。</li>
<li><code>DelayQueue</code>阻塞的是其内部元素，<code>DelayQueue</code>中的元素必须实现 <code>java.util.concurrent.Delayed</code>接口，该接口只有一个方法就是<code>long getDelay(TimeUnit unit)</code>，返回值就是队列元素被释放前的保持时间，如果返回0或者一个负值，就意味着该元素已经到期需要被释放，此时<code>DelayedQueue</code>会通过其take()方法释放此对象，<code>DelayQueue</code>可应用于定时关闭连接、缓存对象，超时处理等各种场景；</li>
<li><code>LinkedBlockingQueue</code>阻塞队列大小的配置是可选的，如果我们初始化时指定一个大小，它就是有边界的，如果不指定，它就是无边界的。说是无边界，其实是采用了默认大小为<code>Integer.MAX_VALUE</code>的容量 。它的内部实现是一个链表。</li>
<li><code>PriorityBlockingQueue</code>是一个没有边界的队列，它的排序规则和 <code>java.util.PriorityQueue</code>一样。需要注意，<code>PriorityBlockingQueue</code>中允许插入null对象。所有插入<code>PriorityBlockingQueue</code>的对象必须实现 <code>java.lang.Comparable</code>接口，队列优先级的排序规则就是按照我们对这个接口的实现来定义的。</li>
<li><code>SynchronousQueue</code>队列内部仅允许容纳一个元素。当一个线程插入一个元素后会被阻塞，除非这个元素被另一个线程消费。</li>
</ul>
<p>使用的最多的应该是<strong>LinkedBlockingQueue</strong>，注意一般情况下要配置一下队列大小，设置成有界队列，否则JVM内存会被撑爆！</p>
<h3 id="饱和策略"><a href="#饱和策略" class="headerlink" title="饱和策略"></a>饱和策略</h3><p>线程池已满的定义，是指<code>运行线程数==maximumPoolSize</code>，并且workQueue是有界队列并且已满（如果是无界队列当然永远不会满）；这时候再提交任务怎么办呢？线程池会将任务传递给最后一个参数<code>RejectedExecutionHandler</code>来处理，比如打印报错日志、抛出异常、存储到Mysql&#x2F;redis用于后续处理等等，线程池默认也提供了几种处理方式：</p>
<ul>
<li>在默认的 <code>ThreadPoolExecutor.AbortPolicy</code> 中，处理程序遭到拒绝将抛出运行时<code>RejectedExecutionException</code>。</li>
<li>在 <code>ThreadPoolExecutor.CallerRunsPolicy</code> 中，线程调用运行该任务的execute 本身。此策略提供简单的反馈控制机制，能够减缓新任务的提交速度。</li>
<li>在 <code>ThreadPoolExecutor.DiscardPolicy</code> 中，不能执行的任务将被删除。</li>
<li>在 <code>ThreadPoolExecutor.DiscardOldestPolicy</code> 中，如果执行程序尚未关闭，则位于工作队列头部的任务将被删除，然后重试执行程序（如果再次失败，则重复此过程）</li>
<li>当然也可以自己实现处理策略类，继承<code>RejectedExecutionHandler</code>接口即可，该接口只有一个方法：<br><code>void rejectedExecution(Runnable r, ThreadPoolExecutor executor);</code></li>
</ul>
<h3 id="线程池配置优化"><a href="#线程池配置优化" class="headerlink" title="线程池配置优化"></a>线程池配置优化</h3><p>一般需要根据任务的类型来配置线程池大小：如果是CPU密集型任务，就需要尽量压榨CPU，参考值可以设为 NCPU+1。如果是IO密集型任务，参考值可以设置为2*NCPU。</p>
<p>当然，这只是一个参考值，具体的设置还需要根据实际情况进行调整，比如可以先将线程池大小设置为参考值，再观察任务运行情况和系统负载、资源利用率来进行适当调整。</p>
<blockquote>
<p>其中NCPU的指的是CPU的核心数，可以使用<code>Runtime.getRuntime().availableProcessors()</code>来获取；</p>
</blockquote>
<h2 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h2><p>使用Executor可以创建四种线程池：分别对应上边提到的四种线程池初始化方法</p>
<ul>
<li><p><code>newCachedThreadPool</code><br>创建一个可缓存的线程池，如果线程池的长度超过了处理的需要，可以灵活回收空闲线程。如果没有可回收的就新建线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//源码：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的一点是，<code>newCachedThreadPool</code>的返回值是ExecutorService类型，该类型只包含基础的线程池方法，但却不包含线程监控相关方法，因此在使用返回值为ExecutorService的线程池类型创建新线程时要考虑到具体情况。</p>
</li>
<li><p><code>newFixedThreadPool</code></p>
<ul>
<li>定长线程池，可以设置线程的最大并发数，超出在队列等待</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//源码：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>newSingleThreadExecutor</code></p>
<p>单线程化的线程池，用唯一的一个共用线程执行任务，保证所有任务按指定顺序执行（FIFO、优先级…）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>newScheduledThreadPool</code></p>
<p>定长线程池，支持定时和周期任务执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//源码：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newScheduledThreadPool</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ScheduledThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,<span class="comment">//此处super指的是ThreadPoolExecutor</span></span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">DelayedWorkQueue</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ScheduledExecutorService</code>提供了三种方法可以使用：</p>
<ul>
<li><p><code>schedule</code>：在指定delay（延时）之后，执行提交Runnable的任务</p>
</li>
<li><p><code>scheduleAtFixedRate</code>：以指定的速率执行任务</p>
</li>
<li><p><code>scheduleWithFixedDelay</code>：以指定的延迟执行任务</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><a href="https://www.cnblogs.com/dafanjoy/p/9729358.html">java线程池ThreadPoolExecutor类使用详解 - bigfan - 博客园 (cnblogs.com)</a></p>
</blockquote>
]]></content>
      <categories>
        <category>java高并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>笔记</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>死锁</title>
    <url>/2021/04/21/java/java%E5%B9%B6%E5%8F%91/ch12%E6%AD%BB%E9%94%81/</url>
    <content><![CDATA[<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>通俗的说，死锁就是两个或者多个线程，相互占用对方需要的资源，而都不进行释放，导致彼此之间都相互等待对方释放资源，产生了无限制等待的现象。死锁一旦发生，如果没有外力介入，这种等待将永远存在，从而对程序产生严重影响。用来描述死锁的问题最有名的场景就是“哲学家就餐问题”。</p>
<span id="more"></span>

<h3 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h3><ul>
<li>互斥条件：进程对锁分配的资源进行排他性使用</li>
<li>请求和保持条件：线程已经保持了一个资源，但是又提出了其他请求，而该资源已被其他线程占用</li>
<li>不剥夺条件：在使用时不能被剥夺，只能自己用完释放</li>
<li>环路等待条件：资源调用是一个环形的链</li>
</ul>
<h2 id="死锁示例"><a href="#死锁示例" class="headerlink" title="死锁示例"></a>死锁示例</h2><pre><code>@Slf4j
public class DeadLock implements Runnable &#123;
    public int flag = 1;
    //静态对象是类的所有对象共享的
    private static Object o1 = new Object(), o2 = new Object();

    @Override
    public void run() &#123;
        log.info(&quot;flag:&#123;&#125;&quot;, flag);
        if (flag == 1) &#123;
            synchronized (o1) &#123;
                try &#123;
                    Thread.sleep(500);
                &#125; catch (Exception e) &#123;
                    e.printStackTrace();
                &#125;
                synchronized (o2) &#123;
                    log.info(&quot;1&quot;);
                &#125;
            &#125;
        &#125;
        if (flag == 0) &#123;
            synchronized (o2) &#123;
                try &#123;
                    Thread.sleep(500);
                &#125; catch (Exception e) &#123;
                    e.printStackTrace();
                &#125;
                synchronized (o1) &#123;
                    log.info(&quot;0&quot;);
                &#125;
            &#125;
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        DeadLock td1 = new DeadLock();
        DeadLock td2 = new DeadLock();
        td1.flag = 1;
        td2.flag = 0;
        //td1,td2都处于可执行状态，但JVM线程调度先执行哪个线程是不确定的。
        //td2的run()可能在td1的run()之前运行
        new Thread(td1).start();
        new Thread(td2).start();
    &#125;
&#125;
</code></pre>
<p><strong>jps jstack 定位死锁</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;jps</span><br><span class="line">&gt;jstack pid </span><br></pre></td></tr></table></figure>

<h2 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h2><ul>
<li>注意加锁顺序</li>
<li>设置加锁时限（超过时限放弃加锁）</li>
<li>死锁检测</li>
</ul>
]]></content>
      <categories>
        <category>java高并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>笔记</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>高并发相关基础知识</title>
    <url>/2021/04/10/java/java%E5%B9%B6%E5%8F%91/ch1%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="高并发相关基础知识"><a href="#高并发相关基础知识" class="headerlink" title="高并发相关基础知识"></a>高并发相关基础知识</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li><p>并发</p>
<p>程序同时拥有两个或者多个线程。如果程序在单核处理器上运行，多个线程将交替地换入或者换出内存，这些线程是同时”存在”的，每个线程都处于执行过程中的某个状态。如果程序运行在多核处理器上，此时，每个线程都将分配到一个处理器核上，因此可以同时运行。</p>
</li>
<li><p>高并发</p>
<p>高并发是互联网分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计保证系统能够同时并行处理很多请求。</p>
<span id="more"></span>
</li>
<li><p>CPU多级缓存</p>
<p>CPU的频率太快了，快到主存跟不上，这样在处理器时钟周期内，CPU常常需要等待主存，浪费资源，所以cache的出现，是<strong>为了缓解CPU和内存之间速度的不匹配问题</strong>。</p>
<p><img src="http://image.onebug.tech/image-20210504002724606.png" alt="image-20210504002724606"></p>
</li>
<li><p>局部性原理</p>
<ul>
<li>时间局部性：如果某个数据被访问，那么在不久的将来它很可能被再次访问。</li>
<li>空间局部性：如果某个数据被访问，那么与他相邻的数据也很可能被访问。</li>
</ul>
</li>
<li><p>乱序执行优化</p>
<p>处理器为提高运算速度而做出违背代码原有顺序的优化。</p>
</li>
</ul>
<h2 id="多核CPU多级缓存一致性协议MESI"><a href="#多核CPU多级缓存一致性协议MESI" class="headerlink" title="多核CPU多级缓存一致性协议MESI"></a>多核CPU多级缓存一致性协议MESI</h2><p>多核CPU的情况下有多个一级缓存，如何保证缓存内部数据的一致，不让系统数据混乱。这里就引出了一个一致性的协议MESI。</p>
<h3 id="MESI协议缓存状态"><a href="#MESI协议缓存状态" class="headerlink" title="MESI协议缓存状态"></a>MESI协议缓存状态</h3><p>MESI 是指4中状态的首字母。每个Cache line有4个状态，可用2个bit表示，它们分别是：</p>
<blockquote>
<p><strong>缓存行（Cache line）</strong>：缓存存储数据的单元。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">状态</th>
<th align="left">描述</th>
<th align="left">监听任务</th>
</tr>
</thead>
<tbody><tr>
<td align="left">M 修改 (Modified)</td>
<td align="left">该Cache line有效，数据被修改了，和内存中的数据不一致，数据只存在于本Cache中。</td>
<td align="left">缓存行必须时刻监听所有试图读该缓存行的对应主存的操作，这种操作必须在缓存将该缓存行写回主存并将状态变成S（共享）状态之前被延迟执行。</td>
</tr>
<tr>
<td align="left">E 独享(Exclusive)</td>
<td align="left">该Cache line有效，数据和内存中的数据一致，数据只存在于本Cache中。</td>
<td align="left">缓存行也必须监听其它缓存读主存中该缓存行的操作，一旦有这种操作，该缓存行需要变成S（共享）状态。</td>
</tr>
<tr>
<td align="left">S 共享 (Shared)</td>
<td align="left">该Cache line有效，数据和内存中的数据一致，数据存在于很多Cache中。</td>
<td align="left">缓存行也必须监听其它缓存使该缓存行无效或者独享该缓存行的请求，并将该缓存行变成无效（Invalid）。</td>
</tr>
<tr>
<td align="left">I 无效 (Invalid)</td>
<td align="left">该Cache line无效。</td>
<td align="left">无</td>
</tr>
</tbody></table>
<h3 id="MESI状态转换"><a href="#MESI状态转换" class="headerlink" title="MESI状态转换"></a>MESI状态转换</h3><p><img src="http://image.onebug.tech/image-20210504002838073.png" alt="image-20210504002838073"></p>
<ul>
<li>触发事件</li>
</ul>
<table>
<thead>
<tr>
<th align="left">触发事件</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">本地读取（Local read）</td>
<td align="left">本地cache读取本地cache数据</td>
</tr>
<tr>
<td align="left">本地写入（Local write）</td>
<td align="left">本地cache写入本地cache数据</td>
</tr>
<tr>
<td align="left">远端读取（Remote read）</td>
<td align="left">其他cache读取其他cache数据</td>
</tr>
<tr>
<td align="left">远端写入（Remote write）</td>
<td align="left">其他cache写入其他cache数据</td>
</tr>
</tbody></table>
<ul>
<li><p>cache分类</p>
<blockquote>
<p>前提：所有的cache共同缓存了主内存中的某一条数据。</p>
</blockquote>
</li>
<li><p>本地cache：指当前CPU的cache</p>
<ul>
<li>触发cache：触发读写事件的cache</li>
<li>其他cache：指既除了以上两种之外的cache</li>
</ul>
</li>
</ul>
<h3 id="多核缓存协同操作"><a href="#多核缓存协同操作" class="headerlink" title="多核缓存协同操作"></a>多核缓存协同操作</h3><p>假设有三个CPU A、B、C，对应三个缓存分别是cache a、b、 c。在主内存中定义了x的引用值为0。</p>
<p><img src="http://image.onebug.tech/1195582-20180503162549299-994420333.png" alt="img"></p>
<p><strong>单核读取</strong></p>
<p>执行流程：</p>
<ul>
<li>CPU A发出了一条指令，从主内存中读取x。、</li>
<li>从主内存通过bus读取到缓存中（远端读取Remote read）,这是该Cache line修改为E状态（独享）。</li>
</ul>
<p><img src="http://image.onebug.tech/1195582-20180503162602668-681441242.png" alt="img"></p>
<p><strong>双核读取</strong></p>
<p>执行流程：</p>
<ul>
<li>CPU A发出了一条指令，从主内存中读取x。</li>
<li>CPU A从主内存通过bus读取到 cache a中并将该cache line 设置为E状态。</li>
<li>CPU B发出了一条指令，从主内存中读取x。</li>
<li>CPU B试图从主内存中读取x时，CPU A检测到了地址冲突。这时CPU A对相关数据做出响应。此时x 存储于cache a和cache b中，x在cache a和cache b中都被设置为S状态(共享)。</li>
</ul>
<p><img src="http://image.onebug.tech/1195582-20180503162619534-683579600.png" alt="img"></p>
<p><strong>修改数据</strong></p>
<p>执行流程：</p>
<ul>
<li>CPU A 计算完成后发指令需要修改x.</li>
<li>CPU A 将x设置为M状态（修改）并通知缓存了x的CPU B, CPU B将本地cache b中的x设置为I状态(无效)</li>
<li>CPU A 对x进行赋值。</li>
</ul>
<p><img src="http://image.onebug.tech/1195582-20180503162633779-1465275811.png" alt="img"></p>
<p><strong>同步数据</strong></p>
<p>执行流程：</p>
<ul>
<li>CPU B 发出了要读取x的指令。</li>
<li>CPU B 通知CPU A,CPU A将修改后的数据同步到主内存时cache a 修改为E（独享）</li>
<li>CPU A同步CPU B的x,将cache a和同步后cache b中的x设置为S状态（共享）。、</li>
</ul>
<p><img src="http://image.onebug.tech/1195582-20180503162644640-382839091.png" alt="img"></p>
<h2 id="MESI与Java"><a href="#MESI与Java" class="headerlink" title="MESI与Java"></a>MESI与Java</h2><p>缓存的一致性消息传递是要时间的，这就使其切换时会产生延迟。当一个缓存被切换状态时，其他缓存收到消息完成各自的切换，并且发出回应消息后，这么一长串的时间中CPU都会等待所有缓存响应完成。可能出现的阻塞都会导致各种各样的性能问题和稳定性问题。这对于程序员来说简直是一个灾难。幸好java解决了这个问题，至于如何解决的请关注JMM。</p>
<h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><h3 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h3><p>Java内存模型（Java Memory Model）即JMM，是一个<strong>抽象</strong>的概念。Java内存模型（JMM）定义了Java虚拟机（JVM）在计算机内存（RAM）中的工作规范。在硬件内存模型中，各种CPU架构的实现是不尽相同的，Java作为跨平台的语言，为了屏蔽底层硬件差异，定义了Java内存模型（JMM）。JMM作用于JVM和底层硬件之间，屏蔽了下游不同硬件模型带来的差异，为上游开发者提供了统一的使用接口。说了这么多其实就是想说明白JMM——JVM——硬件的关系。总之一句话，JMM是JVM的内存使用规范，是一个抽象的概念。</p>
<p><img src="http://image.onebug.tech/image-20210504003219866.png" alt="image-20210504003219866"></p>
<h3 id="JMM主内存和本地内存交互操作"><a href="#JMM主内存和本地内存交互操作" class="headerlink" title="JMM主内存和本地内存交互操作"></a>JMM主内存和本地内存交互操作</h3><p><img src="http://image.onebug.tech/image-20210504003101783.png" alt="image-20210504003101783"></p>
<p> 计算机硬件内存模型有缓存和主内存的交互协议MESI，同样JMM也规范了主内存和线程工作内存进行数据交换操作。一共包括如上图所示的8中操作，并且每个操作都是原子性的。</p>
<ol>
<li><strong>lock(锁定)：</strong>作用于主内存的变量，一个变量在同一时间只能一个线程锁定。该操作表示该线程独占锁定的变量。</li>
<li><strong>unlock(解锁)：</strong>作用于主内存的变量，表示这个变量的状态由处于锁定状态被释放，这样其他线程才能对该变量进行锁定。</li>
<li><strong>read(读取)：</strong>作用于主内存变量，表示把一个主内存变量的值传输到线程的工作内存，以便随后的load操作使用。</li>
<li><strong>load(载入)：</strong>作用于线程的工作内存的变量，表示把read操作从主内存中读取的变量的值放到工作内存的变量副本中(副本是相对于主内存的变量而言的)。</li>
<li><strong>use(使用)：</strong>作用于线程的工作内存中的变量，表示把工作内存中的一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时就会执行该操作。</li>
<li><strong>assign(赋值)：</strong>作用于线程的工作内存的变量，表示把执行引擎返回的结果赋值给工作内存中的变量，每当虚拟机遇到一个给变量赋值的字节码指令时就会执行该操作。</li>
<li><strong>store(存储)：</strong>作用于线程的工作内存中的变量，把工作内存中的一个变量的值传递给主内存，以便随后的write操作使用。</li>
<li><strong>write(写入)：</strong>作用于主内存的变量，把store操作从工作内存中得到的变量的值放入主内存的变量中。</li>
</ol>
<p>JMM规定了以上8中操作需要按照如下规则进行</p>
<ul>
<li>不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。</li>
<li>不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</li>
<li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中。</li>
<li>一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。</li>
<li>一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。</li>
<li>如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。</li>
<li>如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定住的变量。</li>
</ul>
<p>以上8中规则看着也是比较生涩的，其实如果你没看明白也没关系，其实这些规则就是保障数据同步的一些规则。不是很重要，重要的在后面的<strong>happens-before原则</strong>。</p>
<h3 id="并发环境下JMM存在的问题"><a href="#并发环境下JMM存在的问题" class="headerlink" title="并发环境下JMM存在的问题"></a>并发环境下JMM存在的问题</h3><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>JMM保证了上文的8个操作是原子性的，以及Java语言本身对除了<code>double</code>和<code>long</code>的基本数据类型的变量的读取和赋值操作是原子性操作。其他的就算是简单的操作，比如<code>x ++</code>，就不是原子操作，因为这行代码包含三个操作：</p>
<ul>
<li><p>加载x的值</p>
</li>
<li><p>执行 ++</p>
</li>
<li><p>写入新值</p>
</li>
</ul>
<p>在并发环境下，通常采用<code>synchronized</code>或者<code>Lock</code>对代码块加锁保证原子性。</p>
<h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>在Java中提供了一个<code>volatile</code>关键字来保证可见性。当一个主内存中的共享变量被<code>volatile</code>关键字修饰时，一个线程对该变量的修改会被立即刷新（store）到主内存，保证<strong>其他线程看到的值一定是最新的</strong>。<strong>JMM层面上<code>volatile</code>是通过load&#x2F;store操作实现的可见性</strong>。</p>
<p>当然我们也可以通过<code>synchronized</code>和<code>Lock</code>通过加锁将多线程进行同步也就是串行执行来保证共享变量的可见性。</p>
<h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p><strong>happens-before原则</strong></p>
<ul>
<li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于后面的操作。</li>
<li>锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作。（先释放锁，才能加锁）</li>
<li>volatile变量规则：对同一个变量的写操作先行发生于后面对这个变量的读操作。</li>
<li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于C，则A先行发生于操作C。</li>
<li>线程启动规则：Thread对象的<code>start()</code>方法先行发生于此线程的每一个动作。</li>
<li>线程终结规则：对线程<code>interrupt()</code>方法的调用先行发生于被中断线程的代码检测到中断事件的发生。</li>
<li>线程终结规则：线程中所有的操作都先行发生于线程的终结检测，我们可以通过<code>Thread.join()</code>方法结束、<code>Thread.isAlive()</code>的返回值手段检测到线程已经终止执行。</li>
<li>对象终结规则：一个对象的初始化完成先行发生于他的<code>finalize()</code>方法的开始。</li>
</ul>
<p><strong>happens-before与可见性</strong><br>happens-before通过以上8中规则保证可见性，<strong>如果一个操作A happens-before 另一个操作B，那么操作A的结果是对操作B可见的，这不难理解</strong>。</p>
<p><strong>happens-before与重排序</strong><br>两个操作如果存在happens-before关系，并不意味着一定是有序进行的，这是因为JVM存在指令重排优化，如果JVM认为两个操作重排序有利于性能提升并且重排序后的操作和未重排结果一致，将进行指令重排序。当然JVM层面的重排序发生于编译期，运行时的指令重排是处理器决定的。Java语言通过volatile关键字通过向主内存加入内存屏障实现禁止指令重排。</p>
<blockquote>
<p><a href="https://www.cnblogs.com/yanlong300/p/8986041.html">并发研究之CPU缓存一致性协议(MESI) - 枫飘雪落 - 博客园 (cnblogs.com)</a></p>
<p><a href="https://blog.csdn.net/muxiqingyang/article/details/6615199">《大话处理器》Cache一致性协议之MESI_木兮清扬的博客-CSDN博客_mesi</a></p>
</blockquote>
]]></content>
      <categories>
        <category>java高并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>笔记</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>线程安全性</title>
    <url>/2021/04/11/java/java%E5%B9%B6%E5%8F%91/ch2%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7/</url>
    <content><![CDATA[<h2 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>当多个线程访问某个类时，不管运行时环境采用<strong>何种调度方式</strong>或者这些进程将如何交替执行，并且在主调代码中<strong>不需要任何额外的同步或协同</strong>，这个类都能表现出<strong>正确的行为</strong>，那么就称这个类是线程安全的。</p>
<span id="more"></span>

<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>线程安全性主要体现在三个方面：</p>
<ul>
<li>原子性：提供了<strong>互斥访问</strong>，同一时刻只能有一个线程来对它进行操作</li>
<li>可见性：一个线程对主内存的修改可以及时的被其他线程观察到</li>
<li>有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序的存在，该观察结果一般杂乱无序。</li>
</ul>
<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>JAVA中的原子性，一般涉及两个机制：</p>
<ul>
<li>JDK中已经提供好的Atomic包，他们均使用了CAS完成线程的原子性操作</li>
<li>使用锁的机制来处理线程之间的原子性。锁包括：synchronized、Lock</li>
</ul>
<h3 id="Atomic包"><a href="#Atomic包" class="headerlink" title="Atomic包"></a>Atomic包</h3><p><img src="http://image.onebug.tech/image-20210504002340565.png" alt="image-20210504002340565"></p>
<h4 id="AtomicInteger与CAS"><a href="#AtomicInteger与CAS" class="headerlink" title="AtomicInteger与CAS"></a>AtomicInteger与CAS</h4><p>我们从最简单的AtomicInteger类来了解什么是CAS</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">incrementAndGet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="built_in">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAddInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> v ar4)</span> &#123;</span><br><span class="line">    <span class="type">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="built_in">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 比较obj的offset处内存位置中的值和期望的值，如果相同则更新。此更新是不可中断的。</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> obj 需要更新的对象</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> offset obj中整型field的偏移量</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> expect 希望field中存在的值</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> update 如果期望值expect与field的当前值相同，设置filed的值为这个新值</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 如果field的值被更改返回true</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapInt</span><span class="params">(Object obj, <span class="type">long</span> offset, <span class="type">int</span> expect, <span class="type">int</span> update)</span>;</span><br></pre></td></tr></table></figure>

<p><code>getIntVolatile</code>方法获取对象中offset偏移地址对应的整型field的值，支持volatile load语义。</p>
<p><code>compareAndSwap</code>是一个本地方法，在AtomicInteger类中，它的参数具体含义是：</p>
<ul>
<li><code>var1</code> AtomicInteger对象本身。</li>
<li><code>var2</code> 该对象值的引用地址。</li>
<li><code>var4</code> 需要变动的数量</li>
<li><code>var5</code> 是用过<code>var1</code> 、<code>var2</code> 找出的主内存中真实的值</li>
</ul>
<p>用该对象当前的值与<code>var5</code>比较，如果相同，更新<code>var5+var4</code>并且返回true；如果不相同继续取值然后在比较，直到更新完成。</p>
<p>简单来说，<strong>CAS （CompareAndSwap）</strong> 比较当前工作内存中的值和主内存中的值，如果相同则执行规定操作，否则继续比较直到主内存和工作内存中的值一致为止。</p>
<p><strong>CAS优缺点</strong></p>
<ul>
<li><p>优点：非阻塞的轻量级的乐观锁，通过CPU指令实现，在资源竞争不激烈的情况下性能高，相比synchronized重量锁，synchronized会进行比较复杂的加锁、解锁和唤醒操作。</p>
</li>
<li><p>缺点：</p>
<ul>
<li><code>ABA</code>问题： 线程C、D；线程D将A修改为B后又修改为A，此时C线程以为A没有改变过。<code>java</code>的原子类<code>AtomicStampedReference</code>，通过<strong>控制变量值的版本号</strong>来保证CAS的正确性。具体解决思路就是在变量前追加上版本号，每次变量更新的时候把版本号加一，那么<code>A - B - A</code>就会变成<code>1A - 2B - 3A</code>。</li>
<li>自旋时间过长，消耗CPU资源，如果资源竞争激烈，多线程自旋长时间消耗资源。</li>
</ul>
</li>
</ul>
<h4 id="LongAdder"><a href="#LongAdder" class="headerlink" title="LongAdder"></a>LongAdder</h4><p><strong>AtomicLong 的缺陷</strong></p>
<p>AtomicLong 的 Add() 是依赖自旋不断的 CAS 去累加一个 Long 值。如果在竞争激烈的情况下，CAS 操作不断的失败，就会有大量的线程不断的自旋尝试 CAS 会造成 CPU 的极大的消耗。</p>
<p><strong>LongAdder</strong> </p>
<p>LongAdder 功能类似 AtomicLong ，在低并发情况下二者表现差不多，在高并发情况下 LongAdder 的表现就会好很多。</p>
<p>LongAdder先尝试一次CAS更新，如果失败会转而通过<code>Cell[]</code>的方式更新值，如果计算index的方式足够散列，那么在并发量大的情况下，多个线程定位到同一个cell的概率也就越低，这有点类似于分段锁的意思。</p>
<p>当需要在高并发下有较好的性能表现，且<strong>对值的精确度要求不高时，可以使用LongAdder</strong>（例如网站访问人数计数）。 当需要保证线程安全，可允许一些性能损耗，要求高精度时，需要使用AtomicLong（例如自增id）。</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p><strong>AtomicBoolean</strong></p>
<p>常用于控制某一件事只让一个线程执行，并仅能执行一次。</p>
<p><strong>AtomicIntegerFieldUpdater</strong></p>
<p>这个类的核心作用是要更新一个指定的类的某一个字段的值。并且这个字段一定要用volatile修饰同时还不能是static的。</p>
<p><strong>AtomicLongArray</strong></p>
<p>这个类实际上维护了一个Array数组，我们在对数值进行更新的时候，会多一个索引值让我们更新。</p>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>synchronized是java中的一个关键字，是一种 同步锁。在synchronized关键字作用范围内，同一时刻只能有一个线程对其进行操作的。</p>
<p>它可以修饰的对象主要有四种：</p>
<ul>
<li>修饰代码块：大括号括起来的代码，作用于调用的对象</li>
<li>修饰方法：整个方法，作用于调用的对象</li>
<li>修饰静态方法：整个静态方法，作用于所有对象</li>
<li>修饰类：括号括起来的部分，作用于所有对象</li>
</ul>
<h3 id="原子性操作各方法间的对比"><a href="#原子性操作各方法间的对比" class="headerlink" title="原子性操作各方法间的对比"></a>原子性操作各方法间的对比</h3><ul>
<li>synchronized：不可中断锁，适合竞争不激烈，可读性好</li>
<li>Lock：可中断锁，多样化同步，竞争激烈时能维持常态</li>
<li>Atomic：竞争激烈时能维持常态，比Lock性能好，每次只能同步一个值</li>
</ul>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>导致可见性失效的原因：</p>
<ul>
<li>线程交叉执行</li>
<li>重排序结合线程交叉执行</li>
<li>共享变量更新后的值没有在工作内存与主存间及时更新</li>
</ul>
<p>JVM对于可见性的实现，提供了synchronized和volatile。</p>
<h3 id="synchronized-1"><a href="#synchronized-1" class="headerlink" title="synchronized"></a>synchronized</h3><p>JMM关于synchronized的两条规定：</p>
<ul>
<li>线程解锁前，必须把共享变量的最新值刷新到主内存</li>
<li>线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值（注意：<strong>加锁与解锁是同一把锁</strong>）</li>
</ul>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>volatile通过加入<strong>内存屏障</strong>和<strong>禁止重排序</strong>优化来实现</p>
<ul>
<li><p>对volatile变量写操作时，会在写操作后加入一条store屏障指令，将本地内存中的共享变量值刷新到主内存</p>
<p><img src="http://image.onebug.tech/image-20210504003303719.png" alt="image-20210504003303719"></p>
</li>
<li><p>对volatile变量读操作时，会在读操作前加入一条load屏障指令，从主内存中读取共享变量</p>
<p><img src="http://image.onebug.tech/image-20210504003330856.png" alt="image-20210504003330856"></p>
</li>
<li><p>volatile的屏障操作都是cpu级别的</p>
</li>
<li><p>volatile关键字<strong>不具有原子性</strong>，不适合累加值。volatile适合状态验证，在修饰状态标记量时，要保证对：</p>
<ul>
<li>变量的写操作不依赖于当前值</li>
<li>该变量没有包含在具有其他变量的式子中</li>
</ul>
</li>
</ul>
<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>Java内存模型中，允许编译器和处理器对指令进行<strong>重排序</strong>，但是重排序过程不会影响到<strong>单线程</strong>程序的执行，却会影响到多线程并发执行的正确性。</p>
<p>java提供了 volatile、synchronized、Lock可以用来保证有序性。另外，java内存模型具备一些<strong>先天的有序性，即不需要任何手段就能得到保证的有序性。通常被我们成为happens-before原则（先行发生原则）</strong>。如果两个线程的执行顺序无法从happens-before原则推导出来，那么就不能保证它们的有序性，虚拟机就可以对它们进行重排序。</p>
<blockquote>
<p><a href="https://www.cnblogs.com/yanlong300/p/9073338.html">并发之atomicInteger与CAS机制 - 枫飘雪落 - 博客园 (cnblogs.com)</a></p>
<p><a href="https://www.jianshu.com/p/db5c964a61ee">深入理解CAS（乐观锁） - 简书 (jianshu.com)</a></p>
<p><a href="https://juejin.cn/post/6844903891310477325">深入剖析LongAdder是咋干活的 (juejin.cn)</a></p>
<p><a href="https://xilidou.com/2018/11/27/LongAdder/">从 LongAdder 中窥见并发组件的设计思路 | 犀利豆的博客 (xilidou.com)</a></p>
</blockquote>
]]></content>
      <categories>
        <category>java高并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>笔记</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>安全发布对象</title>
    <url>/2021/04/12/java/java%E5%B9%B6%E5%8F%91/ch3%E5%AE%89%E5%85%A8%E5%8F%91%E5%B8%83%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="安全发布对象"><a href="#安全发布对象" class="headerlink" title="安全发布对象"></a>安全发布对象</h1><h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><p>简单来说就是提供一个对象的引用给作用域之外的代码。比如<code>return</code>一个对象，或者作为参数传递到其他类的方法中。</p>
<h2 id="逸出"><a href="#逸出" class="headerlink" title="逸出"></a>逸出</h2><p>如果<strong>一个类还没有构造结束就已经提供给了外部代码一个对象引用</strong>即发布了该对象，此时叫做对象逸出，对象的逸出会破坏线程的安全性。</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnsafeStates</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] states = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;AK&quot;</span>, <span class="string">&quot;AL&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String[] getStates()&#123;</span><br><span class="line">        <span class="keyword">return</span> states;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>states</code>变量作用域是<code>private</code>而我们在<code>getStates</code>方法中却把它发布了，这样就称为数组states逸出了它所在的作用域。</p>
<p>然而更加隐蔽和需要我们注意的是<code>this</code>逸出，这个问题要引起重点关注。观察以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThisEscape</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThisEscape</span><span class="params">(EventSource source)</span>&#123;</span><br><span class="line">        source.registerListener&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">EventListener</span>()&#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(Event e)</span>&#123;</span><br><span class="line">                    doSomething(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//一些初始化工作</span></span><br><span class="line">        value = <span class="number">7</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">(Event e)</span>&#123;</span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在构造方法中我们定义了一个匿名内部类，匿名内部类是一个事件监听类，当事件监听类注册完毕后，实际上我们已经将<code>EventListener</code>匿名内部类发布出去了，而此时我们实际上已经携带了<code>this</code>逸出，重点在于这个时候我们还有一些初始化工作没有做完，这也就是上面所说的，一个类还没有构造结束我们已经将发布了。</p>
<h2 id="安全发布对象-1"><a href="#安全发布对象-1" class="headerlink" title="安全发布对象"></a>安全发布对象</h2><p>安全发布对象，共有四种方法</p>
<ul>
<li>在静态初始化函数中初始化一个对象引用</li>
<li>将对象的引用保存到<code>volatile</code>类型域或者<code>AtomicReference</code>对象中</li>
<li>对象的引用保存到某个正确构造对象的<code>final</code>类型域中</li>
<li>将对象的引用保存到一个由锁保护的域中</li>
</ul>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>下面我们用各种单例模式来演示其中的几种方法：</p>
<h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><p><strong>懒汉式（最简式）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonExample</span> &#123;</span><br><span class="line">    <span class="comment">//私有构造函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonExample</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SingletonExample</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态工厂方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonExample <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SingletonExample</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在多线程环境下，当两个线程同时访问这个方法，同时制定到<code>instance==null</code>的判断。都判断为<code>null</code>，接下来同时执行<code>new</code>操作，这样类的构造函数被执行了两次。一旦构造函数中涉及到某些资源的处理，那么就会发生错误。所以说最简懒汉式是<strong>线程不安全的</strong>。</p>
<p><strong>懒汉式（synchronized）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在类的静态方法上使用synchronized修饰</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SingletonExample <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用synchronized修饰静态方法后，同一时间只有一个线程访问该方，保证了线程安全性，但会造成性能损耗。</p>
<p><strong>懒汉式（双重同步锁模式）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonExample</span> &#123;</span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonExample</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单例对象</span></span><br><span class="line">    <span class="comment">//在对象声明时使用volatile关键字修饰，阻止CPU的指令重排。</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">SingletonExample</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 静态的工厂方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonExample <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123; <span class="comment">// 双重检测机制</span></span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonExample.class) &#123; <span class="comment">// 同步锁</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">SingletonExample</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>先判断一次后，再锁定整个类，再加上一次的双重同步锁，保证了最大程度上的避免耗损性能。</p>
<p>为什么要使用<code>volatile</code>关键字修饰对象引用？</p>
<p>执行new操作的时候，CPU会进行了三次指令：</p>
<ol>
<li><code>memory = allocate()</code> 分配对象的内存空间</li>
<li><code>ctorInstance()</code> 初始化对象</li>
<li><code>instance = memory</code> 设置instance指向刚分配的内存</li>
</ol>
<p>在程序运行过程中，CPU为提高运算速度会做出违背代码原有顺序的优化。我们称之为乱序执行优化或者说是指令重排。<br>那么上面知识点中的三步指令极有可能被优化为1、3、2的顺序。当我们有两个线程A与B，A线程遵从1、3、2的顺序，经过了两此<code>instance</code>的空值判断后，执行了<code>new</code>操作，并且cpu在某一瞬间刚结束指令3，并且还没有执行指令2。而在此时线程B恰巧在进行第一次的<code>instance</code>空值判断，由于线程A执行完3指令，为<code>instance</code>分配了内存，线程B判断<code>instance</code>不为空，直接执行<code>return</code>，返回了<code>instance</code>，这样就出现了错误。</p>
<p><img src="http://image.onebug.tech/20180409165630129" alt="img"></p>
<h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonExample</span> &#123;</span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonExample</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SingletonExample</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingletonExample</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态的工厂方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonExample <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>饿汉模式由于单例实例是在类装载的时候进行创建，因此只会被执行一次，所以它是<strong>线程安全</strong>的。如果构造函数中有着大量的操作要做，类的装载时间会很长。要是只做了类的构造，却没有使用构造好的对象，那么会造成资源浪费。所以饿汉模式适用于以下场景：私有构造函数在实现的时候没有太多的处理，占用系统资源少；这个类在实例化后很大概率会被使用。</p>
<h3 id="枚举式"><a href="#枚举式" class="headerlink" title="枚举式"></a>枚举式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonExample</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonExample <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Singleton.INSTANCE.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line">        <span class="keyword">private</span> SingletonExample singleton;</span><br><span class="line"></span><br><span class="line">        Singleton() &#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> <span class="title class_">SingletonExample</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> SingletonExample <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> singleton;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由于枚举类的特殊性，因为Java保证枚举类的每个枚举都是单例，上诉代码构造函数<code>Singleton</code>方法只会被实例化一次，且是这个类被调用之前。对比懒汉与饿汉模式，它的<strong>优势很明显</strong>。</p>
]]></content>
      <categories>
        <category>java高并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>笔记</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>不可变对象</title>
    <url>/2021/04/13/java/java%E5%B9%B6%E5%8F%91/ch4%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="不可变对象"><a href="#不可变对象" class="headerlink" title="不可变对象"></a>不可变对象</h1><p>不可变对象（Immutable Object）：对象一旦被创建后，对象所有的状态及属性在其生命周期内不会发生任何变化。发布不可变对象是安全的。</p>
<span id="more"></span>

<h2 id="自定义不可变类"><a href="#自定义不可变类" class="headerlink" title="自定义不可变类"></a>自定义不可变类</h2><p>通常来说，创建不可变类原则有以下几条：</p>
<ul>
<li><p>所有成员变量必须是<code>private</code>，同时用<code>final</code>修饰</p>
</li>
<li><p>将类声明为<code>final</code>，不允许类被继承 </p>
</li>
<li><p>不提供能够修改原有对象状态的方法，最常见的方式是不提供<code>setter</code>方法</p>
</li>
<li><p>通过构造器初始化所有成员变量，引用类型的成员变量必须进行<strong>深拷贝(deep copy)</strong></p>
</li>
<li><p>在<code>get</code>方法中不直接返回对象的本身，而是克隆对象，返回对象的拷贝。</p>
</li>
</ul>
<p>下面是一个Immutable Object的例子，该对象可以用在并发环境下而没有线程安全问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name,String address)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAddress</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, address=&#x27;&quot;</span> + address + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Java-unmodifiablexxx"><a href="#Java-unmodifiablexxx" class="headerlink" title="Java unmodifiablexxx"></a>Java unmodifiablexxx</h2><p>使用Java的<code>Collections</code>类的<code>unmodifiablexxx</code>相关方法，可以创建不可变对象。<code>xxx</code>方法包含：Collection、List、Map、Set….</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImmutableExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        map.put(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">        Map&lt;Integer, Integer&gt; unmodifiableMap = Collections.unmodifiableMap(map);</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, unmodifiableMap.get(<span class="number">1</span>));</span><br><span class="line">        unmodifiableMap.put(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>UnmodifiableMap</code>对<code>map</code>的<strong>更新方法（比如put、remove等）进行了重写</strong>，均返回<code>UnsupportedOperationException</code>异常，这样就做到了<code>map</code>对象的不可变。</p>
<h4 id="Guava-Immutablexxx"><a href="#Guava-Immutablexxx" class="headerlink" title="Guava Immutablexxx"></a>Guava Immutablexxx</h4><p>使用<code>Guava</code>的<code>Immutablexxx</code>类也可以创建不可变对象。<code>xxx</code>同样包含很多类型：Collection、List、Map、Set….</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ImmutableMap&lt;Integer, Integer&gt; map = ImmutableMap.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<p><code>Immutable</code>相关类使用了跟Java的<code>unmodifiable</code>相关类相似的实现方法。</p>
]]></content>
      <categories>
        <category>java高并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>笔记</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>线程不安全类与同步容器</title>
    <url>/2021/04/16/java/java%E5%B9%B6%E5%8F%91/ch6%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%B1%BB%E4%B8%8E%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h1 id="线程不安全类"><a href="#线程不安全类" class="headerlink" title="线程不安全类"></a>线程不安全类</h1><p>如果一个类的对象同时可以被多个线程访问，并且你不做特殊的同步或并发处理，那么它就很容易表现出线程不安全的现象。比如抛出异常、逻辑处理错误等。下面列举一下常见的线程不安全的类及对应的线程安全类：</p>
<span id="more"></span>

<h2 id="StringBuilder-与-StringBuffer"><a href="#StringBuilder-与-StringBuffer" class="headerlink" title="StringBuilder 与 StringBuffer"></a>StringBuilder 与 StringBuffer</h2><p>StringBuilder是线程不安全的，而StringBuffer是线程安全的。StringBuffer的方法使用了<code>synchronized</code>关键字修饰。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//StringBuffer的方法使用了synchronized关键字修饰。</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    toStringCache = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SimpleDateFormat-与-jodatime插件"><a href="#SimpleDateFormat-与-jodatime插件" class="headerlink" title="SimpleDateFormat 与 jodatime插件"></a>SimpleDateFormat 与 jodatime插件</h2><p>SimpleDateFormat 类在处理时间的时候，如下写法是线程不安全的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyyMMdd&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程调用方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        simpleDateFormat.parse(<span class="string">&quot;20180208&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;parse exception&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以使用线程封闭等手段，也可以使用jodatime插件来转换时间，Joda 类具有不可变性，因此它们的实例无法被修，可以保证线程安全性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">DateTimeFormatter</span> <span class="variable">dateTimeFormatter</span> <span class="operator">=</span> DateTimeFormat.forPattern(<span class="string">&quot;yyyyMMdd&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, i, DateTime.parse(<span class="string">&quot;20180208&quot;</span>, dateTimeFormatter).toDate());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ArrayList-HashSet-HashMap…"><a href="#ArrayList-HashSet-HashMap…" class="headerlink" title="ArrayList,HashSet,HashMap…"></a>ArrayList,HashSet,HashMap…</h2><p>像ArrayList,HashSet,HashMap 等Collection类均是线程不安全的，我们以ArrayList举例分析一下源码：</p>
<p>首先看看这个类所拥有的<strong>部分</strong>属性字段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 列表元素集合数组</span></span><br><span class="line"><span class="comment">     * 如果新建ArrayList对象时没有指定大小，那么会将EMPTY_ELEMENTDATA赋值给elementData，</span></span><br><span class="line"><span class="comment">     * 并在第一次添加元素时，将列表容量设置为DEFAULT_CAPACITY </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 列表大小，elementData中存储的元素个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以通过这两个字段我们可以看出，ArrayList的实现主要就是用了一个Object的数组，用来保存所有的元素，以及一个size变量用来保存当前数组中已经添加了多少元素。</p>
<p>接着我们看下最重要的add操作时的源代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加一个元素时，做了如下两步操作</span></span><br><span class="line"><span class="comment">     * 1.判断列表的capacity容量是否足够，是否需要扩容</span></span><br><span class="line"><span class="comment">     * 2.真正将元素放在列表的元素数组里面</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ensureCapacityInternal()</code>这个方法的详细代码我们可以暂时不看，它的作用就是判断如果将当前的新元素加到列表后面，列表的<code>elementData</code>数组的大小是否满足，如果size + 1的这个需求长度大于了<code>elementData</code>这个数组的长度，那么就要对这个数组进行<strong>扩容</strong>。</p>
<p>由此看到add元素时，实际做了两个大的步骤：</p>
<ol>
<li>判断<code>elementData</code>数组容量是否满足需求</li>
<li>在<code>elementData</code>对应位置上设置值</li>
</ol>
<p>这样也就出现了第一个导致线程不安全的隐患，在<strong>多个线程进行add操作时可能会导致<code>elementData</code>数组越界</strong>。具体逻辑如下：</p>
<ol>
<li>列表大小为9，即size&#x3D;9</li>
<li>线程A开始进入add方法，这时它获取到size的值为9，调用<code>ensureCapacityInternal</code>方法进行容量判断。</li>
<li>线程B此时也进入add方法，它获取到size的值也为9，也开始调用<code>ensureCapacityInternal</code>方法。</li>
<li>线程A发现需求大小为10，而<code>elementData</code>的大小就为10，可以容纳。于是它不再扩容，返回。</li>
<li>线程B也发现需求大小为10，也可以容纳，返回。</li>
<li>线程A开始进行设置值操作， <code>elementData[size++] = e</code> 操作。此时size变为10。</li>
<li>线程B也开始进行设置值操作，它尝试设置<code>elementData[10] = e</code>，而<code>elementData</code>没有进行过扩容，它的标最大为9。于是此时会报出一个数组越界的异常<code>ArrayIndexOutOfBoundsException</code>.</li>
</ol>
<p>另外第二步 <code>elementData[size++] = e</code> 设置值的操作同样会导致线程不安全。从这儿可以看出，这步操作也不是一个原子操作，它由如下两步操作构成：</p>
<ol>
<li><code>elementData[size] = e;</code></li>
<li><code>size = size + 1;</code></li>
</ol>
<p>也就是说，当多线程环境下执行时，又可能会发生第二个导致线程不安全的隐患：<strong>一个线程的值覆盖另一个线程添加的值</strong>。</p>
<p>对应的线程安全类有哪些呢？接下来就涉及到我们同步容器。</p>
<h1 id="同步容器"><a href="#同步容器" class="headerlink" title="同步容器"></a>同步容器</h1><p>同步容器分两类，一种是Java提供好的类，另一类是Collections类中的相关同步方法。</p>
<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p>Vector实现了List接口，Vector实际上就是一个数组，和ArrayList非常的类似，但是内部的方法都是使用<code>synchronized</code>修饰过的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//vector 的add 方法实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是Vector也不是完全的线程安全的，比如：</p>
<p><strong>删除与获取并发操作</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VectorExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Vector&lt;Integer&gt; vector = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                vector.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">                        vector.remove(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">                        vector.get(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            thread1.start();</span><br><span class="line">            thread2.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：报错<code>java.lang.ArrayIndexOutOfBoundsException: Array index out of range</code><br>原因分析：同时发生获取与删除的操作。当两个线程在同一时间都判断了vector的size，假设都判断为9，而下一刻线程1执行了remove操作，随后线程2才去get，所以就出现了错误。<strong>synchronized关键字可以保证同一时间只有一个线程执行该方法，但是多个线程同时分别执行remove、add、get操作的时候就无法控制了。</strong></p>
<p><strong>使用foreach\iterator遍历Vector的时候进行增删操作，也会出现问题</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VectorExample3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 报错java.util.ConcurrentModificationException</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">(Vector&lt;Integer&gt; v1)</span> &#123; <span class="comment">// foreach</span></span><br><span class="line">        <span class="keyword">for</span>(Integer i : v1) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i.equals(<span class="number">3</span>)) &#123;</span><br><span class="line">                v1.remove(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 报错java.util.ConcurrentModificationException</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">(Vector&lt;Integer&gt; v1)</span> &#123; <span class="comment">// iterator</span></span><br><span class="line">        Iterator&lt;Integer&gt; iterator = v1.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            <span class="keyword">if</span> (i.equals(<span class="number">3</span>)) &#123;</span><br><span class="line">                v1.remove(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Vector&lt;Integer&gt; vector = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line">        vector.add(<span class="number">1</span>);</span><br><span class="line">        vector.add(<span class="number">2</span>);</span><br><span class="line">        test1(vector);</span><br><span class="line">        test2(vector);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决办法：在使用iterator进行增删操作的时候，加上Lock或者synchronized同步措施或者并发容器</p>
<h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="comment">// Make sure the value is not null</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Makes sure the key is not already in the hashtable.</span></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    <span class="keyword">for</span>(; entry != <span class="literal">null</span> ; entry = entry.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">old</span> <span class="operator">=</span> entry.value;</span><br><span class="line">            entry.value = value;</span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addEntry(hash, key, value, index);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码分析</p>
<ul>
<li><strong>使用了synchronized修饰</strong></li>
<li>保证安全性<strong>不允许空值</strong></li>
<li>HashMap和HashTable都使用哈希表来存储键值对</li>
</ul>
<h2 id="Collections类中的相关同步方法"><a href="#Collections类中的相关同步方法" class="headerlink" title="Collections类中的相关同步方法"></a>Collections类中的相关同步方法</h2><p><img src="http://image.onebug.tech/synContainer.png" alt="synContainer"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; list = Collections.synchronizedList(Lists.newArrayList());</span><br><span class="line"><span class="comment">//多线程调用方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    list.add(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java高并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>笔记</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>线程封闭</title>
    <url>/2021/04/15/java/java%E5%B9%B6%E5%8F%91/ch5%E7%BA%BF%E7%A8%8B%E5%B0%81%E9%97%AD/</url>
    <content><![CDATA[<h1 id="线程封闭"><a href="#线程封闭" class="headerlink" title="线程封闭"></a>线程封闭</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>当访问共享变量时，往往需要加锁来保证数据同步。<strong>一种避免使用同步的方式就是不共享数据。如果仅在单线程中访问数据，就不需要同步了，这种技术称为线程封闭。</strong></p>
<p>线程封闭技术有一个常见的应用，JDBC的Connection对象。Connection对象在实现的时候并没有对线程安全做太多的处理，JDBC的规范里也没有要求Connection对象必须是线程安全的。实际在服务器应用程序中，线程从连接池获取了一个Connection对象，使用完再把Connection对象返回给连接池，由于大多数请求都是由单线程采用同步的方式来处理的，并且在Connection对象返回之前，连接池不会将它分配给其他线程。因此这种连接管理模式处理请求时隐含的将Connection对象封闭在线程里面，这样我们使用的<strong>Connection对象虽然本身不是线程安全的，但是它通过线程封闭也做到了线程安全。</strong></p>
<span id="more"></span>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="Ad-hoc-线程封闭"><a href="#Ad-hoc-线程封闭" class="headerlink" title="Ad-hoc 线程封闭"></a>Ad-hoc 线程封闭</h3><p><code>Ad-hoc</code>线程封闭是指，维护线程封闭性的职责完全由程序实现来承担。Ad-hoc线程封闭是非常脆弱的，因为没有任何一种语言特性，例如可见性修饰符或局部变量，能将对象封闭到目标线程上。事实上，对线程封闭对象（例如，GUI应用程序中的可视化组件或数据模型等）的引用通常保存在公有变量中。</p>
<h3 id="堆栈封闭"><a href="#堆栈封闭" class="headerlink" title="堆栈封闭"></a>堆栈封闭</h3><p>堆栈封闭其实就是方法中定义局部变量。不存在并发问题。多个线程访问一个方法的时候，<strong>方法中的局部变量都会被拷贝一份到线程的栈中</strong>（Java内存模型），所以局部变量是不会被多个线程所共享的。</p>
<h3 id="ThreadLocal线程封闭"><a href="#ThreadLocal线程封闭" class="headerlink" title="ThreadLocal线程封闭"></a>ThreadLocal线程封闭</h3><p>它是一个特别好的封闭方法，其实<code>ThreadLocal</code>内部维护了一个<code>map</code>，<strong>map的key是每个线程的名称，而map的value就是我们要封闭的对象</strong>。<code>ThreadLocal</code>提供了<code>get</code>、<code>set</code>、<code>remove</code>方法，每个操作都是基于当前线程的，所以它是线程安全的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ThreadLocal的get方法源码</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();<span class="comment">//当前线程对象</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);<span class="comment">//get操作基于当前线程</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ThreadLocal</code>的使用场景：</p>
<ul>
<li>实现单个线程单例以及单个线程上下文信息存储，比如交易id等</li>
<li>实现线程安全，非线程安全的对象使用<code>ThreadLocal</code>之后就会变得线程安全，因为每个线程都会有一个对应的实例</li>
<li>承载一些线程相关的数据，避免在方法中来回传递参数</li>
</ul>
]]></content>
      <categories>
        <category>java高并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>笔记</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>并发容器</title>
    <url>/2021/04/17/java/java%E5%B9%B6%E5%8F%91/ch7%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h1 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h1><p>Java并发容器JUC是三个单词的缩写。是JDK下面的一个包名。即<code>Java.util.concurrency</code>。</p>
<h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><p>CopyOnWriteArrayList 写操作时复制，当有新元素添加到集合中时，从原有的数组中拷贝一份出来，然后在新的数组上作写操作，将原来的数组指向新的数组。整个数组的add操作都是在锁的保护下进行的，防止并发时复制多份副本。读操作是在原数组中进行，不需要加锁。</p>
<span id="more"></span>

<p><strong>源码分析</strong></p>
<p>下面首先展示了CopyOnWriteArrayList中比较重要的成员：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** The lock protecting all mutators */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">transient</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The array, accessed only via getArray/setArray. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br></pre></td></tr></table></figure>

<p>CopyOnWriteArrayList使用了ReentrantLock来支持并发操作，array就是实际存放数据的数组对象。ReentrantLock是一种支持重入的独占锁，任意时刻只允许一个线程获得锁。下面首先展示了add方法的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock(); <span class="comment">//上锁，只允许一个线程进入</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray(); <span class="comment">// 获得当前数组对象</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);<span class="comment">//拷贝到一个新的数组中</span></span><br><span class="line">        newElements[len] = e;<span class="comment">//插入数据元素</span></span><br><span class="line">        setArray(newElements);<span class="comment">//将新的数组对象设置回去</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();<span class="comment">//释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在来分析一下读操作，下面是get方法的细节：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> E <span class="title function_">get</span><span class="params">(Object[] a, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以发现是非常简单的，而且<strong>读是允许多个线程进入的</strong>。</p>
<p>下面来分析一下CopyOnWriteArrayList的迭代器。下面是两个重要的变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/** Snapshot of the array */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object[] snapshot;</span><br><span class="line"><span class="comment">/** Index of element to be returned by subsequent call to next.  */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> cursor;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>遍历的时候首先会获得当前数组对象的一个拷贝，称为快照，然后遍历的操作会在该快照上进行。</strong>获取了迭代器之后再对CopyOnWriteArrayList进行写操作会，迭代器不会感知到这种变化。每一个线程都将获得当前时刻的一个快照，所以不需要加锁就可以安全的实现遍历。</p>
<p><strong>设计思想</strong></p>
<ol>
<li>读写分离</li>
<li>最终一致性</li>
<li>使用时另外开辟空间，防止并发冲突</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>写操作时<strong>复制消耗内存</strong>，如果元素比较多时候，容易导致young gc 和full gc。</li>
<li>不能用于实时读的场景。由于复制和add操作等需要时间，故读取时可能读到旧值。<strong>能做到最终一致性，但无法满足实时性的要求，更适合读多写少的场景</strong>。如果无法知道数组有多大，或者add,set操作有多少，慎用此类,在大量的复制副本的过程中很容易出错。</li>
</ol>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>Map 这样的 <code>Key Value</code> 在软件开发中是非常经典的结构，常用于在内存中存放数据。</p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>众所周知 HashMap 底层是基于 <code>数组 + 链表</code> 组成的，不过在 jdk1.7 和 1.8 中具体实现稍有不同。</p>
<p><strong>Base 1.7</strong></p>
<p><img src="http://image.onebug.tech/5cd1d2be77958.jpg" alt="img"></p>
<p><strong>Base 1.8</strong></p>
<p>其实一个很明显的地方就是：当 Hash 冲突严重时，在桶上形成的链表会变的越来越长，这样在查询时的效率就会越来越低；时间复杂度为 <code>O(N)</code>。因此 1.8 中重点优化了这个查询效率，判断当前链表的大小是否大于预设的阈值，大于时就要转换为红黑树。</p>
<p><img src="http://image.onebug.tech/5cd1d2c1c1cd7.jpg" alt="img"></p>
<p><strong>线程不安全</strong></p>
<p>HashMap 扩容的时候会调用 <code>resize()</code> 方法，就是这里的并发操作容易在一个桶上形成<strong>环形链表</strong>；这样当获取一个不存在的 key 时，计算出的 index 正好是环形链表的下标就会出现死循环。</p>
<blockquote>
<p><a href="https://coolshell.cn/articles/9606.html#%E9%97%AE%E9%A2%98%E7%9A%84%E7%97%87%E7%8A%B6">疫苗：Java HashMap的死循环 | 酷 壳 - CoolShell</a></p>
</blockquote>
<h3 id="ConcurrentHashMap-1"><a href="#ConcurrentHashMap-1" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p><strong>Base 1.7</strong></p>
<p><img src="http://image.onebug.tech/5cd1d2c5ce95c.jpg" alt="img"></p>
<p>如图所示，是由 Segment 数组、HashEntry 组成，和 HashMap 一样，仍然是数组加链表。</p>
<p>它的核心成员变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Segment 数组，存放数据时首先需要定位到具体的 Segment 中。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Segment&lt;K,V&gt;[] segments;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Set&lt;K&gt; keySet;</span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Segment</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">2249069246763182397L</span>;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 和 HashMap 中的 HashEntry 作用一样，真正存放数据的桶</span></span><br><span class="line">       <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">transient</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">transient</span> <span class="type">int</span> threshold;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原理上来说：ConcurrentHashMap 采用了<strong>分段锁技术</strong>，其中 <strong>Segment 继承于 ReentrantLock</strong>。不会像 HashTable 那样不管是 put 还是 get 操作都需要做同步处理<strong>，理论上 ConcurrentHashMap 支持 CurrencyLevel （Segment 数组数量）的线程并发</strong>。每当一个线程占用锁访问一个 Segment 时，不会影响到其他的 Segment。</p>
<p><strong>Base 1.8</strong></p>
<p><img src="http://image.onebug.tech/5cd1d2ce33795.jpg" alt="img"></p>
<p>1.7 已经解决了并发问题，并且能支持 N 个 Segment 这么多次数的并发，但查询遍历链表效率太低。1.8抛弃了原有的 Segment 分段锁，而采用了 <code>CAS + synchronized</code> 来保证并发安全性。</p>
<h2 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a>ConcurrentSkipListMap</h2><p>底层实现采用SkipList跳表<br>曾经有人用ConcurrentHashMap与ConcurrentSkipListMap做性能测试，在4个线程1.6W的数据条件下，前者的数据存取速度是后者的4倍左右。但是后者有几个前者不能比拟的优点：</p>
<ul>
<li>Key是<strong>有序</strong>的</li>
<li>支持<strong>更高的并发</strong>，存储时间与线程数无关</li>
</ul>
<blockquote>
<p>安全共享对象策略:</p>
<ul>
<li>线程限制：一个被线程限制的对象，由线程独占，并且只能被占有它的线程修改</li>
<li>共享只读：一个共享只读的U帝乡，在没有额外同步的情况下，可以被多个线程并发访问，但是任何线程都不能修改它</li>
<li>线程安全对象：一个线程安全的对象或者容器，在内部通过同步机制来保障线程安全，多以其他线程无需额外的同步就可以通过公共接口随意访问他</li>
<li>被守护对象：被守护对象只能通过获取特定的锁来访问。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>java高并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>笔记</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>AQS-锁</title>
    <url>/2021/04/19/java/java%E5%B9%B6%E5%8F%91/ch9AQS%E9%94%81/</url>
    <content><![CDATA[<h1 id="AQS锁"><a href="#AQS锁" class="headerlink" title="AQS锁"></a>AQS锁</h1><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p><strong>ReentrantLock的使用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建锁：使用Lock对象声明，使用ReentrantLock接口创建</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="comment">//使用锁：在需要被加锁的方法中使用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>源码分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化方面：</span></span><br><span class="line"><span class="comment">//在new ReentrantLock的时候默认给了一个不公平锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//也可以加参数来初始化指定使用公平锁还是不公平锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>功能：</p>
<ul>
<li>tryLock()：仅在调用时锁定未被另一个线程保持的情况下才获取锁定。</li>
<li>tryLock(long timeout, TimeUnit unit)：如果锁定在给定的时间内没有被另一个线程保持且当前线程没有被中断，则获取这个锁定。</li>
<li>lockInterruptbily：如果当前线程没有被中断的话，那么就获取锁定。如果中断了就抛出异常。</li>
<li>isLocked：查询此锁定是否由任意线程保持</li>
<li>isHeldByCurrentThread：查询当前线程是否保持锁定状态。</li>
<li>isFair：判断是不是公平锁</li>
<li>……</li>
</ul>
<p><strong>与synchronized的区别</strong></p>
<ul>
<li>可重入性：两者的锁都是可重入的，差别不大，有线程进入锁，计数器自增1，等下降为0时才可以释放锁</li>
<li>锁的实现：synchronized是基于JVM实现，ReentrantLock是JDK实现的。</li>
<li>性能区别：在最初的时候，二者的性能差别差很多，当synchronized引入了偏向锁、轻量级锁（自旋锁）后，二者的性能差别不大，官方推荐synchronized（优化时其实是借用了ReentrantLock的CAS技术，试图在用户态就把问题解决，避免进入内核态造成线程阻塞）</li>
<li>功能区别：<ul>
<li>便利性：synchronized更便利，它是由编译器保证加锁与释放。ReentrantLock是需要手动释放锁，所以为了避免忘记手工释放锁造成死锁，所以最好在finally中声明释放锁。</li>
<li>锁的细粒度和灵活度，ReentrantLock优于synchronized</li>
</ul>
</li>
</ul>
<p><strong>ReentrantLock独有的功能</strong></p>
<ul>
<li><p>可以指定是公平锁还是<strong>非公平锁</strong>，sync只能是非公平锁。</p>
<blockquote>
<p>公平锁就是先等待的线程先获得锁</p>
</blockquote>
</li>
<li><p>提供了一个Condition类，可以<strong>分组唤醒</strong>需要唤醒的线程，而synchronized要么随机唤醒一个线程，要么全部唤醒。</p>
</li>
<li><p>通过<code>lock.lockInterruptibly()</code>提供能够中断等待锁的线程的功能</p>
</li>
<li><p>ReentrantLock是一种自旋锁，通过循环调用CAS操作来实现加锁。由于避免了进入内核态的阻塞状态，性能比较好。</p>
</li>
</ul>
<p><strong>是否弃用synchronized？</strong></p>
<p>从上边的介绍，看上去ReentrantLock不仅拥有synchronized的所有功能，而且有一些功能synchronized无法实现的特性。性能方面，ReentrantLock也不比synchronized差，那么到底我们要不要放弃使用synchronized呢？<strong>答案是不要这样做</strong>。</p>
<p>J.U.C包中的锁类是高级用户的工具，除非说你对Lock的高级特性有特别清楚的了解以及有明确的需求，或有明确的证据表明同步已经成为可伸缩性的瓶颈的时候，否则我们还是继续使用synchronized。相比较这些高级的锁定类，synchronized还是有一些优势的，比如synchronized不需要手动释放锁。还有当JVM使用synchronized管理锁定请求和释放时，JVM在生成线程转储时能够包括锁定信息，这些信息对调试非常有价值，它们可以标识死锁以及其他异常行为的来源。</p>
<p><strong>如何选择锁？</strong></p>
<ul>
<li>当只有少量竞争者，使用synchronized</li>
<li>竞争者不少但是线程增长的趋势是能预估的，使用ReetrantLock</li>
</ul>
<h2 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h2><p>ReentrantReadWriteLock（读写锁）允许多个线程在没有写入时同时读取，只允许一个线程写入。如果一直存在读操作，那么写锁一直在等待没有读的情况出现，这样我的写锁就永远也获取不到，就会<strong>造成等待获取写锁的线程饥饿</strong>。平时使用的场景并不多，平时使用的场景并不多。</p>
<h2 id="StempedLock"><a href="#StempedLock" class="headerlink" title="StempedLock"></a>StempedLock</h2><p>要进一步提升并发执行效率，Java 8引入了新的读写锁：StampedLock。改进之处在于：读的过程中也允许获取写锁后写入，这样一来，我们读的数据就可能不一致，所以，需要一点额外的代码来判断读的过程中是否有写入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">StampedLock</span> <span class="variable">stampedLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">(<span class="type">double</span> deltaX, <span class="type">double</span> deltaY)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> stampedLock.writeLock(); <span class="comment">// 获取写锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            x += deltaX;</span><br><span class="line">            y += deltaY;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            stampedLock.unlockWrite(stamp); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">distanceFromOrigin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> stampedLock.tryOptimisticRead(); <span class="comment">// 获得一个乐观读锁</span></span><br><span class="line">        <span class="comment">// 注意下面两行代码不是原子操作</span></span><br><span class="line">        <span class="comment">// 假设x,y = (100,200)</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">currentX</span> <span class="operator">=</span> x;</span><br><span class="line">        <span class="comment">// 此处已读取到x=100，但x,y可能被写线程修改为(300,400)</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">currentY</span> <span class="operator">=</span> y;</span><br><span class="line">        <span class="comment">// 此处已读取到y，如果没有写入，读取是正确的(100,200)</span></span><br><span class="line">        <span class="comment">// 如果有写入，读取是错误的(100,400)</span></span><br><span class="line">        <span class="keyword">if</span> (!stampedLock.validate(stamp)) &#123; <span class="comment">// 检查乐观读锁后是否有其他写锁发生</span></span><br><span class="line">            stamp = stampedLock.readLock(); <span class="comment">// 获取一个悲观读锁</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                currentX = x;</span><br><span class="line">                currentY = y;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                stampedLock.unlockRead(stamp); <span class="comment">// 释放悲观读锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(currentX * currentX + currentY * currentY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和ReadWriteLock相比，写入的加锁是完全一样的，不同的是读取。注意到首先我们通过<code>tryOptimisticRead()</code>获取一个乐观读锁，并返回版本号。接着进行读取，读取完成后，我们通过<code>validate()</code>去验证版本号，如果在读取过程中没有写入，版本号不变，验证成功，我们就可以放心地继续后续操作。如果在读取过程中有写入，版本号会发生变化，验证将失败。在失败的时候，我们再通过获取悲观读锁再次读取。由于写入的概率不高，程序在绝大部分情况下可以通过乐观读锁获取数据，极少数情况下使用悲观读锁获取数据。</p>
<p>可见，StampedLock把读锁细分为乐观读和悲观读，能进一步提升并发效率。但这也是有代价的：一是代码更加复杂，二是StampedLock是不可重入锁，不能在一个线程中反复获取同一个锁。</p>
<blockquote>
<p>乐观锁的意思就是乐观地估计读的过程中大概率不会有写入，因此被称为乐观锁。反过来，悲观锁则是读的过程中拒绝有写入，也就是写入必须等待。显然乐观锁的并发效率更高，但一旦有小概率的写入导致读取的数据不一致，需要能检测出来，再读一遍就行</p>
</blockquote>
]]></content>
      <categories>
        <category>java高并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>笔记</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>AQS</title>
    <url>/2021/04/18/java/java%E5%B9%B6%E5%8F%91/ch8AQS/</url>
    <content><![CDATA[<h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><p> AQS（AbstractQueuedSynchronizer）是用来构建锁或者其他同步组件的基础框架，它使用了一个int成员变量来表示状态，通过内置的FIFO（first in，first out）队列来完成资源获取线程的排队工作。</p>
<span id="more"></span>

<h2 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h2><p>同步队列（一个FIFO双向队列）是AQS的核心，用来完成同步状态的管理，当线程获取同步状态失败时，AQS会将当前线程以及等待状态等信息构造成一个节点并加入到同步队列，同时会阻塞当前线程。</p>
<p><img src="https://img2018.cnblogs.com/blog/1055780/201911/1055780-20191129233118009-1456342769.png" alt="img"></p>
<h3 id="同步状态"><a href="#同步状态" class="headerlink" title="同步状态"></a>同步状态</h3><p>AQS中维持一个全局的int状态码<strong>state</strong>，线程通过修改（加&#x2F;减指定的数量）码是否成功来决定当前线程是否成功获取到同步状态。</p>
<p>AQS支持两种获取同步状态的模式既独占式和共享式。顾名思义，独占式模式同一时刻只允许一个线程获取同步状态，而共享模式则允许多个线程同时获取。</p>
<p><img src="http://image.onebug.tech/1055780-20191129233117600-2113769929.jpg" alt="img"></p>
<h3 id="独占模式获取与释放状态"><a href="#独占模式获取与释放状态" class="headerlink" title="独占模式获取与释放状态"></a>独占模式获取与释放状态</h3><p>独占模式既同一时间只能由一个线程持有同步状态。当多个线程竞争时(acquire)，获取到同步状态的线程会将当前线程赋值给<code>Thread exclusiveOwnerThread</code>属性（AQS父类中）来标记当前状态被线程独占。其他线程将被构造成Node加入到同步队列中。</p>
<p><strong>获取同步状态</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取同步状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. tryAcquire    尝试获取同步状态; </span></span><br><span class="line"><span class="comment">     * 2.1 addWaiter     如果尝试获取到同步状态失败，则加入到同步队列中; </span></span><br><span class="line"><span class="comment">     * 2.2 acquireQueued 在队列中尝试获取同步状态.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>多线程并发获取（修改）同步状态, 修改同步状态成功的线程标记为拥有同步状态</li>
</ol>
<p><img src="http://image.onebug.tech/1055780-20191129233118430-1256054001.png" alt="img"></p>
<ol start="2">
<li>获取失败的线程，加入到同步队列的队尾；加入到队列中后，如果当前节点的前驱节点为头节点再次尝试获取同步状态。如果头节点的下一个节点尝试获取同步状态失败后，会进入等待状态；其他节点则继续自旋。</li>
</ol>
<p><img src="http://image.onebug.tech/1055780-20191129233118771-1689741253.png"></p>
<p><img src="https://img2018.cnblogs.com/blog/1055780/201911/1055780-20191129233119143-1476789162.png" alt="img"></p>
<p>总结：</p>
<p><img src="http://image.onebug.tech/1055780-20191129233119985-476209714.png" alt="img"></p>
<p><strong>释放同步状态</strong></p>
<p>当线程执行完相应逻辑后，需要释放同步状态，使后继节点有机会同步状态（让出资源，让排队的线程使用）。这时就需要调用release(int arg)方法。调用该方法后，会唤醒后继节点。</p>
<ol>
<li>释放同步状态，唤醒后继节点</li>
</ol>
<p><img src="http://image.onebug.tech/1055780-20191129233120861-935232279.png" alt="img"></p>
<ol start="2">
<li><p>后继节点获取同步状态成功，头节点出队。需要注意的事，出队操作是间接的，有节点获取到同步状态时，会将当前节点设置为head，而原本的head设置为null。</p>
<blockquote>
<p>当同步队列中头节点唤醒后继节点时，此时可能有其他线程尝试获取同步状态。假设获取成功，将会被设置为头节点。头节点后续节点获取同步状态失败。</p>
</blockquote>
<p><img src="http://image.onebug.tech/1055780-20191129233121530-1946057717.png" alt="img"></p>
</li>
</ol>
<h3 id="共享模式获取与释放状态"><a href="#共享模式获取与释放状态" class="headerlink" title="共享模式获取与释放状态"></a>共享模式获取与释放状态</h3><p>共享模式和独占模式最主要的区别是在<strong>支持同一时刻有多个线程同时获取同步状态</strong>。为了避免带来额外的负担，在上文中提到的同步队列中都是用独占模式进行讲述，其实同步队列中的节点应该是独占和共享节点并存的。</p>
<p><img src="https://img2018.cnblogs.com/blog/1055780/201911/1055780-20191129233125056-1459011349.png" alt="img"></p>
<p><strong>获取同步状态</strong></p>
<ol>
<li>首先至少要调用一次tryAcquireShared(arg)方法，如果返回值大于等于0表示获取成功。</li>
<li>当获取锁失败时，则创建一个共享类型的节点并进入一个同步队列，然后进入队列中进入自旋状态（阻塞，唤醒两种状态来回切换，直到获取到同步状态为止）</li>
<li>当队列中的等待线程被唤醒以后就重新尝试获取锁资源，如果成功则<strong>唤醒后面还在等待的共享节点并把该唤醒事件传递下去，即会依次唤醒在该节点后面的所有共享节点</strong>，否则继续挂起等待。</li>
</ol>
<p><img src="http://image.onebug.tech/1055780-20191129233126033-2079605281.png" alt="img"></p>
<p>当一个同享节点获取到同步状态，并唤醒后面等待的共享状态的结果如下图所示：</p>
<p><img src="http://image.onebug.tech/1055780-20191129233127018-1280581551.png" alt="img"></p>
<p><strong>释放同步状态</strong></p>
<p>释放同步状态后，同步队列的变化过程和共享节点获取到同步状态后的变化过程一致，此处不再进行赘述。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>AQS通过一个int同步状态码，和一个（先进先出）队列来控制多个线程访问资源</strong></li>
<li>支持独占和共享两种模式获取同步状态码</li>
<li><strong>当线程获取同步状态失败会被加入到同步队列中</strong></li>
<li>当线程释放同步状态，会唤醒后继节点来获取同步状态</li>
<li><strong>共享模式下的节点获取到同步状态或者释放同步状态时，不仅会唤醒后继节点，还会向后传播，唤醒所有同步节点</strong></li>
<li><strong>使用volatile关键字保证状态码在线程间的可见性，CAS操作保证修改状态码过程的原子性。</strong></li>
</ul>
<h2 id="条件队列"><a href="#条件队列" class="headerlink" title="条件队列"></a>条件队列</h2><p>条件队列：当某个线程调用了wait方法，或者通过Condition对象调用了await相关方法，线程就会进入阻塞状态，并加入到对应条件队列中。</p>
<p>即当对象获取到同步锁之后，如果调用了wait方法，当前线程会进入到条件队列中，并释放锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象)&#123; <span class="comment">// 获取锁失败，线程会加入到同步队列中 </span></span><br><span class="line">	<span class="keyword">while</span>(条件不满足)&#123;</span><br><span class="line">		对象.wait();<span class="comment">// 调用wait方法当前线程加入到条件队列中</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于synchcronized的内置条件队列存在一些缺陷。<strong>每个内置锁都只能有一个相关联的条件队列</strong>，因而存在多个线程可能在同一个条件队列上等待不同的条件谓词，并且在最常见的加锁模式下公开条件队列对象。</p>
<p>与Object配合synchronized相比，基于AQS的Lock&amp;Condition实现的等待唤醒模式更加灵活，<strong>支持多个条件队列，支持等待状态中不响应中断以及超时等待功能</strong>； 其次就是<strong>基于AQS实现的条件队列是”肉眼可见”的</strong>，我们可以通过源代码进行debug，而synchronized则是完全隐式的。</p>
<h3 id="同步队列和条件队列"><a href="#同步队列和条件队列" class="headerlink" title="同步队列和条件队列"></a>同步队列和条件队列</h3><p>与条件队列密不可分的类则是ConditionObject， 是AQS中实现了Condition接口的内部类，通常配合基于AQS实现的锁一同使用。当线程获取到锁之后，可以调用await方法进入条件队列并释放锁，或者调用singinal方法唤醒对应条件队列中等待时间最久的线程并加入到等待队列中。</p>
<p>在AQS中，线程会被封装成Node对象加入队列中，而<strong>条件队列中则复用了同步队列中的Node对象</strong>。</p>
<p><img src="http://image.onebug.tech/201912222329_295.jpg" alt="img"></p>
<h3 id="Condition相关方法和使用"><a href="#Condition相关方法和使用" class="headerlink" title="Condition相关方法和使用"></a>Condition相关方法和使用</h3><p>Condition接口一共定义了以下几个方法：</p>
<ul>
<li><strong>await():</strong> 当前线程进入等待状态，直到被通知(siginal)或中断【和wait方法语义相同】。</li>
<li><strong>awaitUninterruptibly():</strong> 当前线程进入等待状态，直到被通知，对中断不敏感。</li>
<li><strong>awaitNanos(long timeout):</strong> 当前线程进入等待状态直到被通知(siginal)，中断或超时。</li>
<li><strong>awaitUnitil(Date deadTime):</strong> 当前线程进入等待状态直到被通知(siginal)，中断或到达某个时间。</li>
<li><strong>signal():</strong> 唤醒一个等待在Condition上的线程，该线程从等待方法返回前必须获得与Condition关联的锁【和notify方法语义相同】</li>
<li><strong>signalAll():</strong> 唤醒所有等待在Condition上的线程，能够从等待方法返回的线程必须获得与Condition关联的锁【和notifyAll方法语义相同】。</li>
</ul>
<p><strong>使用</strong></p>
<p>下面是一个线程等待与唤醒的例子，其中用1234序号标出了日志输出顺序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ReentrantLock</span> <span class="variable">reentrantLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> reentrantLock.newCondition();<span class="comment">//创建condition</span></span><br><span class="line">    <span class="comment">//线程1</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            reentrantLock.lock();</span><br><span class="line">            log.info(<span class="string">&quot;wait signal&quot;</span>); <span class="comment">// 1</span></span><br><span class="line">            condition.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;get signal&quot;</span>); <span class="comment">// 4</span></span><br><span class="line">        reentrantLock.unlock();</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="comment">//线程2</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        reentrantLock.lock();</span><br><span class="line">        log.info(<span class="string">&quot;get lock&quot;</span>); <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        condition.signalAll();<span class="comment">//发送信号</span></span><br><span class="line">        log.info(<span class="string">&quot;send signal&quot;</span>); <span class="comment">// 3</span></span><br><span class="line">        reentrantLock.unlock();</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>分析：</p>
<ol>
<li>线程1调用了reentrantLock.lock()，线程进入AQS等待队列，输出”wait signal”</li>
<li>接着调用了awiat方法，线程从AQS队列中移除，锁释放，直接加入condition的等待队列中</li>
<li>线程2因为线程1释放了锁，拿到了锁，输出”get lock”</li>
<li>线程2执行condition.signalAll()发送信号，输出”send signal”</li>
<li>condition队列中线程1的节点接收到信号，从condition队列中拿出来放入到了AQS的等待队列，这时线程1并没有被唤醒。</li>
<li>线程2调用unlock释放锁，因为AQS队列中只有线程1，因此AQS释放锁按照从头到尾的顺序，唤醒线程1</li>
<li>线程1继续执行，输出”get signal”，并进行unlock操作。</li>
</ol>
</blockquote>
<h3 id="条件队列入队操作"><a href="#条件队列入队操作" class="headerlink" title="条件队列入队操作"></a>条件队列入队操作</h3><p>当线程获取到锁之后，Condition对象调用await相关的方法，线程会从同步队列中退出，进入到对应的条件队列中。</p>
<p><img src="http://image.onebug.tech/201912222331_843.jpg" alt="img"></p>
<h3 id="条件队出队操作"><a href="#条件队出队操作" class="headerlink" title="条件队出队操作"></a>条件队出队操作</h3><p>Condition对象调用signal或者signalAll方法时，方法唤醒对应条件队列中的相关线程并加入到同步队列中。</p>
<p><img src="http://image.onebug.tech/201912222332_191.jpg" alt="img"></p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ol>
<li>条件队列和同步队列在Java中有两种实现：synchronized关键字和基于AQS</li>
<li>每个（基于synchronized的）内置锁都只能有一个相关联的条件队列，会存在多个线程可能在同一个条件队列上等待不同的条件谓词；而（基于AQS实现的）显式锁支持多个条件队列</li>
<li>与wait，notify，notifyAll 对应的方法时Conditoin接口中的await，signal，signalAll，他们具有相同的语义</li>
</ol>
]]></content>
      <categories>
        <category>java高并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>笔记</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发包的基石--抽象同步队列(AQS)</title>
    <url>/2021/10/27/java/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/AQS/</url>
    <content><![CDATA[<p><code>AbstractQueuedSynchronizer</code> 抽象同步队列简称AQS ，它是实现同步器的基础组件，并发包中锁的底层就是使用AQS 实现的。另外，大多数开发者可能永远不会直接使用AQS ，但是知道其原理对于架构设计还是很有帮助的。</p>
<span id="more"></span>

<h1 id="LockSupport-工具类"><a href="#LockSupport-工具类" class="headerlink" title="LockSupport 工具类"></a>LockSupport 工具类</h1><p>在剖析AQS之前，我们先来介绍<code>LockSupport</code>工具类，<code>LockSupport</code> 是使用<code>Unsafe</code> 类实现的，它的主要作用是挂起和唤醒线程，该工具类是创建锁和其他同步类的基础。</p>
<p><code>LockSupport</code> 类与每个使用它的线程都会关联一个许可证，在默认情况下调用<code>LockSupport</code> 类的方法的线程是不持有许可证的。下面介绍<code>LockSupport</code> 中的几个主要函数：</p>
<ul>
<li><p><code>void park()</code>方法：<strong>用于挂起进程</strong>。如果调用<code>park</code> 方法的线程没有拿到了与<code>LockSupport</code> 关联的许可证，调用线程会被禁止参与线程的调度， 也就是会被阻塞挂起。</p>
</li>
<li><p><code>void unpark(Thread thread)</code>方法：<strong>用于唤醒进程</strong>。当一个线程调用<code>unpark</code> 时，如果参数thread 线程没有持有thread 与<code>LockSupport</code> 类关联的许可证， 则让thread 线程持有。如果thread 之前因调用<code>park()</code>而被挂起，则调用<code>unpark</code> 后，thread获得许可证，该线程会被唤醒。</p>
<blockquote>
<p>可以把许可证不恰当地比成一次性的“免死金牌”，<code>park()</code>的线程消耗”免死金牌”，如果没有”免死金牌“，那么只能”上法场”（线程阻塞挂起）了。<code>unpark(thread)</code>授予thread线程”免死金牌”</p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread thread=<span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;child thread start park&quot;</span>);</span><br><span class="line">    <span class="comment">//调用park ，由于当前线程不持有许可证，挂起自己</span></span><br><span class="line">    LockSupport.park();</span><br><span class="line">    System.out.println(<span class="string">&quot;child thread begin unpark&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">thread.start();</span><br><span class="line"></span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">System.out.println (<span class="string">&quot;main thread begin  unpark&quot;</span>);</span><br><span class="line"><span class="comment">//调用unpark 使得 thread 持有许可证，park方法返回</span></span><br><span class="line">LockSupport.unpark(thread);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用thread的interrupt()方法会得到同样的输出</span></span><br></pre></td></tr></table></figure>

<p><img src="http://image.onebug.tech/image-20211024211304771.png" alt="image-20211024211304771"></p>
<h1 id="抽象同步队列AQS"><a href="#抽象同步队列AQS" class="headerlink" title="抽象同步队列AQS"></a>抽象同步队列AQS</h1><p><img src="http://image.onebug.tech/20200603222156602.png" alt="简单理解AQS （ 抽象的队列同步器）_迟到的help的博客-CSDN博客_抽象同步队列器"></p>
<p>AQS 是一个FIFO 的双向队列，其内部通过节点<code>head</code> 和<code>tail</code> 记录队首和队尾元素。</p>
<h2 id="节点元素"><a href="#节点元素" class="headerlink" title="节点元素"></a>节点元素</h2><p>我们首先讨论的是队列元素<code>Node</code> 。线程就保存在<code>Node</code>的<code>thread</code> 变量中。<code>Node</code> 的类型分为两种：</p>
<ul>
<li><code>SHARED</code> ：线程是获取共享资源时被阻塞挂起后放入AQS 队列</li>
<li><code>EXCLUSIVE</code>： 线程是获取独占资源时被挂起后放入AQS 队列的。</li>
</ul>
<p><code>Node</code>还拥有<code>waitStatus</code>变量，用于记录当前线程等待状态，可以为<code>CANCELLED</code> （线程被取消了）、<code>SIGNAL</code> （ 线程需要被唤醒）、<code>CONDITION</code> （线程在条件队列里面等待〉和<code>PROPAGATE</code> （释放共享资源时需要通知其他节点）。</p>
<h2 id="状态信息的获取"><a href="#状态信息的获取" class="headerlink" title="状态信息的获取"></a>状态信息的获取</h2><p>AQS 中维持了一个单一的状态信息<code>state</code>，可以通过<code>getState</code> 、<code>setState</code> 、<br><code>compareAndSetState</code> 函数修改其值。对于不同的锁阻塞和同步器，<code>state</code>拥有不同的含义。</p>
<p>对于AQS 来说，线程同步的关键是对状态值<code>state</code> 进行操作。根据<code>state</code> 是否属于一个线程，操作<code>state</code> 的方式分为<strong>独占方式</strong>和<strong>共享方式</strong>。</p>
<h3 id="独占方式"><a href="#独占方式" class="headerlink" title="独占方式"></a>独占方式</h3><p>使用独占方式获取的资源是与具体线程绑定的，就是说如果一个线程获取到了资源，就会<strong>标记</strong>是这个线程获取到了，其他线程再尝试操作<code>state</code> 获取资源时会发现当前该资源不是自己持有的，就会在获取失败后被阻塞。</p>
<p>在独占方式下，获取与释放资源的流程如下：</p>
<ol>
<li><p>当一个线程调用<code>acquire(int arg）</code> 方法获取独占资源时，会首先使用<code>tryAcquire</code> 方法尝试获取资源， 具体是设置状态变量<code>state</code> 的值，成功则直接返回，失败则将当前线程封装为类型为<code>Node.EXCLUSIVE</code> 的<code>Node</code> 节点后插入到AQS 阻塞队列的尾部，并调用<code>LockSupport.park(this)</code> 方法挂起自己。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">//尝试获取state资源</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        <span class="comment">//获取资源失败则调用addWaiter方法创建节点，加入队列，阻塞挂起</span></span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        </span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当一个线程调用<code>release(int arg）</code>方法时会尝试使用<code>tryRelease</code> 操作释放资源，这里是设置状态变量<code>state</code> 的值，然后调用<code>LockSupport.unpark(thread)</code>方法激活AQS 队列里面被阻塞的一个线程 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">//设置state值</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//唤醒队列中的进程</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>需要注意的是， AQS 类并没有提供可用的<code>tryAcquire</code> 和<code>tryRelease</code> 方法，正如AQS是锁阻塞和同步器的基础框架一样， <code>tryAcquire</code> 和<code>tryRelease</code> 需要由具体的子类来实现。子类在实现<code>tryAcquire</code> 和<code>tryRelease</code> 时要根据具体场景使用CAS 算法尝试修改<code>state</code> 状态值，成功则返回<code>true</code>，否则返回<code>false</code>。子类还需要明确，在调用<code>acquire</code> 和<code>release</code> 方法时<code>state</code>状态值的增减代表什么含义。</p>
<h3 id="共享方式"><a href="#共享方式" class="headerlink" title="共享方式"></a>共享方式</h3><p>对应共享方式的资源与具体线程是不相关的，当多个线程去请求资源时通过CAS 方式竞争获取资源，当一个线程获取到了资源后，另外一个线程再次去获取时如果当前资源还能满足它的需要，则当前线程只需要使用CAS 方式进行获取即可。</p>
<p>在共享方式下，获取与释放资源的流程如下：</p>
<ol>
<li><p>当线程调用<code>acquireShared(int arg)</code> 获取共享资源时，会首先使用<code>tryAcquireShared</code>操作尝试获取资源，具体是设置状态变量state 的值，成功则直接返回，失败则将当前线程封装为类型为<code>Node.SHARED</code> 的Node 节点后插入到AQS阻塞队列的尾部，并使用<code>LockSupport.park(this)</code> 方法挂起自己。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当一个线程调用<code>releaseShared(int arg）</code>时会尝试使用<code>tryReleaseShared</code> 操作释放资源，这里是设置状态变量<code>state</code> 的值，然后使用<code>LockSupport.unpark(thread)</code>激活AQS 队列里面被阻塞的线程。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AQS 类也没有提供可用的<code>tryAcquireShared</code> 和<code>tryReleaseShared</code>方法， 需要由具体的子类实现。</p>
<h3 id="中断的忽略"><a href="#中断的忽略" class="headerlink" title="中断的忽略"></a>中断的忽略</h3><p>独占方式下获取资源有两种函数：<code>void acquire(int arg)</code>和<code>void acquireInterruptibly(int arg)</code>，共享方式也是如此。不带<code>Interruptibly</code> 关键字的方法的意思是<strong>不对中断进行响应</strong>，也就是线程在调用方法获取资源时或者获取资源失败被挂起时，其他线程中断了该线程， 那么该线程不会因为被中断而抛出异常，它还是继续获取资源或者被挂起，也就是说不对中断进行响应，忽略中断。</p>
<h2 id="队列的维护"><a href="#队列的维护" class="headerlink" title="队列的维护"></a>队列的维护</h2><p>队列的维护主要看入队操作，当一个线程获取锁失败后该线程会被转换为Node 节点，然后就会使用<code>enq(final Node node）</code> 方法将该节点插入到AQS 的阻塞队列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="comment">//如果队列为空，创建结点，同时被head和tail引用</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="comment">//cas设置尾结点，不成功就一直重试</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://image.onebug.tech/image-20211025162355530.png" alt="image-20211025162355530"></p>
<h1 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h1><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>和<code>notify</code> 和<code>wait</code> 是配合<code>synchronized</code> 内置锁实现线程间同步的基础设施类似，条件变量的<code>signal</code> 和<code>await</code> 方法是用来配合锁（使用AQS 实现的锁〉实现线程间同步的基础设施。</p>
<p>它们的不同在于， <code>synchronized</code> 同时只能与一个共享变量的<code>notify</code> 或<code>wait</code> 方法实现同步，<br>而AQS 的一个锁可以对应<strong>多个</strong>条件变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ReentrantLock reentrantLock=<span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="comment">//newCondition()方法返回reentrantLock对应的一个条件变量</span></span><br><span class="line">   <span class="keyword">static</span> Condition condition=reentrantLock.newCondition();</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">//获取独占锁</span></span><br><span class="line">               reentrantLock.lock();</span><br><span class="line">               System.out.println(<span class="string">&quot;begin wait &quot;</span>);</span><br><span class="line">               <span class="comment">//调用条件变量的await()方法阻塞挂起</span></span><br><span class="line">               condition.await();</span><br><span class="line">               System.out.println(<span class="string">&quot;end wait&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">finally</span> &#123;</span><br><span class="line">               reentrantLock.unlock();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;).start();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">//获取独占锁</span></span><br><span class="line">               reentrantLock.lock();</span><br><span class="line">               Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">               System.out.println(<span class="string">&quot;begin signal &quot;</span>);</span><br><span class="line">               condition.signal();</span><br><span class="line">               System.out.println(<span class="string">&quot;end signal&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">finally</span> &#123;</span><br><span class="line">               reentrantLock.unlock();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;).start();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://image.onebug.tech/image-20211027192845636.png" alt="image-20211027192845636"></p>
<p>其实这里的<code>reentrantLock</code>对象等价于<code>synchronized</code> 加上共享变量，调用<code>reentrantLock.lock()</code>方法就相当于进入了<code>synchronized</code> 块（获取了共享变量的内置锁），调用<code>reentrantLock.iunlock()</code>方法就相当于退出<code>synchronized</code> 块。调用条件变量的<code>await()</code>方法就相当于调用共享变量的<code>wait()</code>方法，调用条件变量的<code>signal</code> 方法就相当于调用共享变量的<code>notify()</code>方法。调用条件变量的<code>signalAll()</code>方法就相当于调用共享变量的<code>notifyAll()</code>方法。</p>
<h2 id="原理剖析"><a href="#原理剖析" class="headerlink" title="原理剖析"></a>原理剖析</h2><p><code>lock.newCondition()</code>的作用其实是new 了一个在AQS 内部声明的<code>ConditionObject</code> 对象， <code>ConditionObject</code> 是AQS 的内部类，可以访问AQS 内部的变量（例如状态变量<code>state</code> ）和方法。在每个条件变量内部都维护了一个条件队列，用来存放调用条件变量的<code>await()</code>方法时被阻塞的线程。注意这个条件队列是单向队列，和AQS 队列不是一回事。</p>
<p><img src="http://image.onebug.tech/201912222329_295.jpg" alt="浅谈Java中的Condition条件队列，手摸手带你实现一个阻塞队列！ - Java填坑笔记- 博客园"></p>
<p>当线程调用条件变量的<code>await()</code>方法时（必须先调用锁的<code>lock()</code>方法获取锁），在内部会构造一个类型为<code>Node.CONDITION</code> 的node节点，然后将该节点插入条件队列末尾，之后当前线程会释放获取的锁（ 也就是会操作锁对应的<code>state</code> 变量的值），并被阻塞挂起。这时候如果有其他线程调用<code>lock.lock()</code> 尝试获取锁，就会有一个线程获取到锁，如果获取到锁的线程调用了条件变量的<code>await()</code>方法，则该线程也会被放入条件变量的阻塞队列，然后释放获取到的锁，在<code>await()</code>方法处阻塞。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">         <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">     	<span class="comment">//调用addConditionWaiter方法创建新的node节点，并插入到条件队列末尾</span></span><br><span class="line">         <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();</span><br><span class="line"><span class="comment">//释放当前锁</span></span><br><span class="line">         <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);</span><br><span class="line">         <span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//调用park方法阻塞挂起当前线程</span></span><br><span class="line">         <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">             LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">             <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         ...</span><br><span class="line">     &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">addConditionWaiter</span><span class="params">()</span> &#123;</span><br><span class="line">           <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> lastWaiter;</span><br><span class="line">           ...</span><br><span class="line">           <span class="comment">//创建类型为Node.CONDITON的节点</span></span><br><span class="line">           <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">       </span><br><span class="line">       	<span class="comment">//向单向队列尾部插入一个元素</span></span><br><span class="line">           <span class="keyword">if</span> (t == <span class="literal">null</span>)</span><br><span class="line">               firstWaiter = node;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               t.nextWaiter = node;</span><br><span class="line">           lastWaiter = node;</span><br><span class="line">           <span class="keyword">return</span> node;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>当另外一个线程调用条件变量的<code>signaL</code>  方法时（ 必须先调用锁的<code>lock()</code> 方法获取锁），在内部会把条件队列里面队头的一个线程节点从条件队列里面移除并放入AQS 的阻塞队列里面， 然后激活这个线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">//将队列头元素移动到AQS队列</span></span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>笔记</tag>
        <tag>并发</tag>
        <tag>java并发编程之美</tag>
      </tags>
  </entry>
  <entry>
    <title>原子性操作类--高并发下的CAS解决方案</title>
    <url>/2021/10/19/java/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/AtomicLong%E5%92%8CLongAdder/</url>
    <content><![CDATA[<p>JUC 包提供了一系列的原子性操作类，这些类都是使用非阻塞算法CAS 实现的，相比使用锁实现原子性操作这在性能上有很大提高。由于原子性操作类的原理都大致相同，所以本文只讲解最简单的<code>AtomicLong</code> 类及JDK 8 中新增的<code>LongAdder</code> 的实现原理。</p>
<span id="more"></span>

<h1 id="AtomicLong"><a href="#AtomicLong" class="headerlink" title="AtomicLong"></a>AtomicLong</h1><p>JUC 并发包中包含有<code>Atomiclnteger</code> 、<code>AtomicLong</code> 和<code>AtomicBoolean</code> 等原子性操作类，它们的原理类似。AtomicLong 是原子性递增或者递减类，其内部使用<code>Unsafe</code> 来实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicLong</span> <span class="keyword">extends</span> <span class="title class_">Number</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">	<span class="comment">//获取Unsafe实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> Unsafe.getUnsafe();</span><br><span class="line">    <span class="comment">//存放value的偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取value在AtomicLong的偏移量</span></span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicLong.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//实际变量值，使用volatile修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> value;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment">//调用unsafe方法，原子性设置value值为原始值+1， 返回值为原始值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">long</span> <span class="title function_">getAndIncrement</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddLong(<span class="built_in">this</span>, valueOffset, <span class="number">1L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>getAndIncrement()</code>、<code>getAndDecrement()</code>等主要数都是通过调用<code>Unsafe</code> 的<code>getAndAddLong</code> 方法来实现操作，其在JDK8中的实现为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">long</span> <span class="title function_">getAndAddLong</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">long</span> var4)</span> &#123;</span><br><span class="line">        <span class="type">long</span> var6;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">//传入对象地址和实际值偏移量，获取实际值</span></span><br><span class="line">            var6 = <span class="built_in">this</span>.getLongVolatile(var1, var2);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//尝试CAS更新实际值，失败则重试</span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">this</span>.compareAndSwapLong(var1, var2, var6, var6 + var4));</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var6;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="LongAdder"><a href="#LongAdder" class="headerlink" title="LongAdder"></a>LongAdder</h1><p><code>AtomicLong</code> 通过CAS 提供了非阻塞的原子性操作，相比使用阻塞算法的同步器来说它的性能己经很好了，但是使用<code>AtomicLong</code> 时，在高并发下大量线程会同时去竞争更新同一个原子变量，但是由于同时只有一个线程的CAS 操作会成功，这就造成了大量线程竞争失败后，会通过无限循环不断进行自旋尝试CAS 的操作， 而这会白白浪费CPU 资源。JDK 8 新增了一个原子性递增或者递减类<code>LongAdder</code> 用来克服在高并发下使用<code>AtomicLong</code> 的缺点。</p>
<p>既然<code>AtomicLong</code> 的性能瓶颈是由于过多线程同时去竞争一个变量的更新而产生的，那么可以把一个变量分解为多个变量，让同样多的线程去竞争多个资源，从而解决性能问题，这就是<code>LongAdder</code>设计的思路。</p>
<p><img src="http://image.onebug.tech/LongAddr-CAS.png" alt="Java AtomicLong 和LongAdder | A Big Boy Blog - Tech Articls &amp; Notes"></p>
<p><code>LongAdder</code> 在内部维护多个<code>Cell</code> 变量，<code>Cell</code> 类型是<code>AtomicLong</code>的一个改进。这样，在同等并发量的情况下，争夺单个变量更新操作的线程量会减少，这变相地减少了争夺共享资源的并发量。另外，多个线程在争夺同一个<code>Cell</code> 原子变量时如果失败了， 它并不是在当前<code>Cell</code> 变量上一直自旋CAS 重试，而是尝试在其他<code>Cell</code>的变量上进行CAS 尝试，这个改变增加了当前线程重试CAS 成功的可能性。</p>
<p>最后，在获取<code>LongAdder</code>当前值时， 是把所有<code>Cell</code> 变量的value值累加后再加上<code>base</code>返回的。</p>
<p>由于<code>Cells</code> 占用的内存是相对比较大的，所以一开始并不创建它，而是在需要时创建，也就是惰性加载。<code>LongAdder</code> 维护了一个延迟初始化的原子性更新数组（默认情况下<code>Cell</code> 数组是<code>null</code>）和一个基值变量<code>base</code> 。</p>
<p><img src="http://image.onebug.tech/image-20211019171832480.png" alt="image-20211019171832480"></p>
<p> <code>LongAdder</code> 类内部维护着三个变量。获取<code>LongAdder</code> 的真实值时，得到的其实是<code>base</code> 的值与<code>cells</code> 数组里面所有<code>Cell</code> 元素中的<code>value</code> 值的累加，<code>base</code> 是个基础值，默认为0 。<code>cellsBusy</code> 用来实现自旋锁，状态值只有0 和1，使用CAS操作<code>cellsBusy</code> 来保证同时只有一个线程可以进行创建<code>Cell</code> 元素、扩容<code>cells</code> 数组、初始化<code>cells</code> 数组这些操作。</p>
<p><code>LongAdder</code> 类的主要函数有：</p>
<ul>
<li><code>long sum()</code>：返回当前的值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sum</span><span class="params">()</span> &#123;</span><br><span class="line">       Cell[] as = cells; Cell a;</span><br><span class="line">   	<span class="comment">//bash值加上所有Cell内部的value值后就是当前值</span></span><br><span class="line">       <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> base;</span><br><span class="line">       <span class="keyword">if</span> (as != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">               <span class="keyword">if</span> ((a = as[i]) != <span class="literal">null</span>)</span><br><span class="line">                   sum += a.value;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> sum;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>要注意的是，由于计算总和时没有对<code>cells</code>数组进行加锁，所以在累加过程中可能有其他线程对<code>Cell</code> 中的值进行了修改， 也有可能对数组进行了扩容，所以<code>sum</code>返回的值并不是非常精确的， 其返回值并不是一个调用<code>sum</code> 方法时的原子快照值。</p>
<ul>
<li><code>add(long x)</code>：增加给定值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">long</span> x)</span> &#123;</span><br><span class="line">    Cell[] as; <span class="type">long</span> b, v; <span class="type">int</span> m; Cell a;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//cell是否为null，是的话就在基础变量base上累加</span></span><br><span class="line">    <span class="keyword">if</span> ((as = cells) != <span class="literal">null</span> || !casBase(b = base, b + x)) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">boolean</span> <span class="variable">uncontended</span> <span class="operator">=</span> <span class="literal">true</span>;  </span><br><span class="line">        <span class="keyword">if</span> (as == <span class="literal">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            决定当前线程应该访问cells 数组里面的哪一个Cell元素</span></span><br><span class="line"><span class="comment">            其中m 是当前cells数组元素个数－1 , getProbe()获取的是当前线程中变量threadLocalRandomProbe的值</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            (a = as[getProbe() &amp; m]) == <span class="literal">null</span> ||</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//用CAS操作去更新分配到的Cell元素的value 值</span></span><br><span class="line">            !(uncontended = a.cas(v = a.value, v + x)))</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//初始化或扩容cells数组</span></span><br><span class="line">            longAccumulate(x, <span class="literal">null</span>, uncontended);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>longAccumulate</code>源码解析： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">longAccumulate</span><span class="params">(<span class="type">long</span> x, LongBinaryOperator fn,</span></span><br><span class="line"><span class="params">                           <span class="type">boolean</span> wasUncontended)</span> &#123;</span><br><span class="line">     <span class="type">int</span> h;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    初始化当前线程的变量threadLocalRandomProbe的值，</span></span><br><span class="line"><span class="comment">    这个变量在计算当前线程应该被分配到cells数组的哪一个Cell 元素时会用到。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">     <span class="keyword">if</span> ((h = getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">         ThreadLocalRandom.current(); <span class="comment">// force initialization</span></span><br><span class="line">         h = getProbe();</span><br><span class="line">         wasUncontended = <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   </span><br><span class="line">     <span class="type">boolean</span> <span class="variable">collide</span> <span class="operator">=</span> <span class="literal">false</span>;                <span class="comment">// True if last slot nonempty</span></span><br><span class="line">     <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">         Cell[] as; Cell a; <span class="type">int</span> n; <span class="type">long</span> v;</span><br><span class="line">         <span class="keyword">if</span> ((as = cells) != <span class="literal">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">             </span><br><span class="line">             <span class="comment">//当前线程计算要访问的Cell元素下标，然后如果发现对应下标元素的值为null</span></span><br><span class="line">             <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="literal">null</span>) &#123;</span><br><span class="line">                 <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;       <span class="comment">// Try to attach new Cell</span></span><br><span class="line">                     <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     新增一个Cell 元素到cell 数组，</span></span><br><span class="line"><span class="comment">                     并且在将其添加到cells 数组之前要竞争设置cellsBusy 为1</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                     <span class="type">Cell</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cell</span>(x);   <span class="comment">// Optimistically create</span></span><br><span class="line">			</span><br><span class="line">                     <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                         <span class="type">boolean</span> <span class="variable">created</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                         <span class="keyword">try</span> &#123;               <span class="comment">// Recheck under lock</span></span><br><span class="line">                             Cell[] rs; <span class="type">int</span> m, j;</span><br><span class="line">                             <span class="keyword">if</span> ((rs = cells) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                                 (m = rs.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                                 rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="literal">null</span>) &#123;</span><br><span class="line">                                 rs[j] = r;</span><br><span class="line">                                 created = <span class="literal">true</span>;</span><br><span class="line">                             &#125;</span><br><span class="line">                         &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                             cellsBusy = <span class="number">0</span>;</span><br><span class="line">                         &#125;</span><br><span class="line">                         <span class="keyword">if</span> (created)</span><br><span class="line">                             <span class="keyword">break</span>;</span><br><span class="line">                         <span class="keyword">continue</span>;           <span class="comment">// Slot is now non-empty</span></span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">                 collide = <span class="literal">false</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)       <span class="comment">// CAS already known to fail</span></span><br><span class="line">                 wasUncontended = <span class="literal">true</span>;      <span class="comment">// Continue after rehash</span></span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (a.cas(v = a.value, ((fn == <span class="literal">null</span>) ? v + x :</span><br><span class="line">                                          fn.applyAsLong(v, x))))</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= NCPU || cells != as)</span><br><span class="line">                 collide = <span class="literal">false</span>;            <span class="comment">// At max size or stale</span></span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">                 collide = <span class="literal">true</span>;</span><br><span class="line">             </span><br><span class="line">             <span class="comment">/*</span></span><br><span class="line"><span class="comment">             下面数组是扩容cells数组的代码，扩容条件的前提具体就是</span></span><br><span class="line"><span class="comment">             当前cells 的元素个数小于当前机器CPU个数</span></span><br><span class="line"><span class="comment">             并且当前多个线程访问了cells中同一个元素从而导致冲突使其中一个线程CAS失败。</span></span><br><span class="line"><span class="comment">             和初始化一样，需要cas设置cellsBusy值，保证cells数组的互斥访问。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                 <span class="keyword">try</span> &#123;</span><br><span class="line">                     <span class="keyword">if</span> (cells == as) &#123;      <span class="comment">// Expand table unless stale</span></span><br><span class="line">                         <span class="comment">//扩容为原来的两倍</span></span><br><span class="line">                         Cell[] rs = <span class="keyword">new</span> <span class="title class_">Cell</span>[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                         <span class="comment">//将旧的cells数组复制新的cells数组</span></span><br><span class="line">                         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                             rs[i] = as[i];</span><br><span class="line">                         cells = rs;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                     cellsBusy = <span class="number">0</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">                 collide = <span class="literal">false</span>;</span><br><span class="line">                 <span class="keyword">continue</span>;                   <span class="comment">// Retry with expanded table</span></span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">/*CAS 失败的线程重新计算当前线程的随机值threadLocalRandomProbe,</span></span><br><span class="line"><span class="comment">             以减少下次访问cells元素时的冲突机会*/</span></span><br><span class="line">             h = advanceProbe(h);</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">         <span class="comment">//下面是初始化cells数组的代码</span></span><br><span class="line">         </span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">         cellsBusy 是一个状态标识，</span></span><br><span class="line"><span class="comment">         为0说明当前cells 数组没有在被初始化或者扩容，也没有在新建Cell元素，</span></span><br><span class="line"><span class="comment">         当前线程通过casCellsBusy()设置cellsBusy 为l ，</span></span><br><span class="line"><span class="comment">         则当前线程在初始化cells数组时，其他线程就不能进行对cells数组进行初始化。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">             <span class="type">boolean</span> <span class="variable">init</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">             <span class="keyword">try</span> &#123;                           <span class="comment">// Initialize table</span></span><br><span class="line">                 <span class="keyword">if</span> (cells == as) &#123;</span><br><span class="line">                     <span class="comment">//初始化cells 数组元素个数为2</span></span><br><span class="line">                     Cell[] rs = <span class="keyword">new</span> <span class="title class_">Cell</span>[<span class="number">2</span>];</span><br><span class="line">                     <span class="comment">//使用h&amp;1计算当前线程应该访问celll 数组的哪个位置</span></span><br><span class="line">                     rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Cell</span>(x);</span><br><span class="line">                     cells = rs;</span><br><span class="line">                     <span class="comment">//标识cells 数组已经被初始化</span></span><br><span class="line">                     init = <span class="literal">true</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                 <span class="comment">/*重置了cellsBusy 标记。这里没有使用CAS 操作，却是线程安全的，</span></span><br><span class="line"><span class="comment">                 原因是cellsBusy 是volatile类型的，这保证了变量的内存可见性，</span></span><br><span class="line"><span class="comment">                 另外此时其他地方的代码没有机会修改cellsBusy的值*/</span></span><br><span class="line">                 cellsBusy = <span class="number">0</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (init)</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (casBase(v = base, ((fn == <span class="literal">null</span>) ? v + x :</span><br><span class="line">                                     fn.applyAsLong(v, x))))</span><br><span class="line">             <span class="keyword">break</span>;                          <span class="comment">// Fall back on using base</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>阅读上面的源码后，我们基本可以回答以下几个重要问题：</p>
<ul>
<li><p>LongAdder 的结构是怎样的</p>
<p><code>base</code>基值变量，<code>cells</code>数组，<code>cellsBusy</code>标识</p>
</li>
<li><p>当前线程应该访问<code>cells</code>数组里面的哪一个<code>Cell</code> 元素</p>
<p>元素下标通过<code>cells</code>数组长度对<code>threadLocalRandomProbe</code>取模计算得到，<code>threadLocalRandomProbe</code>可以看成是<code>ThreadLocal</code>类型的变量，只与当前线程相关。</p>
</li>
<li><p>如何初始化<code>cells</code>数组？ 略</p>
</li>
<li><p><code>cells</code>数组如何扩容？略</p>
</li>
<li><p>线程访问分配的Cell 元素有冲突后如何处理：扩容（需要满足<code>cells</code> 数组元素个数小于CPU核心数），并重新计算当前线程的<code>threadLocalRandomProbe</code>，减小冲突概率</p>
</li>
<li><p>如何保证线程操作被分配的<code>Cell</code> 元素的原子性：CAS操作</p>
</li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>笔记</tag>
        <tag>并发</tag>
        <tag>java并发编程之美</tag>
      </tags>
  </entry>
  <entry>
    <title>高并发下随机数的获取--ThreadlocalRandom</title>
    <url>/2021/10/16/java/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/ThreadLocal%20Random/</url>
    <content><![CDATA[<h1 id="Random类的局限性"><a href="#Random类的局限性" class="headerlink" title="Random类的局限性"></a>Random类的局限性</h1><p>每个Random 实例里面都有一个原子性的种子变量用来记录当前的种子值，当要生成新的随机数时需要根据当前种子计算新的种子并更新回原子变量。在多线程下使用单个Random 实例生成随机数时，当多个线程同时计算随机数来计算新的种子时，多个线程会竞争同一个原子变量的更新操作，由于原子变量的更新是CAS 操作，同时只有一个线程会成功，所以会造成大量线程进行自旋重试， 这会降低并发性能，所以<code>ThreadLocalRandom</code> 应运而生。</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Random类的核心方法，CAS操作会导致高竞用情况下的性能下降</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">next</span><span class="params">(<span class="type">int</span> bits)</span> &#123;</span><br><span class="line">       <span class="type">long</span> oldseed, nextseed;</span><br><span class="line">       <span class="type">AtomicLong</span> <span class="variable">seed</span> <span class="operator">=</span> <span class="built_in">this</span>.seed;</span><br><span class="line">       <span class="keyword">do</span> &#123;</span><br><span class="line">           oldseed = seed.get();</span><br><span class="line">           nextseed = (oldseed * multiplier + addend) &amp; mask;</span><br><span class="line">       &#125; <span class="keyword">while</span> (!seed.compareAndSet(oldseed, nextseed));</span><br><span class="line">       <span class="keyword">return</span> (<span class="type">int</span>)(nextseed &gt;&gt;&gt; (<span class="number">48</span> - bits));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h1 id="ThreadlocalRandom"><a href="#ThreadlocalRandom" class="headerlink" title="ThreadlocalRandom"></a>ThreadlocalRandom</h1><p>为了弥补多线程高并发情况下Random 的缺陷， <code>ThreadLocalRandom</code>类应运而生。<code>ThreadLocalRandom</code> 使用<code>ThreadLocal</code>的原理，让每个线程都持有一个本地的种子变量，该种子变量只有在使用随机数时才会被初始化。在多线程下计算新种子时是根据自己线程内维护的种子变量进行更新，从而避免了竞争。<br><code>ThreadLocalRandom</code> 类似于<code>ThreadLocal</code> 类，就是个工具类。当线程调用<code>ThreadLocalRandom</code> 的<code>current</code>方法时， <code>ThreadLocalRandom</code> 负责初始化调用线程的<code>threadLocalRandomSeed</code> 变量， 也就是初始化种子。<br>当调用<code>ThreadLocalRandom</code> 的<code>nextlnt</code> 方法时，实际上是获取当前线程的<code>threadLocalRandomSeed</code> 变量作为当前种子来计算新的种子，然后更新新的种子到当前线程的<code>threadLocalRandomSeed</code> 变量，而后再根据新种子并使用具体算法计算随机数。</p>
<blockquote>
<p><code>threadLocalRandomSeed</code> 变量是Thread 类里面的一个普通long 变量</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">//ThreadLocalRandom类的核心代码</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="title function_">nextSeed</span><span class="params">()</span> &#123;</span><br><span class="line">       Thread t; <span class="type">long</span> r; <span class="comment">// read and update per-thread seed</span></span><br><span class="line">       UNSAFE.putLong(t = Thread.currentThread(), SEED,</span><br><span class="line">                      r = UNSAFE.getLong(t, SEED) + GAMMA);</span><br><span class="line">       <span class="keyword">return</span> r;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://image.onebug.tech/image-20211016224505557.png" alt="image-20211016224505557"></p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>笔记</tag>
        <tag>并发</tag>
        <tag>java并发编程之美</tag>
      </tags>
  </entry>
  <entry>
    <title>写时复制与弱一致性--CopyOnWriteArrayList源码剖析</title>
    <url>/2021/10/21/java/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/CopyOnWriteList/</url>
    <content><![CDATA[<p><code>CopyOnWriteArrayList</code> 是一个线程安全的<code>ArrayList</code> ，对其进行的修改操作都是在底层的一个复制的数组（快照）上进行的，也就是使用了<strong>写时复制</strong>策略。</p>
<p><img src="http://image.onebug.tech/image-20211021195250084.png" alt="image-20211021195250084"></p>
<p>在<code>CopyOnWriteArrayList</code> 的类图中，每个<code>CopyOnWriteArrayList</code> 对象里面有一个使用<code>volatile</code>修饰的<code>array</code> 数组对象用来存放具体元素，独占锁<code>lock</code>用来保证同时只有1个线程对<code>array</code>进行修改。</p>
<span id="more"></span>

<h2 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h2><p><code>CopyOnWriteArrayList</code> 的写操作需要上锁，下面是<code>add(E e)</code>添加元素的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">//获取独占锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取array</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">       	<span class="comment">//复制array到新数组，添加元素到新数组</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        <span class="comment">//使用新数组替换原数组</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//释放独占锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setArray</span><span class="params">(Object[] a)</span> &#123;</span><br><span class="line">    array = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>add(E e)</code>操作是通过<code>加锁-复制-添加-覆盖-解锁</code>实现的，保证了线程安全。从代码可以知道，新数组的大小是原来数组大小加一，<code>CopyOnWriteArrayList</code> 是无界数组。</p>
<p>修改、删除、添加元素的这些写操作的思路都差不多，这里不进行赘述。</p>
<h2 id="弱一致性的迭代器"><a href="#弱一致性的迭代器" class="headerlink" title="弱一致性的迭代器"></a>弱一致性的迭代器</h2><p>在讨论读操作前，我们先讨论<code>CopyOnWriteArrayList</code> 中的迭代器的弱一致性。弱一致性是指返回迭代器后，其他线程对list 的增删改对迭代器是不可见的。例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CopyOnWriteArrayList&lt;Integer&gt; copyOnWriteArrayList=</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">Thread thread=<span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    <span class="comment">//写操作</span></span><br><span class="line">    copyOnWriteArrayList.remove(<span class="number">1</span>);</span><br><span class="line">    copyOnWriteArrayList.set(<span class="number">0</span>,<span class="number">100</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//在写操作前获取迭代器</span></span><br><span class="line">Iterator&lt;Integer&gt; iterator=copyOnWriteArrayList.iterator();</span><br><span class="line"><span class="comment">//启动线程</span></span><br><span class="line">thread.start();</span><br><span class="line"><span class="comment">//等待线程执行完毕</span></span><br><span class="line">thread.join();</span><br><span class="line"><span class="comment">//迭代元素</span></span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://image.onebug.tech/image-20211021205356619.png" alt="image-20211021205356619"></p>
<p>源码剖析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">COWIterator</span>&lt;E&gt;(getArray(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">COWIterator</span><span class="params">(Object[] elements, <span class="type">int</span> initialCursor)</span> &#123;</span><br><span class="line">    cursor = initialCursor;</span><br><span class="line">    snapshot = elements;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (! hasNext())</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="keyword">return</span> (E) snapshot[cursor++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> cursor &lt; snapshot.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当调用<code>iterator()</code>方法获取迭代器时实际上会返回一个<code>COWiterator</code> 对象， <code>COWiterator</code> 对象的<code>snapshot</code> 变量保存了当前list 的内容， <code>cursor</code> 是遍历list 时数据的下标。</p>
<p>为什么说snapshot 是list 的快照呢？明明是指针传递的引用啊，而不是副本。如果在该线程使用返回的迭代器代器遍历元素的过程中， 其他线程没有对list 进行增删改，那么snapshot 本身就是list 的array ， 因为它们是引用关系。但是如果在遍历期间其他线程对该list 进行了增删改，那么snapshot 就是快照了，因为增删改后list 里面的数组被新数组替换了，这时候老数组被snapshot引用。这也说明获取迭代器后， 使用该法代器元素时， 其他线程对该list 进行的增删改不可见，<strong>因为它们操作的是两个不同的数组</strong>， 这就是弱一致性。</p>
<h2 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h2><p><code>CopyOnWriteArrayList</code> 的读操作不会上锁，也就是说，<strong>读操作是允许多个线程进入的</strong>。下面是<code>get(int index)</code>获取元素操作的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> E <span class="title function_">get</span><span class="params">(Object[] a, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在如上代码中， 当线程x 调用<code>get</code> 方法获取指定位置的元素时，分两步走， 首先获取<code>array</code> 数组（这里命名为步骤A ），然后通过下标访问指定位置的元素（这里命名为步骤B ) ，这是两步操作， 但是在整个过程中并没有进行加锁同步。也就是说，假设这时候List 内容如图所示，里面有1、2 、3 三个元素。</p>
<p><img src="http://image.onebug.tech/image-20211021201352808.png" alt="image-20211021201352808"></p>
<p>由于执行步骤A 和步骤B 没有加锁，这就可能导致在线程x执行完步骤A 后执行步骤B前， 另外一个线程y进行了<code>remove</code> 操作，假设要线程y要删除元素1， <code>remove</code> 操作首先会获取独占锁， 然后进行写时复制操作，也就是复制一份当前<code>array</code> 数组， 然后在复制的数组里面删除元素1 ，之后让<code>array</code>指向复制的新数组。而这时候<code>array</code>之前指向的数组的引用计数为1而不是0， 因为线程x 还在使用它，这时线程x 开始执行步骤B ，步骤B 操作的数组是线程y 删除元素之前的数组。</p>
<p><img src="http://image.onebug.tech/image-20211021201430872.png" alt="image-20211021201430872"></p>
<p>所以，虽然线程y己经删除了<code>index</code>处的元素，但是线程x 的步骤B 还是<strong>有可能</strong>会返回<code>index</code> 处的元素，这其实就是写时复制策略产生的<strong>弱一致性问题</strong>。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>笔记</tag>
        <tag>并发</tag>
        <tag>java并发编程之美</tag>
      </tags>
  </entry>
  <entry>
    <title>线程封闭的常用策略--ThreadLocal</title>
    <url>/2021/10/10/java/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/ThreadLocal/</url>
    <content><![CDATA[<h1 id="线程封闭"><a href="#线程封闭" class="headerlink" title="线程封闭"></a>线程封闭</h1><p>当访问共享变量时，往往需要加锁来保证数据同步。<strong>一种避免使用同步的方式就是不共享数据。如果仅在单线程中访问数据，就不需要同步了，这种技术称为线程封闭。</strong></p>
<p>线程封闭技术有一个常见的应用，JDBC的Connection对象。Connection对象在实现的时候并没有对线程安全做太多的处理，JDBC的规范里也没有要求Connection对象必须是线程安全的。实际在服务器应用程序中，线程从连接池获取了一个Connection对象，使用完再把Connection对象返回给连接池，由于大多数请求都是由单线程采用同步的方式来处理的，并且在Connection对象返回之前，连接池不会将它分配给其他线程。因此这种连接管理模式处理请求时隐含的将Connection对象封闭在线程里面，这样我们使用的Connection对象虽然本身不是线程安全的，但是它通过线程封闭也做到了线程安全。</p>
<p>实现线程封闭，一般有三种方法：Ad-hoc 线程封闭、堆栈封闭、<strong>ThreadLocal线程封闭</strong>。</p>
<span id="more"></span>

<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p>ThreadLocal 是JDK 包提供的，它提供了线程本地变量，也就是如果你创建了一个ThreadLocal 变量，那么访问这个变量的每个线程都会有这个变量的一个本地副本。当多个线程操作这个变量时，实际操作的是自己本地内存里面的变量，从而避免了线程安全问题。创建一个ThreadLocal 变量后，每个线程都会复制一个变量到自己的本地内存中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//   一个简单ThreadLocal示例</span></span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;String&gt; localVal=<span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        localVal.set(<span class="string">&quot;main THREAD&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            System.out.println(localVal.get());</span><br><span class="line">            localVal.set(<span class="string">&quot;THREAD 1&quot;</span>);</span><br><span class="line">            System.out.println(localVal.get());</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            localVal.set(<span class="string">&quot;THREAD 2&quot;</span>);</span><br><span class="line">            System.out.println(localVal.get());</span><br><span class="line">        &#125;).start();</span><br><span class="line">        </span><br><span class="line">        localVal.remove();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://image.onebug.tech/image-20211010191615958.png" alt="image-20211010191615958"></p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p><img src="http://image.onebug.tech/image-20211010191911770.png" alt="image-20211010191911770"></p>
<p><code>Thread</code> 类中有一个<code>threadLocals</code> 和一个<code>inheritableThreadLocals</code> ， 它们都是<code>ThreadLocalMap</code> 类型的变量， 而<code>ThreadLocalMap</code> 是一个定制化的<code>Hashmap</code> 。其实每个线程的本地变量不是存放在<code>ThreadLocal</code> 实例里面，而是存放在调用线程的<code>threadLocals</code> 变量里面。也就是说， <code>ThreadLocal</code> 类型的本地变量存放在具体的线程内存空间中。而<code>ThreadLocal</code> 就是一个工具壳类，它通过<code>set</code> 方法把<code>value</code> 值放入调用线程的<code>threadLocals</code> 里面并存放起来，当调用线程调用它的get 方法时，再从当前线程的<code>threadLocals</code> 变量里面将其拿出来使用。</p>
<p><code>ThreadLocal</code>工具类的<code>set</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="comment">//获取当前线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">//获取线程对应的ThreadLocalMap</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">    <span class="comment">// 将this作为key,写入ThreadLocalMap </span></span><br><span class="line">    map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ThreadLocal</code>工具类的<code>get</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">    ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li><p>内存泄露与预防：每个线程的本地变量存放在线程自己的内存变量<code>threadLocals</code> 中，如果当前线程一直不消亡， 那么这些本地变量会一直存在， 所以可能会造成内存溢出， 因此使用完毕后要记得调用<code>ThreadLocal</code> 的<code>remove</code> 方法删除对应线程的<code>threadLocals</code> 中的本地变量。</p>
</li>
<li><p><code>InheritableThreadLocal</code>：<code>InheritableThreadLocal</code>继承自<code>ThreadLocal</code> ， 其提供了一个特性，就是让子线程可以访问在父线程中设置的本地变量。它的实现原理是当父线程创建子线程时，构造函数会把父线程中<code>inheritableThreadLocals</code> 变量里面的本地变量复制一份保存到子线程的<code>inheritableThreadLocals</code> 变量里面。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>笔记</tag>
        <tag>并发</tag>
        <tag>java并发编程之美</tag>
      </tags>
  </entry>
  <entry>
    <title>java多线程编程基础（一）</title>
    <url>/2021/10/08/java/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h1><p>在讨论什么是线程前有必要先说下什么是进程，因为线程是进程中的一个实体，线程本身是不会独立存在的。进程是代码在数据集合上的一次运行活动， 是系统进行资源分配和调度的基本单位， 线程则是进程的一个执行路径， 一个进程中至少有一个线程，进程中的多个线程共享进程的资源。操作系统在分配资源时是把资源分配给进程的， 但是CPU 资源比较特殊， 它是被分配到线程的， 因为真正要占用C PU 运行的是线程， 所以也说线程是CPU 分配的基本单位。</p>
<span id="more"></span>

<h1 id="线程的创建与启动"><a href="#线程的创建与启动" class="headerlink" title="线程的创建与启动"></a>线程的创建与启动</h1><p>Java 中有三种线程创建方式，分别为：</p>
<h2 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h2><p>实现<code>Runnable</code> 接口的<code>run</code> 方法。使用<code>lambda</code>简化代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123; System.out.println(<span class="string">&quot;Task #1 is running&quot;</span>); &#125;;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br></pre></td></tr></table></figure>

<h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><p>继承<code>Thread</code> 类并重写<code>run</code> 的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;child thread run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ThreadTest</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><p>使用<code>FutureTask</code> 方式。<code>FutureTask</code>实现了<code>Callable</code>接口，能够获取异步任务的返回值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建异步任务</span></span><br><span class="line">FutureTask&lt;Integer&gt; futureTask=<span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;task#2: cal 1+2&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+<span class="number">2</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">//启动任务</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待任务执行完毕，并返回结果</span></span><br><span class="line"><span class="type">int</span> result=futureTask.get();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;result is &quot;</span>+result);</span><br></pre></td></tr></table></figure>

<h1 id="线程通知与等待"><a href="#线程通知与等待" class="headerlink" title="线程通知与等待"></a>线程通知与等待</h1><h2 id="wait-和notify"><a href="#wait-和notify" class="headerlink" title="wait()和notify()"></a>wait()和notify()</h2><p>当一个线程调用一个共享变量的<code>wait()</code>方法时， 该调用线程会被阻塞挂起， 直到发生下面几件事情之一才返回： </p>
<ul>
<li>其他线程调用了该共享对象的<code>notify()</code>或者<code>notifyAll()</code>方法；</li>
<li>其他线程调用了该线程的<code>interrupt()</code>方法， 该线程抛出<code>InterruptedException</code> 异常返回。</li>
</ul>
<p>一个线程调用共享对象的notify（）方法后，会唤醒一个在该共享变量上调用<code>wait</code>系列方法后被挂起的线程。一个共享变量上可能会有多个线程在等待，具体唤醒哪个等待的线程是<strong>随机</strong>的。不同于<code>notify()</code>函数只会唤醒一个被阻塞到该共享变量上的线程，<code>notifyAll()</code>方法则会唤醒所有在该共享变量上由于调用<code>wait</code> 系列方法而被挂起的线程。</p>
<p><code>notify</code>和<code>wait</code>系列方法，都需要当前线程获取到了共享变量的监视器锁后，才可以调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread thread1=<span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!prepare)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread()+<span class="string">&quot;阻塞挂起中...&quot;</span>);</span><br><span class="line">                lock.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread()+<span class="string">&quot;被唤醒&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程被中断&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">thread1.start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            prepare=<span class="literal">true</span>;</span><br><span class="line">            System.out.println(Thread.currentThread()+<span class="string">&quot;唤醒其他阻塞挂起的线程&quot;</span>);</span><br><span class="line">            lock.notify();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<p><img src="http://image.onebug.tech/image-20211008205319745.png" alt="image-20211008205319745"></p>
<blockquote>
<p>另外需要注意的是，当前线程调用共享变量的<code>wait()</code>方法后只会释放当前共享变量上的锁，如果当前线程还持有其他共享变量的锁，则这些锁是不会被释放的</p>
</blockquote>
<h2 id="虚假唤醒"><a href="#虚假唤醒" class="headerlink" title="虚假唤醒"></a>虚假唤醒</h2><p>另外需要注意的是，一个线程可以从挂起状态变为可以运行状态（ 也就是被唤醒）即使该线程没有被其他线程调用<code>notify()</code>、<code>notifyAll()</code>方法进行通知，或者被中断，或者等待超时，这就是所谓的虚假唤醒。<br>虽然虚假唤醒在应用实践中很少发生，但要防患于未然，做法就是不停地去测试该线程被唤醒的条件是否满足，不满足则继续等待，也就是说在一个循环中调用<code>wait()</code>方法进行防范。退出循环的条件是满足了唤醒该线程的条件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">synchronized (obj)&#123;</span><br><span class="line">    while (!prepare)&#123;</span><br><span class="line">        //阻塞挂起</span><br><span class="line">        obj.wait();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="wait超时"><a href="#wait超时" class="headerlink" title="wait超时"></a>wait超时</h2><ul>
<li><code>wait(long timeout)</code>：该方法相比<code>wait()</code> 方法多了一个超时参数，它的不同之处在于，如果一个线程调用共享对象的该方法挂起后， 没有在指定的timeout ms 时间内被唤醒，那么该函数还是会因为超时而返回。</li>
</ul>
<h1 id="线程的其他方法"><a href="#线程的其他方法" class="headerlink" title="线程的其他方法"></a>线程的其他方法</h1><h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><p>在项目实践中经常会遇到一个场景，就是是需要等待某几件事情完成后才能继续往下执行，比如多个线程加载资源， 需要等待多个线程全部加载完毕再汇总处理。Thread 类中有一个简单的<code>join</code> 方法就可以做这个事情。（事实上不太使用该方法，<code>AQS</code>中的<code>CountdownLatch</code>更为强大和常用）</p>
<h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h2><p>Thread 类中有一个静态的<code>sleep</code>方法，当一个执行中的线程调用了<code>Thread</code> 的<code>sleep</code> 方法后，调用线程会暂时让出指定时间的执行权，也就是在这期间不参与CPU的调度。指定的睡眠时间到了后该函数会正常返回，线程就处于就绪状态，然后参与CPU 的调度，获取到CPU 资源后就可以继续运行了。不同于<code>wait</code>方法，线程在调用<code>sleep</code>方法后，该线程所拥有的监视器资源，比如锁还是持有不让出的。</p>
<h2 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h2><p>Thread 类中有一个静态的yield 方法，当一个线程调用<code>yield</code>方法时，实际就是在暗示线程调度器当前线程请求让出自己的CPU使用，但是线程调度器可以无条件忽略这个暗示。当一个线程调用<code>yield</code> 方法时， 当前线程会让出CPU使用权，然后处于就绪状态，线程调度器会从线程就绪队列里面获取一个线程优先级最高的线程，当然也有可能会调度到刚刚让出CPU 的那个线程来获取CPU 执行权，这也是<code>yield</code>和<code>sleep</code>不同的地方。</p>
<h1 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h1><p>Java 中的线程中断是一种线程间的协作模式，通过设置线程的中断标志并不能直接终止该线程的执行， 而是被中断的线程根据中断状态自行处理。</p>
<ul>
<li><code>void interrup()</code> 方法： 中断线程， 例如，当线程A 运行时，线程B 可以调用钱程A的<code>interrupt()</code>方法来设置线程A 的中断标志为true 并立即返回。<strong>设置标志仅仅是设置标志， 线程A 实际并没有被中断， 它会继续往下执行</strong>。如果线程A 因为调用了<code>wait</code> 系列函数、<code>join</code> 方法或者<code>sleep</code> 方法而被阻塞挂起，这时候若线程B 调用线程A 的<code>interrupt()</code> 方法，线程A 会在调用这些方法的地方抛出<code>InterruptedException</code> 异常而返回。</li>
<li><code>boolean isinterrupte()</code> 方法： 检测当前线程是否被中断，如果是返回<code>true</code> ， 否则返回<code>false</code> 。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread thread=<span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">float</span> i=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (i&lt;<span class="number">1000</span>) &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//                clean up if required</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        thread.interrupt();</span><br><span class="line">        System.out.println(<span class="string">&quot;中断线程&quot;</span>+thread);</span><br></pre></td></tr></table></figure>

<p><img src="http://image.onebug.tech/image-20211008212955074.png" alt="image-20211008212955074"></p>
<p>可以看到，程序没有抛出异常，而是正常执行。</p>
<h1 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h1><p>死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的互相等待的现象，在无外力作用的情况下，这些线程会一直相互等待而无法继续运行下去。</p>
<p>死锁的产生必须具备以下四个条件：</p>
<ul>
<li>互斥条件： 指线程对己经获取到的资源进行排它性使用， 即该资源同时只由一个线程占用。如果此时还有其他线程请求获取该资源，则请求者只能等待，直至占有资源的线程释放该资源。</li>
<li>请求并持有条件： 指一个线程己经持有了至少一个资源， 但又提出了新的资源请求，而新资源己被其他线程占有，所以当前线程会被阻塞，但阻塞的同时并不释放自己己经获取的资源。</li>
<li>不可剥夺条件： 指线程获取到的资源在自己使用完之前不能被其他线程抢占， 只有在自己使用完毕后才由自己释放该资源。</li>
<li>环路等待条件： 指在发生死锁时， 必然存在一个线程→资源的环形链， 即线程集合{TO , TL T2 ，…， Tn ｝中的TO 正在等待一个Tl 占用的资源， Tl 正在等待T2 占用的资源，……Tn 正在等待己被TO 占用的资源。</li>
</ul>
<p>一个线程死锁的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> Object resource1=<span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> Object resource2=<span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Thread threadA=<span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;threadA 尝试获取 resource1中...&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (resource1)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;threadA 获取 resource1成功&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;threadA 尝试获取 resource2中...&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (resource2)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;threadA 获取 resource2成功&quot;</span>);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Thread threadB=<span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;threadB 尝试获取 resource2中...&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (resource2)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;threadB 获取 resource2成功&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;threadB尝试获取 resource1中...&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (resource1)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;threadB 获取 resource1成功&quot;</span>);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://image.onebug.tech/image-20211008214107190.png" alt="image-20211008214107190"></p>
<p>如图所示，<code>threadA</code>和<code>threadB</code>形成了线程死锁。</p>
<p><img src="http://image.onebug.tech/image-20211008213421323.png" alt="image-20211008213421323"></p>
<p>关于如何避免线程死锁，操作系统中有详细介绍，这里不赘述。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>笔记</tag>
        <tag>并发</tag>
        <tag>java并发编程之美</tag>
      </tags>
  </entry>
  <entry>
    <title>java多线程编程基础（二）</title>
    <url>/2021/10/15/java/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><p><code>synchronized块</code>是Java 提供的一种原子性内置锁， <code>Java</code> 中的每个对象都可以把它当作一个同步锁来使用， 这些Java 内置的使用者看不到的锁被称为内部锁，也叫作监视器锁。<code>synchronized</code> 关键字底层原理属于 JVM 层面。线程的执行代码在进入<code>synchronized</code> 代码块前会自动获取内部锁，这时候其他线程访问该同步代码块时会被阻塞挂起。拿到内部锁的线程会在正常退出同步代码块或者抛出异常后或者在同步块内调用了该内置锁资源的<code>wait</code> 系列方法时释放该内置锁。内置锁是排它锁，也就是当一个线程获取这个锁后， 其他线程必须等待该线程释放锁后才能获取该锁。</p>
<span id="more"></span>

<p>由于Java 中的线程是与操作系统的原生线程一一对应的，所以当阻塞一个线程时，需要从用户态切换到内核态执行阻塞操作，这是很耗时的操作，而<code>synchronized</code>的使用就会导致上下文切换。</p>
<blockquote>
<p>庆幸的是，JDK1.6 对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销，所以现在的 <code>synchronized</code> 锁效率也很不错了。</p>
</blockquote>
<p><code>synchronized</code> 同时具有内存语义，这个内存语义可以解决共享变量内存可见性问题。进入<code>synchronized</code> 块的内存语义是把在<code>synchronized</code> 块内使用到的变量从线程的工作内存中清除，这样在<code>synchronized</code> 块内使用到该变量时就不会从线程的工作内存中获取，而是<strong>直接从主内存中获取</strong>。退出<code>synchronized</code> 块的内存语义是把在<code>synchronized</code> 块内对共享变量的修改刷新到主内存。</p>
<h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><p>使用锁的方式可以解决共享变量内存可见性问题，但是使用锁太笨重，因为它会带来线程上下文的切换开销。对于解决内存可见性问题， Java 还提供了一种弱形式的同步，也就是使用<code>volatile</code> 关键字。该关键字可以确保对一个变量的更新对其他线程马上可见。当一个变量被声明为<code>volatile</code> 时，线程在<strong>写入变量</strong>时不会把值缓存在寄存器或者其他地方，而是会把值<strong>刷新回主内存</strong>。当其他线程<strong>读取该共享变量</strong>时，会<strong>从主内存重新获取</strong>最新值，而不是使用当前线程的工作内存中的值。<code>volatile</code> 的内存语义和<code>synchronized</code> 的内存语义有相似之处，具体来说就是，当线程写入了<code>volatile</code> 变量值时就等价于线程退出<code>synchronized</code> 同步块（把写入工作内存的变量值同步到主内存），读取<code>volatile</code> 变量值时就相当于进入同步块（ 先清空本地内存变量值，再从主内存获取最新值）。</p>
<p><code>volatile</code> 只能保证共享变量的可见性，不能解决<code>读—改一写</code>等的原子性问题。下例中，<code>cnt</code>变量已经使用<code>volatile</code> 修饰，最终结果却不正确。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Unsafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntegerCount</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"><span class="comment">//线程不安全</span></span><br><span class="line">        Thread[] threads=<span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;threads.length;i++)&#123;</span><br><span class="line">            threads[i]=<span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">10000</span>;j++)&#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;cnt:&quot;</span>+cnt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://image.onebug.tech/image-20211015202422807.png"></p>
<p>一般来说，volatile适合状态验证，不适合累加值，在修饰状态标记量时，要保证对：</p>
<ul>
<li>变量的写操作不依赖于当前值</li>
<li>该变量没有包含在具有其他变量的式子中</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//volatile经典用法</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">boolean</span> asleep</span><br><span class="line">...</span><br><span class="line">	<span class="keyword">while</span>(!asleep)&#123;</span><br><span class="line">		<span class="comment">//do some work</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><p>在Java 中， 锁在并发处理中占据了一席之地，但是使用锁有一个不好的地方，就是当一个线程没有获取到锁时会被阻塞挂起， 这会导致线程上下文的切换和重新调度开销。Java 提供了非阻塞的<code>volatile</code> 关键字来解决共享变量的可见性问题， 这在一定程度上弥补了锁带来的开销问题，但是volatile 只能保证共享变量的可见性，不能解决<code>读—改一写</code>等的原子性问题。CAS 即Compare and Swap ，其是JDK 提供的非阻塞原子性操作， 它通过硬件保证了比较更新操作的原子性。JDK 里面的Unsafe 类提供了一系列的<code>compareAndSwap*</code>方法，例如:</p>
<ul>
<li><code>boolean compareAndSwapLong(Object obj ,long valueOffset,long expect, long update）</code>方<br>法： 其中<code>compareAndSwap</code> 的意思是比较并交换。CAS 有四个操作数， 分别为： 对象内存位置、对象中的变量的偏移量、变量预期值和新的值。其操作含义是， 如果对象<code>obj</code> 中内存偏移量为<code>valueOffset</code> 的变量值为<code>expect</code> ，则使用新的值<code>update</code> 替换旧的值<code>expect</code> 。这是处理器提供的一个原子性指令。</li>
</ul>
<h1 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h1><p>JDK 的<code>rt.jar</code>包中的<code>Unsafe</code> 类提供了硬件级别的原子性操作， <code>Unsafe</code> 类中的方法都是<code>native</code> 方法，它们使用JNI的方式访问本地C++实现，除了上文提到的<code>compareAndSwap*</code>方法，其中还有几个重要的方法：</p>
<ul>
<li><code>long objectFieldOffset(Field field）</code> 方法： 返回指定的变量在所属类中的内存偏移地址，该偏移地址仅仅在该Unsafe 函数中访问指定宇段时使用。</li>
<li><code>void park(boolean isAbsolute, long time）</code> 方法： 阻塞当前线程</li>
<li><code>void unpark(Object thread）</code> 方法：唤醒调用<code>park</code>后阻塞的线程。</li>
</ul>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h2><ul>
<li><p>悲观锁指对数据被外界修改持保守态度，认为数据很容易就会被其他线程修改，所以在数据被处理前先对数据进行加锁，并在整个数据处理过程中，使数据处于锁定状态。悲观锁的实现往往依靠数据库提供的锁机制，即在数据库中，在对数据记录操作前给记录加排它锁。如果获取锁失败， 则说明数据正在被其他线程修改， 当前线程则等待或者抛出异常。如果获取锁成功，则对记录进行操作，然后提交事务后释放排它锁。</p>
</li>
<li><p>乐观锁是相对悲观锁来说的，它认为数据在一般情况下不会造成冲突，所以在访问记录前不会加排它锁，而是在进行数据提交更新时，才会正式对数据冲突与否进行检测。</p>
</li>
</ul>
<h2 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h2><p>根据线程获取锁的抢占机制，锁可以分为公平锁和非公平锁：</p>
<ul>
<li>公平锁表示线程获取锁的顺序是按照线程请求锁的时间早晚来决定的，也就是最早请求锁的线程将最早获取到锁。</li>
<li>非公平锁可以在运行时闯入，也就是先来不一定先得。</li>
</ul>
<h2 id="独占锁和共享锁"><a href="#独占锁和共享锁" class="headerlink" title="独占锁和共享锁"></a>独占锁和共享锁</h2><p>根据锁只能被单个线程持有还是能被多个线程共同持有，锁可以分为独占锁和共享锁：</p>
<ul>
<li>独占锁保证任何时候都只有一个线程能得到锁， <code>ReentrantLock</code> 就是以独占方式实现的。独占锁是一种悲观锁，由于每次访问资源都先加上互斥锁，这限制了并发性，因为读操作并不会影响数据的一致性，而独占锁只允许在同一时间由一个线程读取数据，其他线程必须等待当前线程释放锁才能进行读取。</li>
<li>共享锁则可以同时由多个线程持有，例如<code>ReadWriteLock</code> 读写锁，它允许一个资源可以被多线程同时进行读操作。共享锁则是一种乐观锁，它放宽了加锁的条件，允许多个线程同时进行读操作</li>
</ul>
<h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><p>当一个线程要获取一个被其他线程持有的独占锁时，该线程会被阻塞，那么当一个线程再次获取它自己己经获取的锁时，如果不被阻塞，那么我们说该锁是可重入的，也就是只要该线程获取了该锁，那么可以无限次数（严格来说是有限次数）地进入被该锁锁住的代码。</p>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>由于Java 中的线程是与操作系统中的线程一一对应的，所以当一个线程在获取锁（比如独占锁）失败后，会被切换到内核状态而被挂起。当该线程获取到锁时又需要将其切换到内核状态而唤醒该线程。而从用户状态切换到内核状态的开销是比较大的，在一定程度上会影响并发性能。自旋锁则是，当前线程在获取锁时，如果发现锁已经被其他线程占有，它不马上阻塞自己，在不放弃CPU 使用权的情况下，多次尝试获取，很有可能在后面几次尝试中其他线程己经释放了锁。如果尝试指定的次数后仍没有获取到锁则当前线程才会被阻塞挂起。由此看来自旋锁是使用CPU 时间换取线程阻塞与调度的开销，但是很有可能这些CPU 时间白白浪费了。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>笔记</tag>
        <tag>并发</tag>
        <tag>java并发编程之美</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发队列简介</title>
    <url>/2021/12/01/java/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/%E5%B9%B6%E5%8F%91%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>JDK 中提供了一系列场景的并发安全队列。总的来说，按照实现方式的不同可分为阻塞队列和非阻塞队列，前者使用锁实现，而后者则使用CAS 非阻塞算法实现。</p>
<span id="more"></span>

<h1 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h1><p><code>ConcurrentLinkedQueue</code> 是线程安全的无界非阻塞队列，其底层数据结构使用单向链表实现，对于入队和出队操作<strong>使用CAS 来实现线程安全</strong>。</p>
<p><code>ConcurrentLinkedQueue</code> 的底层使用单向链表数据结构来保存队列元素，每个元素被包装成一个Node 节点。队列是靠头、尾节点来维护的，创建队列时头、尾节点指向一个item 为null 的哨兵节点。第一次执行<code>peek</code> 操作时会把head 指向第一个真正的队列元素。由于使用非阻塞CAS 算法，没有加锁，所以在计算size 时有可能进行了<code>offer</code>、 <code>poll</code> 或者<code>remove</code> 操作， 导致<strong>计算的元素个数不精确</strong>，所以在井发情况下<code>size</code> 函数不是很有用。</p>
<p>如图所示，入队、出队都是操作使用<code>volatile</code> 修饰的<code>tail</code> 、<code>head</code> 节点，要保证在多线程下出入队线程安全，<strong>只需要保证这两个Node 操作的可见性和原子性即可</strong>。由于<code>volatile</code> 本身可以保证可见性，所以只需要保证对两个变量操作的原子性即可。</p>
<p><img src="http://image.onebug.tech/image-20211201121242572.png" alt="image-20211201121242572"></p>
<h1 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h1><p><code>LinkedBlockingQueue</code>是使用独占锁实现的阻塞队列。<code>LinkedBlockingQueue</code> 的内部是通过单向链表实现的，使用头、尾节点来进行入队和出队操作，也就是入队操作都是对尾节点进行操作，出队操作都是对头节点进行操作。</p>
<p>如图所示，<strong>对头、尾节点的操作分别使用了单独的独占锁从而保证了原子性，所以出队和入队操作是可以同时进行的。</strong>另外对头、尾节点的独占锁都配备了一个条件队列，用来存放被阻塞的线程，并结合入队、出队操作实现了一个生产消费模型。</p>
<p><img src="http://image.onebug.tech/image-20211201121921403.png" alt="image-20211201121921403"></p>
<h1 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h1><p><code>ArrayBlockingQueue</code>是有界数组方式实现的阻塞队列。</p>
<p>如图所示， <code>ArrayBlockingQueue</code> 通过<strong>使用全局独占锁实现了同时只能有一个线程进行入队或者出队操作</strong>，这个锁的粒度比较大。</p>
<p>其中，<code>offer</code>和<code>poll</code> 操作通过简单的加锁进行入队、出队操作，而<code>put</code> 、<code>take</code> 操作则使用条件变量实现，如果队列满则等待，如果队列空则等待，然后分别在出队和入队操作中发送信号激活等待线程实现同步。</p>
<p>另外，<strong>相比<code>LinkedBlockingQueue</code>，<code>ArrayBlockingQueue</code> 的<code>size</code>操作的结果是精确的</strong>， 因为计算前加了全局锁。</p>
<p><img src="http://image.onebug.tech/image-20211201122330680.png" alt="image-20211201122330680"></p>
<h1 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h1><p><code>PriorityBlockingQueue</code> 是带优先级的无界阻塞队列，<strong>每次出队都返回优先级最高或者最低的元素</strong>。其内部是使用<strong>平衡二叉树堆</strong>实现的，所以直接遍历队列元素不保证有序。默认使用对象的<code>compareTo</code> 方法提供比较规则，如果你需要自定义比较规则则可以自定义<code>comparators</code> 。</p>
<p>PriorityBlockingQueue 队列在内部使用二叉树堆维护元素优先级，使用数组作为元素存储的数据结构，这个数组是可扩容的。当元素个数＞＝最大容量时会通过CAS 算法扩容。</p>
<p><code>PriorityBlockingQueue</code> 类似于<code>ArrayBlockingQueue</code> ，<strong>在内部使用一个独占锁来控制，同时只有一个线程可以进行入队和出队操作</strong>。另外，<code>PriorityBlockingQueue</code>只使用了一个<code>notEmpty</code> 条件变量而没有使用<code>notFull</code> ，这是因为前者是无界队列。</p>
<p><img src="http://image.onebug.tech/image-20211201122801247.png" alt="image-20211201122801247"></p>
<h1 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h1><p><code>DelayQueue</code> 并发队列是一个无界阻塞延迟队列，队列中的每个元素都有个过期时间，<strong>当从队列获取元素时，只有过期元素才会出队列</strong>。队列头元素是最快要过期的元素。</p>
<p><strong>DelayQueue 内部使用PriorityQueue存放数据</strong>，使用<code>ReentrantLock</code> 实现线程同步。另外，队列里面的<strong>元素要实现<code>Delayed</code> 接口</strong>，由于每个元素都有一个过期时间，所以要实现获知当前元素还剩下多少时间就过期了的接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Delayed</span> <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;Delayed&gt; &#123;</span><br><span class="line">    <span class="comment">//获知当前元素还剩下多少时间就过期</span></span><br><span class="line">    <span class="type">long</span> <span class="title function_">getDelay</span><span class="params">(TimeUnit unit)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://image.onebug.tech/image-20211201185757443.png" alt="image-20211201185757443"></p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>笔记</tag>
        <tag>并发</tag>
        <tag>java并发编程之美</tag>
      </tags>
  </entry>
  <entry>
    <title>AQS的经典应用--可重入独占锁的原理剖析</title>
    <url>/2021/11/22/java/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/%E7%8B%AC%E5%8D%A0%E9%94%81/</url>
    <content><![CDATA[<p><code>ReentrantLock</code> 是可重入的独占锁， 同时只能有一个线程可以获取该锁，其他获取该锁的线程会被阻塞而被放入该锁的<code>AQS</code> 阻塞队列里面。</p>
<p><code>ReentrantLock</code> 根据参数来决定其内部是一个公平还是非公平锁，默认是非公平锁。其中Sync 类直接继承自AQS ， 它的子类<code>NonfairSync</code> 和<code>FairSync</code> 分别实现了获取锁的非公平与公平策略。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="state的含义"><a href="#state的含义" class="headerlink" title="state的含义"></a>state的含义</h1><p>在<code>ReentrantLock</code> 中， AQS 的<code>state</code> 状态值表示线程获取<strong>该锁的可重入次数</strong>， 在默认情况下， <code>state</code>的值为0 表示当前锁没有被任何线程持有。当一个线程第一次获取该锁时会尝试使用CAS设置<code>state</code> 的值为1，如果CAS 成功则当前线程获取了该锁，然后记录该锁的持有者为当前线程。在该线程没有释放锁的情况下第二次获取该锁后，状态值被设置为2 ， 这就是可重入次数。在该线程释放该锁时，会尝试使用CAS 让状态值减1 ， 如果减1后状态值为0,则当前线程释放该锁。</p>
<h1 id="锁的获取"><a href="#锁的获取" class="headerlink" title="锁的获取"></a>锁的获取</h1><p><code>ReentrantLock</code> 的l<code>ock()</code>委托给了<code>sync</code> 类，根据创建<code>ReentrantLock</code> 构造函数选择sync 的实现是<code>NonfairSync</code> 还是<code>FairSync</code> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="非公平锁的获取"><a href="#非公平锁的获取" class="headerlink" title="非公平锁的获取"></a>非公平锁的获取</h2><p>默认AQS 的状态值为0，所以第一个调用<code>lock</code> 的线程会通过CAS 设置状态值为1, CAS 成功则表示当前线程获取到了锁， 然后<code>setExclusiveOwnerThread</code>设置该锁持有者是当前线程。如果这时候有其他线程调用<code>lock</code>方法企图获取该锁， CAS 会失败，然后会调用AQS的<code>acquire</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//cas设置状态值</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//调用AQS的acquire方法</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AQS 并没有提供可用的<code>tryAcquire</code> 方法， <code>tryAcquire</code> 方法需要子类自己定制化，<code>ReentrantLock</code>需要重写<code>tryAcquire</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="comment">//如果当前AQS状态为0</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//锁的持有锁是当前线程</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow，可重入次数溢出</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>nonfairTryAcquire</code>方法首先会查看当前锁的状态值是否为0 ，为0则说明当前该锁空闲，那么就尝试CAS 获取该锁，将AQS 的状态值从0 设置为1 ，并设置当前锁的持有者为当前线程然后返回 true 。如果当前状态值不为0 则说明该锁已经被某个线程持有，如果当前线程是该锁的持有者，则状态值加1 ，然后返回true 。 如果当前线程不是锁的持有者或者CAS获取锁失败则返回false，然后其会被放入AQS 阻塞队列。</p>
<p>需要注意的是，线程在CAS 获取锁前，并不会查看当前AQS 队列里面是否有比自己更早请求该锁的线程， 而是使用了抢夺策略，这就是不公平的体现。</p>
<h2 id="公平锁的获取"><a href="#公平锁的获取" class="headerlink" title="公平锁的获取"></a>公平锁的获取</h2><p>公平锁和非公平锁的获取不同之处在于重写的<code>tryAcquire</code>函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//公平性策略</span></span><br><span class="line">                <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>公平锁和非公平锁的<code>tryAcquire</code> 代码的类似，不同之处在于，<strong>公平锁在设置CAS 获取锁前添加了<code>hasQueuedPredecessors</code> 方法检查当前线程是否有前驱节点</strong>，该方法是实现公平性的核心代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasQueuedPredecessors</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">    <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">    <span class="comment">// thread is first in queue.</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">//s为队列的第一个元素</span></span><br><span class="line">    Node s;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">		<span class="comment">// 队列里面的第一个元素不是当前线程的判断：</span></span><br><span class="line">        <span class="comment">// h!=t&amp;&amp;s!=null&amp;&amp;s.thread!= Thread.cunentThread():</span></span><br><span class="line">        ((s = h.next) == <span class="literal">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果当前线程节点有前驱节点则返回true，否则如果当前AQS 队列为空或者当前线程节点是AQS 的第一个节点则返回false。</p>
<h1 id="锁的释放"><a href="#锁的释放" class="headerlink" title="锁的释放"></a>锁的释放</h1><p>如果当前线程持有该锁， 则调用该方法会让该线程对该线程持有的AQS状态值减1， 如果减去1 后当前状态值为0 ，则当前线程会释放该锁， 否则仅仅减1而己。同样.<code>ReentrantLock</code> 需要重写<code>tryRelease</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">	<span class="comment">//更新后的可重入次数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">    <span class="comment">//如果当前线程不是锁的持有者，抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//可重入次数变为0，将线程持有者设置为null</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                free = <span class="literal">true</span>;</span><br><span class="line">                setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="comment">//更新可重入次数</span></span><br><span class="line">            setState(c);</span><br><span class="line">            <span class="keyword">return</span> free;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h1 id="可重入锁使用案例"><a href="#可重入锁使用案例" class="headerlink" title="可重入锁使用案例"></a>可重入锁使用案例</h1><p>下面使用<code>ReentrantLock</code> 来实现一个简单的线程安全的list。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLockList</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">//线程不安全的list</span></span><br><span class="line">    List&lt;T&gt; list  = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//独占锁</span></span><br><span class="line">    <span class="keyword">final</span>  ReentrantLock lock=<span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">//添加元素</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T e)</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            list.add(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">            exception.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除元素</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            list.remove(index);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">            exception.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取元素</span></span><br><span class="line">    T <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> list.get(index);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">            exception.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上代码通过在操作<code>list</code>前进行加锁保证同一时间只有一个线程可以对<code>list</code>数组进行修改，但是也只能有一个线程对<code>list</code>元素进行访问。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>笔记</tag>
        <tag>并发</tag>
        <tag>java并发编程之美</tag>
      </tags>
  </entry>
  <entry>
    <title>读多写少的性能考虑--ReentrantReadWriteLock的原理剖析</title>
    <url>/2021/11/27/java/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/%E8%AF%BB%E5%86%99%E9%94%81/</url>
    <content><![CDATA[<p><code>ReentrantLock</code> 是独占锁， 某时只有一个线程可以获取该锁，而实际中会有写少读多的场景，<code>ReentrantReadWriteLock</code> 应运而生。<code>ReentrantReadWriteLock</code> 采用读写分离的策略，允许多个线程可以同时获取读锁。</p>
<p>读写锁的内部维护了一个<code>ReadLock</code> 和一个<code>WriteLock</code> ，它们依赖Sync 实现具体功能。</p>
<span id="more"></span>

<h1 id="state的含义"><a href="#state的含义" class="headerlink" title="state的含义"></a>state的含义</h1><p><code>ReentrantReadWriteLock</code> 需要维护读状态和写状态， 为了用一个state 表示写和读两种状态，<code>ReentrantReadWriteLock</code> 巧妙地使用<code>state</code> 的<strong>高16位表示读状态</strong>，也就是获取到读锁的次数；使用<strong>低16 位表示获取到写锁的线程的可重入次数</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHARED_SHIFT</span>   <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHARED_UNIT</span>    <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_COUNT</span>      <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">EXCLUSIVE_MASK</span> <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回以count表示的共享持有的数量[读线程数]</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sharedCount</span><span class="params">(<span class="type">int</span> c)</span>    &#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回count中所代表的排他性持有的数量[写锁可重入次数]</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">exclusiveCount</span><span class="params">(<span class="type">int</span> c)</span> &#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//用来每个线程的读锁可重入数的计数器</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">HoldCounter</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">tid</span> <span class="operator">=</span> getThreadId(Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h1><h2 id="写锁的获取"><a href="#写锁的获取" class="headerlink" title="写锁的获取"></a>写锁的获取</h2><p><strong>写锁是个独占锁</strong>， 某时只有一个线程可以获取该锁。如果当前没有线程获取到读锁和写锁， 则当前线程可以获取到写锁然后返回。如果当前己经有线程获取到读锁和写锁，则当前请求写锁的线程会被阻塞挂起。另外， 写锁是可重入锁，如果当前线程己经获取了该锁，再次获取只是简单地把可重入次数加1后直接返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">            sync.acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>其中重写的<code>tryAcquire</code>方法的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">			<span class="comment">//w是写锁线程的可重入次数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> exclusiveCount(c);</span><br><span class="line">            <span class="comment">//c!=0 说明已经有线程获获取了读锁或写锁</span></span><br><span class="line">            <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line">                <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">                <span class="comment">// Reentrant acquire</span></span><br><span class="line">                setState(c + acquires);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//第一个写线程获取先锁</span></span><br><span class="line">			<span class="comment">//writerShouldBlock()用来实现公平锁和非公平锁的区分</span></span><br><span class="line">            <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">                !compareAndSetState(c, c + acquires))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><code>c</code>是AQS状态变量，<code>w</code>是<code>c</code>的低16位（写状态）。</p>
<p><code>c!=0&amp;&amp;w==0</code>时说明状态值的的高16位（读状态）不为0，这说明了已经有线程获取了读锁，返回<code>false</code>。</p>
<p><code>c!=0&amp;&amp;w!=0&amp;&amp;current!= getExclusiveOwnerThread()</code> 则说明当前已经有线程获取了写锁，但是当前线程不是写锁的持有者，返回<code>false</code> 。</p>
<h2 id="写锁的释放"><a href="#写锁的释放" class="headerlink" title="写锁的释放"></a>写锁的释放</h2><p>如果当前线程持有写锁，调用锁释放方法会让该线程对该线程持有的AQS状态值减1 ，如果减去1后当前状态值为0 则当前线程会释放该锁， 否则仅仅减1而己。其中重写的<code>tryRelease</code>方法如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="comment">//看是否是写锁拥有者调用的unlock</span></span><br><span class="line">            <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">   <span class="comment">//获取可重入值， 这里没有考虑高16位， 因为获取写锁时读锁状态值肯定为0</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">    <span class="comment">//如采写锁可重入值为0 则释放锁，否则只是简单地更新状态值</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (free)</span><br><span class="line">                setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> free;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h1 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h1><h2 id="读锁的获取"><a href="#读锁的获取" class="headerlink" title="读锁的获取"></a>读锁的获取</h2><p>写锁是共享锁。获取读锁，如果当前<strong>没有其他线程持有写锁</strong>，则当前线程可以获取读锁， AQS 的状态值state 的高16 位的值会增加1 ，然后方法返回。否则如果其他一个线程持有写锁， 则当前线程会被阻塞。共享锁的<code>tryAcquireShared</code>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> unused)</span> &#123;</span><br><span class="line">    <span class="comment">//获取当前状态值</span></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="comment">//判断是否写锁被占用</span></span><br><span class="line">            <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                getExclusiveOwnerThread() != current)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//获取读锁计数，sharedCount返回c的高16位</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> sharedCount(c);</span><br><span class="line">   <span class="comment">//更新AQS状态值， 多个读线程只有一个会成功，不成功的进入fullTryAcquireShared进行重试。</span></span><br><span class="line">            <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">                r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">                compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">	<span class="comment">//更新一些记录信息</span></span><br><span class="line">                <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">                    firstReader = current;</span><br><span class="line">                    firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">               </span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                    firstReaderHoldCount++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">HoldCounter</span> <span class="variable">rh</span> <span class="operator">=</span> cachedHoldCounter;</span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="literal">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                        cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                        readHolds.set(rh);</span><br><span class="line">                    rh.count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="comment">//fullTryAcquireShared类似tryAcquireShared ，但是是自旋获取</span></span><br><span class="line">            <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>如上代码首先查看是否有其他线程获取到了写锁，如果是则直接返回-1。</p>
<blockquote>
<p>如果当前要获取读锁的线程己经持有了写锁， 则也可以获取读锁。但是需要注意，当一个线程先获取了写锁，然后获取了读锁处理事情完毕后，要记得把读锁和写锁都释放掉，不能只释放写锁。</p>
</blockquote>
<p>在线程尝试获取读锁前，会进行<code>readerShouldBlock</code>检查，其中非公平锁的<code>readerShouldBlock</code> 实现代码如下，代码的作用是检查队列的第一个元素是否存在以及是不是正在尝试获取写锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">readerShouldBlock</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> apparentlyFirstQueuedIsExclusive();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">apparentlyFirstQueuedIsExclusive</span><span class="params">()</span> &#123;</span><br><span class="line">    Node h, s;</span><br><span class="line">    <span class="keyword">return</span> (h = head) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        (s = h.next)  != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        <span class="comment">//判断第一个元素是不是独占锁</span></span><br><span class="line">        !s.isShared()         &amp;&amp;</span><br><span class="line">        s.thread != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进行<code>readerShouldBlock</code>检查后，还要检查获取读锁的线程是否达到了最大值，然后才是执行CAS 操作将AQS 状态值的高16 位值增加1。</p>
<p>更新AQS状态值后，最后还要更新一些重要的变量：</p>
<ul>
<li><code>firstReader</code>：用来记录第一个获取到读锁的线程</li>
<li><code>firstReaderHoldCount</code>：记录第一个获取到读锁的线程获取读锁的可重入次数</li>
<li><code>cachedHoldCounter</code>：记录最后一个获取读锁的线程获取读锁的可重入次数</li>
<li><code>readHolds</code>：ThreadLocal 变量， 用来存放除去第一个获取读锁线程外的其他线程获取读锁的可重入次数</li>
</ul>
<p><code>fullTryAcquireShared</code>类似<code>tryAcquireShared</code> ，但是是自旋获取。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">fullTryAcquireShared</span><span class="params">(Thread current)</span> &#123;</span><br><span class="line">            <span class="type">HoldCounter</span> <span class="variable">rh</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//for循环，自旋获取</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">//..code</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">                 <span class="comment">//..code</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">       </span><br></pre></td></tr></table></figure>

<h2 id="读锁的释放"><a href="#读锁的释放" class="headerlink" title="读锁的释放"></a>读锁的释放</h2><p><code>tryReleaseShared</code>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> unused)</span> &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="comment">//code</span></span><br><span class="line">    		<span class="comment">//循环直到自己的读计数-1 , CAS 更新成功</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">                <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c - SHARED_UNIT;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                    <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>在无限循环里面，首先获取当前AQS 状态值并将其保存到变量c ，然后变量c被减去一个读计数单位后使用CAS 操作更新AQS 状态值，如果更新成功则<strong>查看当前AQS 状态值是否为0</strong> ，为0则说明当前己经没有读线程占用读锁，则<code>tryReleaseShared</code> 返回true 。然后会调用<code>doReleaseShared</code> 方法<strong>释放一个由于获取写锁而被阻塞的线程</strong>，如果当前AQS 状态值不为0 ，则说明当前还有其他线程持有了读锁，所以<code>trγReleaseShared</code> 返回false 。如果<code>tryReaseShared</code> 中的CAS 更新AQS 状态值失败，则自旋重试直到成功。</p>
<h1 id="读写锁使用案例"><a href="#读写锁使用案例" class="headerlink" title="读写锁使用案例"></a>读写锁使用案例</h1><p>改造List，使得在读多写少的情况下保持性能和线程安全。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读多写少</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecureList</span> &lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    线程不安全的List</span></span><br><span class="line">    List&lt;T&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">final</span> ReentrantReadWriteLock reentrantReadWriteLock=<span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">final</span> Lock writeLock=reentrantReadWriteLock.writeLock();</span><br><span class="line">    <span class="keyword">final</span> Lock readLock=reentrantReadWriteLock.readLock();</span><br><span class="line"></span><br><span class="line">    T <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> list.get(index);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> index,T ele)</span>&#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            list.set(index,ele);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            list.remove(index);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="读写锁的改进"><a href="#读写锁的改进" class="headerlink" title="读写锁的改进"></a>读写锁的改进</h1><p><code>StampedLock</code> 是并发包里面JDK8 版本新增的一个锁，该锁提供了三种模式的读写控制，当调用获取锁的系列函数时，会返回一个long 型的变量，我们称之为戳记（ stamp)，这个戳记代表了锁的状态。其中t可系列获取锁的函数，当获取锁失败后会返回为0的stamp 值。当调用释放锁和转换锁的方法时需要传入获取锁时返回的stamp 值。</p>
<p><code>StampedLock</code> 提供的三种读写模式的锁分别如下：</p>
<ul>
<li>写锁<code>writeLock</code> ：独占锁。</li>
<li>悲观读锁<code>readLock</code> ：悲观是指在具体操作数据前其会悲观地认为其他线程可能要对自己操作的数据进行修改，所以需要先对数据加锁，这是在读少写多的情况下的一种考虑。</li>
<li>乐观读锁<code>tryOptimisticRead</code>：它是相对于悲观锁来说的，该锁的一个特点是适用于读多写少的场景， 因为获取读锁只是使用位操作进行检验，不涉及CAS 操作，所以效率会高很多，但是同时由于没有使用真正的锁，所以返回的不是最新的数据，但是一致性还是得到保障的。</li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>笔记</tag>
        <tag>并发</tag>
        <tag>java并发编程之美</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty的字节容器---ByteBuf</title>
    <url>/2021/09/04/java/netty/ByteBuf/</url>
    <content><![CDATA[<p>网络数据的基本单位总是字节。Java NIO 提供了<code>ByteBuffer</code> 作为它的字节容器，但是这个类使用起来过于复杂，而且也有些繁琐。Netty 的<code>ByteBuffer</code> 替代品是<code>ByteBuf</code>，一个强大的实现，既解决了JDK API 的局限性，又为网络应用程序的开发者提供了更好的API。<code>ByteBuf</code>本质的原理就是引用了一段内存，这段内存可以是堆内也可以是堆外的，然后用引用计数来控制这段内存是否需要被释放，使用读写指针来控制对 <code>ByteBuf</code> 的读写，可以理解为是外观模式的一种使用。</p>
<span id="more"></span>

<h1 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h1><p><img src="http://image.onebug.tech/image-20210903174536572.png" alt="image-20210903174536572"></p>
<ul>
<li><p><code>ByteBuf</code> 是一个字节容器，容器里面的的数据分为三个部分，第一个部分是已经丢弃的字节，这部分数据是无效的；第二部分是可读字节，这部分数据是 <code>ByteBuf</code> 的主体数据， 从 <code>ByteBuf</code> 里面读取的数据都来自这一部分;最后一部分的数据是可写字节，所有写到 <code>ByteBuf</code> 的数据都会写到这一段。</p>
</li>
<li><p>以上三段内容是被两个指针给划分出来的，从左到右，依次是读指针（<code>readerIndex</code>）、写指针（<code>writerIndex</code>），然后还有一个变量 <code>capacity</code>，表示 <code>ByteBuf</code> 底层内存的总容量。</p>
</li>
<li><p>从 <code>ByteBuf</code> 中每读取一个字节，<code>readerIndex</code> 自增1，<code>ByteBuf</code> 里面总共有 <code>writerIndex-readerIndex</code> 个字节可读, 由此可以推论出当 <code>readerIndex</code> 与 <code>writerIndex</code> 相等的时候，<code>ByteBuf</code> 不可读。</p>
</li>
<li><p>写数据是从 <code>writerIndex</code> 指向的部分开始写，每写一个字节，<code>writerIndex</code> 自增1，直到增到 <code>capacity</code>，这个时候，表示 <code>ByteBuf</code> 已经不可写了</p>
</li>
</ul>
<blockquote>
<p><code>ByteBuf</code> 里面其实还有一个参数 <code>maxCapacity</code>，当向 <code>ByteBuf</code> 写数据的时候，如果容量不足，那么这个时候可以进行扩容，直到 <code>capacity</code> 扩容到 <code>maxCapacity</code>，超过 <code>maxCapacity</code> 就会报错</p>
</blockquote>
<h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><h2 id="容量"><a href="#容量" class="headerlink" title="容量"></a>容量</h2><table>
<thead>
<tr>
<th>名 称</th>
<th>描 述</th>
</tr>
</thead>
<tbody><tr>
<td>capacity()</td>
<td>表示 <code>ByteBuf</code> 底层占用了多少字节的内存（包括丢弃的字节、可读字节、可写字节）</td>
</tr>
<tr>
<td>maxCapacity()</td>
<td>表示 <code>ByteBuf</code> 底层最大能够占用多少字节的内存，当向 <code>ByteBuf</code> 中写数据的时候，如果发现容量不足，则进行扩容，直到扩容到 <code>maxCapacity</code>，超过这个数，就抛异常</td>
</tr>
<tr>
<td>readableBytes()</td>
<td>表示 ByteBuf 当前可读的字节数，它的值等于 <code>writerIndex-readerIndex</code>，如果两者相等，则不可读，<code>isReadable()</code> 方法返回 <code>false</code></td>
</tr>
<tr>
<td>writableBytes()</td>
<td><code>ByteBuf</code> 当前可写的字节数，它的值等于 capacity-writerIndex，如果两者相等，则表示不可写，<code>isWritable()</code> 返回 <code>false</code>，但是这个时候，并不代表不能往 <code>ByteBuf</code> 中写数据了， 如果发现往 <code>ByteBuf</code> 中写数据写不进去的话，Netty 会自动扩容 <code>ByteBuf</code>，直到扩容到底层的内存大小为 <code>maxCapacity</code>，而 <code>maxWritableBytes()</code> 就表示可写的最大字节数，它的值等于 <code>maxCapacity-writerIndex</code></td>
</tr>
</tbody></table>
<h2 id="索引管理"><a href="#索引管理" class="headerlink" title="索引管理"></a>索引管理</h2><table>
<thead>
<tr>
<th>名 称</th>
<th>描 述</th>
</tr>
</thead>
<tbody><tr>
<td>readerIndex()</td>
<td>返回当前的读指针</td>
</tr>
<tr>
<td>writeIndex()</td>
<td>返回当前的写指针</td>
</tr>
<tr>
<td>markReaderIndex()</td>
<td>把当前的读指针保存起来</td>
</tr>
<tr>
<td>resetReaderIndex()</td>
<td>把当前的读指针恢复到之前保存的值</td>
</tr>
</tbody></table>
<h2 id="读写操作"><a href="#读写操作" class="headerlink" title="读写操作"></a>读写操作</h2><p>有两种类别的读&#x2F;写操作：</p>
<ul>
<li><code>get()</code>和<code>set()</code>操作，从给定的索引开始，并且保持索引不变；</li>
<li><code>read()</code>和<code>write()</code>操作，从给定的索引开始，并且会根据已经访问过的字节数对索引进行调整。</li>
</ul>
<p>基于读写指针和容量、最大可扩容容量，衍生出一系列的读写方法。其中比较重要的有：</p>
<table>
<thead>
<tr>
<th>名 称</th>
<th>描 述</th>
</tr>
</thead>
<tbody><tr>
<td>readByte()</td>
<td>返回当前<code>readerIndex</code> 处的字节，并将<code>readerIndex</code> 增加1（从 <code>ByteBuf</code> 中读取一个字节）</td>
</tr>
<tr>
<td>writeByte(int)</td>
<td>在当前<code>writerIndex</code> 处写入一个字节值，并将<code>writerIndex</code> 增加1（往 <code>ByteBuf</code> 中写一个字节）</td>
</tr>
<tr>
<td>readBytes(destination byte[])</td>
<td>把 <code>ByteBuf</code> 里面的数据全部读取到 <code>destination </code>（<code>ByteBuf</code>-&gt;<code>destination</code>）</td>
</tr>
<tr>
<td>writeBytes(source byte[])</td>
<td>把字节数组 <code>source</code> 里面的数据写到 <code>ByteBuf</code>（<code>source</code>-&gt;<code>ByteBuf</code>）</td>
</tr>
</tbody></table>
<p>类似的 API 还有 <code>writeBoolean()</code>、<code>writeChar()</code>、<code>writeShort()</code>、<code>writeInt()</code>、<code>writeLong()</code>、<code>writeFloat()</code>、<code>writeDouble()</code> 与 <code>readBoolean()</code>、<code>readChar()</code>、<code>readShort()</code>、<code>readInt()</code>、<code>readLong()</code>、<code>readFloat()</code>、<code>readDouble()</code> ，这里就不一一赘述了。</p>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>由于 Netty 可以使用堆外内存，而堆外内存是不被 <code>jvm</code> 直接管理的，也就是说申请到的内存无法被垃圾回收器直接回收，所以需要我们手动回收，否则会造成内存泄漏。Netty 的 <code>ByteBuf</code> 是通过<strong>引用计数</strong>的方式管理的，如果一个 <code>ByteBuf</code> 没有地方被引用到，需要回收底层内存。默认情况下，当创建完一个 <code>ByteBuf</code>，它的引用为1，然后每次调用 <code>retain()</code> 方法， 它的引用就<code>+1</code>， release() 方法原理是将引用计数<code>-1</code>，减完之后如果发现引用计数为0，则直接回收 <code>ByteBuf</code> 底层的内存。</p>
<h2 id="池化"><a href="#池化" class="headerlink" title="池化"></a>池化</h2><p>为了降低分配和释放内存的开销，Netty 通过 <code>ByteBufAllocator</code> 实现了<code>ByteBuf</code> 的池化，它可以用来分配我们所描述过的任意类型的<code>ByteBuf</code> 实例（直接内存、堆内存）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从Channel 获取一个到 ByteBufAllocator 的引用</span></span><br><span class="line"><span class="type">ByteBufAllocator</span> <span class="variable">allocator</span> <span class="operator">=</span> channel.alloc();</span><br><span class="line"></span><br><span class="line"><span class="comment">//从ChannelHandlerContext 获取一个到ByteBufAllocator 的引用</span></span><br><span class="line"><span class="type">ByteBufAllocator</span> <span class="variable">allocator2</span> <span class="operator">=</span> ctx.alloc();</span><br></pre></td></tr></table></figure>


<p>一般使用<code>buffer(int initialCapacity, int maxCapacity);</code>返回一个基于堆或者直接内存存储的<code>ByteBuf</code>。</p>
<h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p><code>slice()</code>、<code>duplicate()</code>、<code>copy()</code>三者的返回值都是一个新的 <code>ByteBuf</code> 对象：</p>
<ul>
<li><p><code>slice()</code> 方法从原始 <code>ByteBuf</code> 中截取一段，这段数据是从 <code>readerIndex</code> 到 <code>writeIndex</code>，同时，返回的新的 <code>ByteBuf</code> 的最大容量 <code>maxCapacity</code> 为原始 <code>ByteBuf</code> 的 <code>readableBytes()</code></p>
</li>
<li><p><code>duplicate()</code> 方法把整个 <code>ByteBuf</code> 都截取出来，包括所有的数据，指针信息</p>
<blockquote>
<p><code>slice()</code> 方法与 <code>duplicate()</code> 方法不会拷贝数据，它们只是通过改变读写指针来改变读写的行为。底层内存以及引用计数与原始的 <code>ByteBuf</code> 共享，也就是说返回的 <code>ByteBuf</code> 调用 <code>write</code> 系列方法都会影响到原始的 <code>ByteBuf</code>，但是它们都维持着与原始 <code>ByteBuf</code> 不同的读写指针。</p>
</blockquote>
</li>
<li><p><code>copy()</code> 会直接从原始的 <code>ByteBuf</code> 中拷贝所有的信息，包括读写指针以及<strong>底层对应的数据</strong>，因此， <code>copy()</code> 返回的 <code>ByteBuf</code> 中写数据不会影响到原始的 <code>ByteBuf</code></p>
</li>
<li><p><code>retainedSlice()</code> 与 <code>retainedDuplicate()</code>它们的作用是在截取内存片段的同时，增加内存的引用计数。</p>
</li>
</ul>
<p>多个 <code>ByteBuf</code> 可以引用同一段内存，而Netty会通过引用计数来控制内存的释放，应当遵循谁 <code>retain()</code> 谁 <code>release()</code> 的原则。我们建议，在一个函数体里面，只要增加了引用计数（包括 <code>ByteBuf</code> 的创建和手动调用 <code>retain()</code> 方法），就必须调用 <code>release()</code> 方法，否则往往会出现内存泄露的问题。</p>
]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>ByteBuf</tag>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty的优化</title>
    <url>/2021/09/30/java/netty/Netty%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="共享Handler"><a href="#共享Handler" class="headerlink" title="共享Handler"></a>共享Handler</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">serverBootstrap</span><br><span class="line">                .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> &#123;</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">Spliter</span>());<span class="comment">//帧解码器</span></span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">PacketDecoder</span>());<span class="comment">//数据包解码器</span></span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">HandlerA</span>());<span class="comment">//业务Handler</span></span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">HandlerB</span>());<span class="comment">//业务Handler</span></span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">HandlerC</span>());<span class="comment">//业务Handler</span></span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">PacketEncoder</span>());<span class="comment">//数据包编码器</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure>

<p>每次有新连接到来的时候，都会调用 <code>ChannelInitializer</code> 的 <code>initChannel()</code> 方法，然后这里相关的 <code>handler</code> 都会被 <code>new</code> 一次。许多 <code>handler</code>，他们内部都是没有成员变量的，也就是说是无状态的，我们完全可以使用单例模式，即调用 <code>pipeline().addLast()</code> 方法的时候，都直接使用单例，不需要每次都 <code>new</code>，提高效率，也避免了创建很多小的对象。</p>
<p>单例改造：对于无状态<code>Handler</code>，使用单例模式，多个channel共享一个实例</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 1. 加上注解标识，表明该 handler 是可以多个 channel 共享的</span></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerA</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;APacket&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 构造单例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">HandlerA</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerA</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">HandlerA</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>@ChannelHandler.Sharable</code> 显示地告诉 Netty，这个 handler 是支持多个 channel 共享的，否则会报错。</p>
</blockquote>
<h1 id="合并编解码器"><a href="#合并编解码器" class="headerlink" title="合并编解码器"></a>合并编解码器</h1><p>Netty 内部提供了一个类，叫做 <code>MessageToMessageCodec</code>，使用它可以让我们的编解码操作放到一个类里面去实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PacketCodecHandler</span> <span class="keyword">extends</span> <span class="title class_">MessageToMessageCodec</span>&lt;ByteBuf,Packet&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> PacketCodecHandler INSTANCE=<span class="keyword">new</span> <span class="title class_">PacketCodecHandler</span>();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(ChannelHandlerContext ctx, Packet msg, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        out.add(PacketCodeC.DEFAULT.encode(ctx.alloc(),msg));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf msg, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        out.add(PacketCodeC.DEFAULT.decode(msg));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> <code>PacketCodecHandler</code>一般是一个无状态的 <code>handler</code>，因此，同样可以使用单例模式来实现。我们需要实现 <code>MessageToMessageCodec</code>的<code>decode()</code> 和 <code>encode()</code> 方法，<code>decode</code> 是将二进制数据 <code>ByteBuf</code> 转换为 java 对象 <code>Packet</code>，而 <code>encode</code> 操作是一个相反的过程，在 <code>encode()</code> 方法里面，我们需要传入了 <code>channel</code> 的 内存分配器，手工分配了 <code>ByteBuf</code>。</p>
<h1 id="缩短事件传播路径"><a href="#缩短事件传播路径" class="headerlink" title="缩短事件传播路径"></a>缩短事件传播路径</h1><h2 id="合并平行-handler"><a href="#合并平行-handler" class="headerlink" title="合并平行 handler"></a>合并平行 handler</h2><p>在很多情况下，每次 decode 出来一个指令对象之后，其实只会在一个指令 <code>handler</code> 上进行处理，因此，我们其实可以把这么多的指令 <code>handler</code> 压缩为一个 <code>handler</code>实现路由功能</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ChannelHandler.Sharable</span><br><span class="line">public class RouteHandler extends SimpleChannelInboundHandler&lt;Packet&gt; &#123;</span><br><span class="line">    public static final RouteHandler INSTANCE = new RouteHandler();</span><br><span class="line"></span><br><span class="line">    private Map&lt;Byte, SimpleChannelInboundHandler&lt;? extends Packet&gt;&gt; routeMap;</span><br><span class="line"></span><br><span class="line">    private IMHandler() &#123;</span><br><span class="line">        routeMap = new HashMap&lt;Byte, SimpleChannelInboundHandler&lt;? extends Packet&gt;&gt;()&#123;&#123;</span><br><span class="line">            put(CommandA, HandlerA.INSTANCE);</span><br><span class="line">           	put(CommandB, HandlerB.INSTANCE);</span><br><span class="line">           	put(CommandC, HandlerC.INSTANCE);</span><br><span class="line"></span><br><span class="line">        &#125;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void channelRead0(ChannelHandlerContext ctx, Packet packet) throws Exception &#123;</span><br><span class="line">        routeMap.get(packet.getCommand()).channelRead(ctx, packet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过上述优化方法后，我们的<code>pipeline</code>最终变成这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">serverBootstrap</span><br><span class="line">                .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    protected void initChannel(NioSocketChannel ch) &#123;</span><br><span class="line">                        ch.pipeline().addLast(new Spliter());//帧解码器</span><br><span class="line">                        ch.pipeline().addLast(new PacketCodecHandler.INSTANCE());//数据包编解码器</span><br><span class="line">                        ch.pipeline().addLast(RouteHandler.INSTANCE);//路由</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第一个<code>Handler</code>是帧解码器 <code>Spliter</code>，我们是无法使用单例模式进行改造的，因为他内部实现是与每个 <code>channel</code> 有关，每个 <code>Spliter</code> 需要维持每个 channel 当前读到的数据，也就是说他是有状态的。</p>
</blockquote>
<h2 id="更改事件传播源"><a href="#更改事件传播源" class="headerlink" title="更改事件传播源"></a>更改事件传播源</h2><p>如果你的 <code>outBound</code> 类型的 <code>handler</code> 较多，在写数据的时候能用 <code>ctx.writeAndFlush()</code> 就用这个方法。</p>
<p><code>ctx.writeAndFlush()</code> 是从 pipeline 链中的当前节点开始往前找到第一个 outBound 类型的 handler 把对象往前进行传播，如果这个对象确认不需要经过其他 outBound 类型的 handler 处理，就使用这个方法。</p>
<p><img src="http://image.onebug.tech/1664b767ddcf7711~tplv-t2oaga2asx-watermark.awebp" alt="image.png"></p>
<p><code>ctx.channel().writeAndFlush()</code> 是从 <code>pipeline</code> 链中的最后一个 <code>outBound</code> 类型的 <code>handler</code> 开始，把对象往前进行传播，如果你确认当前创建的对象需要经过后面的 <code>outBound</code> 类型的 handler，那么就调用此方法。</p>
<p><img src="http://image.onebug.tech/1664b767de0cf5ea~tplv-t2oaga2asx-watermark.awebp" alt="image.png"></p>
<h1 id="减少阻塞主线程的操作"><a href="#减少阻塞主线程的操作" class="headerlink" title="减少阻塞主线程的操作"></a>减少阻塞主线程的操作</h1><p>通常我们的应用程序会涉及到数据库或者网络，比如以下这个例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, T packet)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. balabala 一些逻辑</span></span><br><span class="line">    <span class="comment">// 2. 数据库或者网络等一些耗时的操作</span></span><br><span class="line">    <span class="comment">// 3. writeAndFlush()</span></span><br><span class="line">    <span class="comment">// 4. balabala 其他的逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于Netty是基于事件驱动的异步网络框架，一个 <code>handler</code> 中的 <code>channelRead0()</code> 方法阻塞了 NIO 线程，最终都会拖慢绑定在该 NIO 线程上的其他所有的 <code>channel</code>。对于耗时的操作，我们需要把这些耗时的操作丢到我们的业务线程池或利用消息队列中去处理，这样，就可以避免一些耗时的操作影响 Netty 的 NIO 线程，从而影响其他的 <code>channel</code>。</p>
]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty的责任链</title>
    <url>/2021/09/05/java/netty/pipeline%E5%92%8CchannelHandler/</url>
    <content><![CDATA[<p>为了避免逻辑判断泛滥导致的拓展性受限问题，Netty 发明了 <code>pipeline</code> 和 <code>channelHandler</code> 。它通过<strong>责任链设计模式</strong>来组织代码逻辑，并且能够支持逻辑的动态添加和删除 ，Netty 能够支持各类协议的扩展，比如 HTTP，WebSocket，Redis，靠的就是 <code>pipeline</code> 和 <code>channelHandler</code>。</p>
<span id="more"></span>

<h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p><img src="http://image.onebug.tech/image-20210905211158604.png" alt="image-20210905211158604"></p>
<p>在 Netty 整个框架里面，一条连接对应着一个 <code>Channel</code>，这条 <code>Channel</code> 所有的处理逻辑都在一个叫做 <code>ChannelPipeline</code> 的对象里面，<code>ChannelPipeline</code> 是一个双向链表结构，他和 <code>Channel</code> 之间是一对一的关系。</p>
<p><code>ChannelPipeline</code> 里面每个节点都是一个 <code>ChannelHandlerContext</code> 对象，这个对象能够拿到和 Channel 相关的所有的上下文信息，然后这个对象包着一个重要的对象，那就是逻辑处理器 <code>ChannelHandler</code>。</p>
<h1 id="channelHandler-家族"><a href="#channelHandler-家族" class="headerlink" title="channelHandler 家族"></a>channelHandler 家族</h1><p><img src="http://image.onebug.tech/image-20210905211319568.png" alt="image-20210905211319568"></p>
<p>入站操作和数据由 <code>ChannelInboundHandler</code>处理。 在开始组装响应之前的所有的逻辑，都可以放置在 <code>ChannelInboundHandler</code> 里处理，它的一个最重要的方法就是 <code>channelRead()</code>。比如，我们在一端读到一段数据，首先要解析这段数据，然后对这些数据做一系列逻辑处理，最终把响应写到对端。</p>
<p>出站操作和数据将由<code>ChannelOutboundHandler</code> 处理。它是定义我们一端在组装完响应之后，把数据写到对端的逻辑，它里面最核心的一个方法就是 <code>write()</code>。比如，我们封装好一个 <code>response</code> 对象，接下来我们有可能对这个 <code>response</code> 做一些其他的特殊逻辑，然后，再编码成 <code>ByteBuf</code>，最终写到对端。</p>
<p>这两个子接口分别有对应的默认实现，<code>ChannelInboundHandlerAdapter</code>和 <code>ChanneloutBoundHandlerAdapter</code>，它们分别实现了两大接口的所有功能，默认情况下会把读写事件传播到下一个 <code>handler</code>。</p>
<h1 id="事件传播"><a href="#事件传播" class="headerlink" title="事件传播"></a>事件传播</h1><p>Netty通过<strong>责任链设计模式</strong>来组织代码逻辑，所谓的事件传播其实就是事件在<code>ChannelPipeline</code>上移动。</p>
<p>可以看到<code>ChannelPipeline</code>是由一系列<code>ChannelHandlers</code>组成，其还提供了通过自身传播事件的方法，<strong>当进站事件触发时，其从<code>ChannelPipeline</code>的头部传递到尾部，而出站事件会从右边传递到左边。</strong></p>
<p>当管道传播事件时，其会确定下一个<code>ChannelHandler</code>的类型是否与移动方向匹配，若不匹配，则会跳过并寻找下一个，直至找到相匹配的<code>ChannelHandler</code>（一个处理器可以会同时实现<code>ChannelInboundHandler</code>和<code>ChannelOutboundHandler</code>）。</p>
<p><img src="http://image.onebug.tech/616953-20170524202716435-790612436.png" alt="img"></p>
<p>关于<code>ChannelInboundHandler</code> 和<code>ChanneloutBoundHandler</code>的传播顺序的不同，可以看下面的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">serverBootstrap</span><br><span class="line">        .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> &#123;</span><br><span class="line">                <span class="comment">// inBound，处理读数据的逻辑链</span></span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">InBoundHandlerA</span>());</span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">InBoundHandlerB</span>());</span><br><span class="line">                </span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">OutBoundHandlerD</span>());</span><br><span class="line"></span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">InBoundHandlerC</span>());</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// outBound，处理写数据的逻辑链</span></span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">OutBoundHandlerE</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<p>在该例子中，<code>pipeline</code> 的执行顺序是：<code>InBoundHandlerA</code>-&gt;<code>InBoundHandlerB()</code>-&gt;<code>InBoundHandlerC()</code>-&gt;<code>OutBoundHandlerE()</code></p>
<blockquote>
<p><code>channelPipeline</code>是双向链表，<code>inBoundHandler</code> 的事件通常只会传播到下一个 <code>inBoundHandler</code>，<code>outBoundHandler</code> 的事件通常只会传播到下一个 <code>outBoundHandler</code>，两者相互不受干扰。</p>
</blockquote>
<p><code>inBoundHandler</code> 的执行顺序与我们实际的添加顺序相同，而 <code>outBoundHandler</code> 则相反。</p>
]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title>心跳与空闲检测</title>
    <url>/2021/09/30/java/netty/%E5%BF%83%E8%B7%B3%E4%B8%8E%E7%A9%BA%E9%97%B2%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<h2 id="1-网络问题"><a href="#1-网络问题" class="headerlink" title="1. 网络问题"></a>1. 网络问题</h2><p>下图是网络应用程序普遍会遇到的一个问题：连接假死</p>
<p><img src="http://image.onebug.tech/1664c39eb393e946~tplv-t2oaga2asx-watermark.awebp" alt="image.png"></p>
<p>连接假死的现象是：在某一端（服务端或者客户端）看来，底层的 TCP 连接已经断开了，但是应用程序并没有捕获到，因此会认为这条连接仍然是存在的，从 TCP 层面来说，只有收到四次握手数据包或者一个 RST 数据包，连接的状态才表示已断开。</p>
<p>连接假死会带来以下两大问题</p>
<span id="more"></span>

<ol>
<li>对于服务端来说，因为每条连接都会耗费 cpu 和内存资源，大量假死的连接会逐渐耗光服务器的资源，最终导致性能逐渐下降，程序奔溃。</li>
<li>对于客户端来说，连接假死会造成发送数据超时，影响用户体验。</li>
</ol>
<p>通常，连接假死由以下几个原因造成的</p>
<ol>
<li>应用程序出现线程堵塞，无法进行数据的读写。</li>
<li>客户端或者服务端网络相关的设备出现故障，比如网卡，机房故障。</li>
<li>公网丢包。公网环境相对内网而言，非常容易出现丢包，网络抖动等现象，如果在一段时间内用户接入的网络连续出现丢包现象，那么对客户端来说数据一直发送不出去，而服务端也是一直收不到客户端来的数据，连接就一直耗着。</li>
</ol>
<p>如果我们的应用是面向用户的，那么公网丢包这个问题出现的概率是非常大的。对于内网来说，内网丢包，抖动也是会有一定的概率发生。一旦出现此类问题，客户端和服务端都会受到影响，接下来，我们分别从服务端和客户端的角度来解决连接假死的问题。</p>
<h2 id="2-服务端空闲检测"><a href="#2-服务端空闲检测" class="headerlink" title="2. 服务端空闲检测"></a>2. 服务端空闲检测</h2><p>对于服务端来说，客户端的连接如果出现假死，那么服务端将无法收到客户端的数据，也就是说，如果能一直收到客户端发来的数据，那么可以说明这条连接还是活的，因此，服务端对于连接假死的应对策略就是空闲检测。</p>
<p>何为空闲检测？空闲检测指的是每隔一段时间，检测这段时间内是否有数据读写，简化一下，我们的服务端只需要检测一段时间内，是否收到过客户端发来的数据即可，Netty 自带的 <code>IdleStateHandler</code> 就可以实现这个功能。</p>
<p>接下来，我们写一个类继承自 <code>IdleStateHandler</code>，来定义检测到假死连接之后的逻辑。</p>
<blockquote>
<p>IMIdleStateHandler.java</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class IMIdleStateHandler extends IdleStateHandler &#123;</span><br><span class="line"></span><br><span class="line">    private static final int READER_IDLE_TIME = 15;</span><br><span class="line"></span><br><span class="line">    public IMIdleStateHandler() &#123;</span><br><span class="line">        super(READER_IDLE_TIME, 0, 0, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void channelIdle(ChannelHandlerContext ctx, IdleStateEvent evt) &#123;</span><br><span class="line">        System.out.println(READER_IDLE_TIME + &quot;秒内未读到数据，关闭连接&quot;);</span><br><span class="line">        ctx.channel().close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>首先，我们观察一下 <code>IMIdleStateHandler</code> 的构造函数，他调用父类 <code>IdleStateHandler</code> 的构造函数，有四个参数，其中第一个表示读空闲时间，指的是在这段时间内如果没有数据读到，就表示连接假死；第二个是写空闲时间，指的是 在这段时间如果没有写数据，就表示连接假死；第三个参数是读写空闲时间，表示在这段时间内如果没有产生数据读或者写，就表示连接假死。写空闲和读写空闲为0，表示我们不关心者两类条件；最后一个参数表示时间单位。在我们的例子中，表示的是：如果 15 秒内没有读到数据，就表示连接假死。</li>
<li>连接假死之后会回调 <code>channelIdle()</code> 方法，我们这个方法里面打印消息，并手动关闭连接。</li>
</ol>
<p>接下来，我们把这个 handler 插入到服务端 pipeline 的最前面</p>
<blockquote>
<p>NettyServer.java</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">serverBootstrap</span><br><span class="line">        .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">            protected void initChannel(NioSocketChannel ch) &#123;</span><br><span class="line">                // 空闲检测</span><br><span class="line">                ch.pipeline().addLast(new IMIdleStateHandler());</span><br><span class="line">                ch.pipeline().addLast(new Spliter());</span><br><span class="line">                // ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<p>为什么要插入到最前面？是因为如果插入到最后面的话，如果这条连接读到了数据，但是在 inBound 传播的过程中出错了或者数据处理完完毕就不往后传递了（我们的应用程序属于这类），那么最终 <code>IMIdleStateHandler</code> 就不会读到数据，最终导致误判。</p>
<p>服务端的空闲检测时间完毕之后，接下来我们再思考一下，在一段时间之内没有读到客户端的数据，是否一定能判断连接假死呢？并不能，如果在这段时间之内客户端确实是没有发送数据过来，但是连接是 ok 的，那么这个时候服务端也是不能关闭这条连接的，为了防止服务端误判，我们还需要在客户端做点什么。</p>
<h2 id="3-客户端定时发心跳"><a href="#3-客户端定时发心跳" class="headerlink" title="3. 客户端定时发心跳"></a>3. 客户端定时发心跳</h2><p>服务端在一段时间内没有收到客户端的数据，这个现象产生的原因可以分为以下两种：</p>
<ol>
<li>连接假死。</li>
<li>非假死状态下确实没有发送数据。</li>
</ol>
<p>我们只需要排除掉第二种可能性，那么连接自然就是假死的。要排查第二种情况，我们可以在客户端定期发送数据到服务端，通常这个数据包称为心跳数据包，接下来，我们定义一个 handler，定期发送心跳给服务端</p>
<blockquote>
<p>HeartBeatTimerHandler.java</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class HeartBeatTimerHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    private static final int HEARTBEAT_INTERVAL = 5;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        scheduleSendHeartBeat(ctx);</span><br><span class="line"></span><br><span class="line">        super.channelActive(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void scheduleSendHeartBeat(ChannelHandlerContext ctx) &#123;</span><br><span class="line">        ctx.executor().schedule(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            if (ctx.channel().isActive()) &#123;</span><br><span class="line">                ctx.writeAndFlush(new HeartBeatRequestPacket());</span><br><span class="line">                scheduleSendHeartBeat(ctx);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;, HEARTBEAT_INTERVAL, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ctx.executor()</code> 返回的是当前的 channel 绑定的 NIO 线程，不理解没关系，只要记住就行，然后，NIO 线程有一个方法，<code>schedule()</code>，类似 jdk 的延时任务机制，可以隔一段时间之后执行一个任务，而我们这边是实现了每隔 5 秒，向服务端发送一个心跳数据包，这个时间段通常要比服务端的空闲检测时间的一半要短一些，我们这里直接定义为空闲检测时间的三分之一，主要是为了排除公网偶发的秒级抖动。</p>
<p>实际在生产环境中，我们的发送心跳间隔时间和空闲检测时间可以略长一些，可以设置为几分钟级别，具体应用可以具体对待，没有强制的规定。</p>
<p>我们上面其实解决了服务端的空闲检测问题，服务端这个时候是能够在一定时间段之内关掉假死的连接，释放连接的资源了，但是对于客户端来说，我们也需要检测到假死的连接。</p>
<h2 id="4-服务端回复心跳与客户端空闲检测"><a href="#4-服务端回复心跳与客户端空闲检测" class="headerlink" title="4. 服务端回复心跳与客户端空闲检测"></a>4. 服务端回复心跳与客户端空闲检测</h2><p>客户端的空闲检测其实和服务端一样，依旧是在客户端 pipeline 的最前方插入 <code>IMIdleStateHandler</code></p>
<blockquote>
<p>NettyClient.java</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bootstrap</span><br><span class="line">        .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">            public void initChannel(SocketChannel ch) &#123;</span><br><span class="line">                // 空闲检测</span><br><span class="line">                ch.pipeline().addLast(new IMIdleStateHandler());</span><br><span class="line">                ch.pipeline().addLast(new Spliter());</span><br><span class="line">                // ...</span><br></pre></td></tr></table></figure>

<p>然后为了排除是否是因为服务端在非假死状态下确实没有发送数据，服务端也要定期发送心跳给客户端。</p>
<p>而其实在前面我们已经实现了客户端向服务端定期发送心跳，服务端这边其实只要在收到心跳之后回复客户端，给客户端发送一个心跳响应包即可。如果在一段时间之内客户端没有收到服务端发来的数据，也可以判定这条连接为假死状态。</p>
<p>因此，服务端的 pipeline 中需要再加上如下一个 handler - <code>HeartBeatRequestHandler</code>，由于这个 handler 的处理其实是无需登录的，所以，我们将该 handler 放置在 <code>AuthHandler</code> 前面</p>
<blockquote>
<p>NettyServer.java</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">serverBootstrap</span><br><span class="line">                ch.pipeline().addLast(new IMIdleStateHandler());</span><br><span class="line">                ch.pipeline().addLast(new Spliter());</span><br><span class="line">                ch.pipeline().addLast(PacketCodecHandler.INSTANCE);</span><br><span class="line">                ch.pipeline().addLast(LoginRequestHandler.INSTANCE);</span><br><span class="line">                // 加在这里</span><br><span class="line">                ch.pipeline().addLast(HeartBeatRequestHandler.INSTANCE);</span><br><span class="line">                ch.pipeline().addLast(AuthHandler.INSTANCE);</span><br><span class="line">                ch.pipeline().addLast(IMHandler.INSTANCE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<p><code>HeartBeatRequestHandler</code> 相应的实现为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ChannelHandler.Sharable</span><br><span class="line">public class HeartBeatRequestHandler extends SimpleChannelInboundHandler&lt;HeartBeatRequestPacket&gt; &#123;</span><br><span class="line">    public static final HeartBeatRequestHandler INSTANCE = new HeartBeatRequestHandler();</span><br><span class="line"></span><br><span class="line">    private HeartBeatRequestHandler() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void channelRead0(ChannelHandlerContext ctx, HeartBeatRequestPacket requestPacket) &#123;</span><br><span class="line">        ctx.writeAndFlush(new HeartBeatResponsePacket());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现非常简单，只是简单地回复一个 <code>HeartBeatResponsePacket</code> 数据包。客户端在检测到假死连接之后，断开连接，然后可以有一定的策略去重连，重新登录等等，这里就不展开了，留给读者自行实现。</p>
<p>关于心跳与健康检测相关的内容就讲解到这里，原理理解清楚了并不难实现，最后，我们来对本小节内容做一下总结。</p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><ol>
<li>我们首先讨论了连接假死相关的现象以及产生的原因。</li>
<li>要处理假死问题首先我们要实现客户端与服务端定期发送心跳，在这里，其实服务端只需要对客户端的定时心跳包进行回复。</li>
<li>客户端与服务端如果都需要检测假死，那么直接在 pipeline 的最前方插入一个自定义 <code>IdleStateHandler</code>，在 <code>channelIdle()</code> 方法里面自定义连接假死之后的逻辑。</li>
<li>通常空闲检测时间要比发送心跳的时间的两倍要长一些，这也是为了排除偶发的公网抖动，防止误判。</li>
</ol>
]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP的拆包和粘包</title>
    <url>/2021/09/06/java/netty/%E6%8B%86%E5%8C%85%E4%B8%8E%E7%B2%98%E5%8C%85/</url>
    <content><![CDATA[<h1 id="粘包、半包"><a href="#粘包、半包" class="headerlink" title="粘包、半包"></a>粘包、半包</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在网络传输中，粘包和半包应该是最常出现的问题。</p>
<p>TCP 传输中，客户端发送数据，实际是把数据写入到了 TCP 的缓存中，粘包和半包也就会在此时产生。</p>
<p>客户端给服务端发送了两条消息<code>ABC</code>和<code>DEF</code>，服务端这边的接收会有多少种情况呢？有可能是一次性收到了所有的消息<code>ABCDEF</code>，有可能是收到了三条消息<code>AB</code>、<code>CD</code>、<code>EF</code>。</p>
<p>上面所说的一次性收到了所有的消息<code>ABCDEF</code>，类似于粘包。如果客户端发送的包的大小比 TCP 的缓存容量小，并且 TCP 缓存可以存放多个包，那么客户端和服务端的一次通信就可能传递了多个包，这时候服务端从 TCP 缓存就可能一下读取了多个包，这种现象就叫<code>粘包</code>。</p>
<p>上面说的后面那种收到了三条消息<code>AB</code>、<code>CD</code>、<code>EF</code>，类似于半包。如果客户端发送的包的大小比 TCP 的缓存容量大，那么这个数据包就会被分成多个包，通过 Socket 多次发送到服务端，服务端第一次从接受缓存里面获取的数据，实际是整个包的一部分，这时候就产生了<code>半包</code>(半包不是说只收到了全包的一半，是说收到了全包的一部分)。</p>
<span id="more"></span>

<h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><p>因为TCP是面向连接的传输协议，TCP传输的数据是以流的形式，而流数据是没有明确的开始结尾边界，所以TCP也没办法判断哪一段流属于一个消息。</p>
<p><img src="http://image.onebug.tech/1460000021175323" alt="TCP协议传输过程.jpg"></p>
<p>因为TCP会根据缓冲区的实际情况进行包的划分，在业务上认为，有的包被拆分成多个包进行发送，也可能多个晓小的包封装成一个大的包发送，这就是TCP的粘包或者拆包。</p>
<p><img src="http://image.onebug.tech/1460000021175317" alt="粘包拆包图解.png"></p>
<p>假设客户端分别发送了两个数据包D1和D2给服务端，由于服务端一次读取到字节数是不确定的，故可能存在以下几种情况：</p>
<ol>
<li>服务端分两次读取到两个独立的数据包，分别是D1和D2，没有粘包和拆包。</li>
<li>服务端一次接收到了两个数据包，D1和D2粘在一起，发生粘包。</li>
<li>服务端分两次读取到数据包，第一次读取到了完整的D1包和D2包的部分内容，第二次读取到了D2包的剩余内容，发生拆包。</li>
<li>服务端分两次读取到数据包，第一次读取到部分D1包，第二次读取到剩余的D1包和全部的D2包。</li>
</ol>
<p>当TCP缓存再小一点的话，会把D1和D2分别拆成多个包发送。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>解决半包粘包的问题其实就是定义消息边界的问题。因为TCP只负责数据发送，并不处理业务上的数据，所以只能在上层应用协议栈解决，目前的解决方案归纳：</p>
<ol>
<li>消息定长，每个报文的大小固定，如果数据不够，空位补空格。</li>
<li>在包的尾部加回车换行符标识。</li>
<li>将消息分为消息头与消息体，消息头中包含消息总长度。</li>
<li>设计更复杂的协议。</li>
</ol>
<h1 id="Netty解决方案"><a href="#Netty解决方案" class="headerlink" title="Netty解决方案"></a>Netty解决方案</h1><h2 id="LineBasedFrameDecoder"><a href="#LineBasedFrameDecoder" class="headerlink" title="LineBasedFrameDecoder"></a>LineBasedFrameDecoder</h2><p>基于回车换行符的解码器，当遇到”n”或者 “rn”结束符时，分为一组。支持携带结束符或者不带结束符两种编码方式，也支持配置单行的最大长度。</p>
<h2 id="DelimiterBasedFrameDecoder"><a href="#DelimiterBasedFrameDecoder" class="headerlink" title="DelimiterBasedFrameDecoder"></a>DelimiterBasedFrameDecoder</h2><p>分隔符解码器，可以指定消息结束的分隔符，它可以自动完成以分隔符作为码流结束标识的消息的解码。回车换行解码器实际上是一种特殊的DelimiterBasedFrameDecoder解码器。</p>
<h2 id="FixedLengthFrameDecoder"><a href="#FixedLengthFrameDecoder" class="headerlink" title="FixedLengthFrameDecoder"></a>FixedLengthFrameDecoder</h2><p>固定长度解码器，它能够按照指定的长度对消息进行自动解码,当制定的长度过大，消息过短时会有资源浪费，但是使用起来简单。</p>
<h2 id="LengthFieldBasedFrameDecoder"><a href="#LengthFieldBasedFrameDecoder" class="headerlink" title="LengthFieldBasedFrameDecoder"></a>LengthFieldBasedFrameDecoder</h2><p>通用解码器，一般协议头中带有长度字段，通过使用LengthFieldBasedFrameDecoder传入特定的参数，来解决拆包粘包。</p>
]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>netty</tag>
      </tags>
  </entry>
</search>
